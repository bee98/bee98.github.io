<html>
<head><meta http-equiv=Content-Type content="text/html; charset=UTF-8">
<style type="text/css">
<!--
span.cls_004{font-family:"Verdana Bold",serif;font-size:8.1px;color:rgb(0,0,0);font-weight:bold;font-style:normal;text-decoration: none}
div.cls_004{font-family:"Verdana Bold",serif;font-size:8.1px;color:rgb(0,0,0);font-weight:bold;font-style:normal;text-decoration: none}
span.cls_005{font-family:"Verdana",serif;font-size:8.1px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_005{font-family:"Verdana",serif;font-size:8.1px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_035{font-family:"Verdana",serif;font-size:8.1px;color:rgb(0,0,204);font-weight:normal;font-style:normal;text-decoration: underline}
div.cls_035{font-family:"Verdana",serif;font-size:8.1px;color:rgb(0,0,204);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_006{font-family:Times,serif;font-size:10.6px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_006{font-family:Times,serif;font-size:10.6px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_007{font-family:Times,serif;font-size:10.6px;color:rgb(0,0,0);font-weight:normal;font-style:italic;text-decoration: none}
div.cls_007{font-family:Times,serif;font-size:10.6px;color:rgb(0,0,0);font-weight:normal;font-style:italic;text-decoration: none}
span.cls_009{font-family:Arial,serif;font-size:12.1px;color:rgb(50,203,204);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_009{font-family:Arial,serif;font-size:12.1px;color:rgb(50,203,204);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_010{font-family:Arial,serif;font-size:7.1px;color:rgb(50,203,204);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_010{font-family:Arial,serif;font-size:7.1px;color:rgb(50,203,204);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_008{font-family:Arial,serif;font-size:16.6px;color:rgb(53,66,120);font-weight:bold;font-style:normal;text-decoration: none}
div.cls_008{font-family:Arial,serif;font-size:16.6px;color:rgb(53,66,120);font-weight:bold;font-style:normal;text-decoration: none}
span.cls_012{font-family:Arial,serif;font-size:11.1px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_012{font-family:Arial,serif;font-size:11.1px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_013{font-family:Times,serif;font-size:11.1px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_013{font-family:Times,serif;font-size:11.1px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_014{font-family:Courier New,serif;font-size:11.1px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_014{font-family:Courier New,serif;font-size:11.1px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_003{font-family:Times,serif;font-size:12.1px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_003{font-family:Times,serif;font-size:12.1px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_015{font-family:Times,serif;font-size:10.6px;color:rgb(0,0,0);font-weight:bold;font-style:normal;text-decoration: none}
div.cls_015{font-family:Times,serif;font-size:10.6px;color:rgb(0,0,0);font-weight:bold;font-style:normal;text-decoration: none}
span.cls_016{font-family:Arial,serif;font-size:15.1px;color:rgb(53,66,120);font-weight:bold;font-style:normal;text-decoration: none}
div.cls_016{font-family:Arial,serif;font-size:15.1px;color:rgb(53,66,120);font-weight:bold;font-style:normal;text-decoration: none}
span.cls_017{font-family:Arial,serif;font-size:10.0px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_017{font-family:Arial,serif;font-size:10.0px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_036{font-family:Times,serif;font-size:10.6px;color:rgb(0,51,154);font-weight:normal;font-style:normal;text-decoration: underline}
div.cls_036{font-family:Times,serif;font-size:10.6px;color:rgb(0,51,154);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_019{font-family:Times,serif;font-size:10.6px;color:rgb(0,0,0);font-weight:bold;font-style:italic;text-decoration: none}
div.cls_019{font-family:Times,serif;font-size:10.6px;color:rgb(0,0,0);font-weight:bold;font-style:italic;text-decoration: none}
span.cls_020{font-family:Courier New,serif;font-size:10.0px;color:rgb(53,66,120);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_020{font-family:Courier New,serif;font-size:10.0px;color:rgb(53,66,120);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_021{font-family:Arial,serif;font-size:10.6px;color:rgb(53,66,120);font-weight:bold;font-style:normal;text-decoration: none}
div.cls_021{font-family:Arial,serif;font-size:10.6px;color:rgb(53,66,120);font-weight:bold;font-style:normal;text-decoration: none}
span.cls_022{font-family:Courier New,serif;font-size:10.0px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_022{font-family:Courier New,serif;font-size:10.0px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_023{font-family:Arial,serif;font-size:13.0px;color:rgb(53,66,120);font-weight:bold;font-style:normal;text-decoration: none}
div.cls_023{font-family:Arial,serif;font-size:13.0px;color:rgb(53,66,120);font-weight:bold;font-style:normal;text-decoration: none}
span.cls_024{font-family:Courier New,serif;font-size:11.6px;color:rgb(53,66,120);font-weight:bold;font-style:normal;text-decoration: none}
div.cls_024{font-family:Courier New,serif;font-size:11.6px;color:rgb(53,66,120);font-weight:bold;font-style:normal;text-decoration: none}
span.cls_037{font-family:Arial,serif;font-size:7.0px;color:rgb(0,51,154);font-weight:normal;font-style:normal;text-decoration: line-through}
div.cls_037{font-family:Arial,serif;font-size:7.0px;color:rgb(0,51,154);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_026{font-family:Arial,serif;font-size:7.0px;color:rgb(95,95,95);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_026{font-family:Arial,serif;font-size:7.0px;color:rgb(95,95,95);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_027{font-family:Arial,serif;font-size:9.1px;color:rgb(95,95,95);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_027{font-family:Arial,serif;font-size:9.1px;color:rgb(95,95,95);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_038{font-family:Arial,serif;font-size:9.1px;color:rgb(0,51,154);font-weight:normal;font-style:normal;text-decoration: underline}
div.cls_038{font-family:Arial,serif;font-size:9.1px;color:rgb(0,51,154);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_029{font-family:Courier New,serif;font-size:10.0px;color:rgb(53,66,120);font-weight:bold;font-style:normal;text-decoration: none}
div.cls_029{font-family:Courier New,serif;font-size:10.0px;color:rgb(53,66,120);font-weight:bold;font-style:normal;text-decoration: none}
span.cls_031{font-family:Arial,serif;font-size:10.6px;color:rgb(0,0,0);font-weight:bold;font-style:italic;text-decoration: none}
div.cls_031{font-family:Arial,serif;font-size:10.6px;color:rgb(0,0,0);font-weight:bold;font-style:italic;text-decoration: none}
span.cls_032{font-family:Arial,serif;font-size:10.6px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_032{font-family:Arial,serif;font-size:10.6px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_033{font-family:Times,serif;font-size:7.0px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
div.cls_033{font-family:Times,serif;font-size:7.0px;color:rgb(0,0,0);font-weight:normal;font-style:normal;text-decoration: none}
span.cls_034{font-family:Times,serif;font-size:10.6px;color:rgb(0,51,154);font-weight:normal;font-style:italic;text-decoration: none}
div.cls_034{font-family:Times,serif;font-size:10.6px;color:rgb(0,51,154);font-weight:normal;font-style:italic;text-decoration: none}
-->
</style>
<script type="text/javascript" src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/wz_jsgraphics.js"></script>
</head>
<body>
<div style="position:absolute;left:50%;margin-left:-297px;top:0px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background001.jpg" width=595 height=842></div>
<div style="position:absolute;left:161.88px;top:75.84px" class="cls_004"><span class="cls_004">Efficient C++ Performance Programming Techniques</span></div>
<div style="position:absolute;left:161.88px;top:93.00px" class="cls_005"><span class="cls_005">By </span><span class="cls_035">Dov Bulka</span><span class="cls_005">, </span><span class="cls_035">David Mayhew</span></div>
<div style="position:absolute;left:211.08px;top:123.00px" class="cls_005"><span class="cls_005">Publisher : Addison Wesley</span></div>
<div style="position:absolute;left:211.08px;top:138.00px" class="cls_005"><span class="cls_005">Pub Date : November 03, 1999</span></div>
<div style="position:absolute;left:227.28px;top:153.00px" class="cls_005"><span class="cls_005">ISBN : 0-201-37950-3</span></div>
<div style="position:absolute;left:99.96px;top:160.56px" class="cls_035"><span class="cls_035">Table of</span></div>
<div style="position:absolute;left:99.96px;top:170.28px" class="cls_035"><span class="cls_035">Contents</span></div>
<div style="position:absolute;left:224.16px;top:168.00px" class="cls_005"><span class="cls_005">Pages : 336</span></div>
<div style="position:absolute;left:160.68px;top:204.12px" class="cls_006"><span class="cls_006">Far too many programmers and software designers consider efficient C++ to be an</span></div>
<div style="position:absolute;left:160.68px;top:216.24px" class="cls_006"><span class="cls_006">oxymoron. They regard C++ as inherently slow and inappropriate for performance-</span></div>
<div style="position:absolute;left:160.68px;top:228.24px" class="cls_006"><span class="cls_006">critical applications. Consequently, C++ has had little success penetrating domains such</span></div>
<div style="position:absolute;left:160.68px;top:240.36px" class="cls_006"><span class="cls_006">as networking, operating system kernels, device drivers, and others.</span></div>
<div style="position:absolute;left:160.68px;top:266.40px" class="cls_007"><span class="cls_007">Efficient C++</span><span class="cls_006"> explodes that myth. Written by two authors with first-hand experience</span></div>
<div style="position:absolute;left:160.68px;top:278.52px" class="cls_006"><span class="cls_006">wringing the last ounce of performance from commercial C++ applications, this book</span></div>
<div style="position:absolute;left:160.68px;top:290.64px" class="cls_006"><span class="cls_006">demonstrates the potential of C++ to produce highly efficient programs. The book reveals</span></div>
<div style="position:absolute;left:160.68px;top:302.64px" class="cls_006"><span class="cls_006">practical, everyday object-oriented design principles and C++ coding techniques that can</span></div>
<div style="position:absolute;left:160.68px;top:314.76px" class="cls_006"><span class="cls_006">yield large performance improvements. It points out common pitfalls in both design and</span></div>
<div style="position:absolute;left:160.68px;top:326.76px" class="cls_006"><span class="cls_006">code that generate hidden operating costs.</span></div>
<div style="position:absolute;left:160.68px;top:352.92px" class="cls_006"><span class="cls_006">This book focuses on combining C++'s power and flexibility with high performance and</span></div>
<div style="position:absolute;left:160.68px;top:364.92px" class="cls_006"><span class="cls_006">scalability, resulting in the best of both worlds. Specific topics include temporary objects,</span></div>
<div style="position:absolute;left:160.68px;top:377.04px" class="cls_006"><span class="cls_006">memory management, templates, inheritance, virtual functions, inlining, reference-</span></div>
<div style="position:absolute;left:160.68px;top:389.04px" class="cls_006"><span class="cls_006">counting, STL, and much more.</span></div>
<div style="position:absolute;left:160.68px;top:415.20px" class="cls_006"><span class="cls_006">With this book, you will have a valuable compendium of the best performance techniques</span></div>
<div style="position:absolute;left:160.68px;top:427.20px" class="cls_006"><span class="cls_006">at your fingertips.</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010"><sup>®</sup></span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:852px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background002.jpg" width=595 height=842></div>
<div style="position:absolute;left:89.88px;top:69.12px" class="cls_008"><span class="cls_008">Table of Content</span></div>
<div style="position:absolute;left:101.88px;top:103.92px" class="cls_012"><span class="cls_012">Table of Content</span></div>
<div style="position:absolute;left:501.60px;top:102.96px" class="cls_013"><span class="cls_013">i</span></div>
<div style="position:absolute;left:101.88px;top:116.64px" class="cls_012"><span class="cls_012">Copyright</span></div>
<div style="position:absolute;left:499.32px;top:115.68px" class="cls_013"><span class="cls_013">v</span></div>
<div style="position:absolute;left:113.88px;top:129.24px" class="cls_012"><span class="cls_012">Dedication</span></div>
<div style="position:absolute;left:496.20px;top:128.28px" class="cls_013"><span class="cls_013">vi</span></div>
<div style="position:absolute;left:101.88px;top:141.96px" class="cls_012"><span class="cls_012">Preface</span></div>
<div style="position:absolute;left:496.20px;top:141.00px" class="cls_013"><span class="cls_013">vi</span></div>
<div style="position:absolute;left:101.88px;top:154.68px" class="cls_012"><span class="cls_012">Introduction</span></div>
<div style="position:absolute;left:490.09px;top:153.72px" class="cls_013"><span class="cls_013">viii</span></div>
<div style="position:absolute;left:113.88px;top:167.40px" class="cls_012"><span class="cls_012">Roots of Software Inefficiency</span></div>
<div style="position:absolute;left:490.14px;top:166.44px" class="cls_013"><span class="cls_013">viii</span></div>
<div style="position:absolute;left:113.88px;top:180.12px" class="cls_012"><span class="cls_012">Our Goal</span></div>
<div style="position:absolute;left:496.08px;top:179.16px" class="cls_013"><span class="cls_013">xi</span></div>
<div style="position:absolute;left:113.88px;top:192.72px" class="cls_012"><span class="cls_012">Software Efficiency: Does It Matter?</span></div>
<div style="position:absolute;left:496.08px;top:191.76px" class="cls_013"><span class="cls_013">xi</span></div>
<div style="position:absolute;left:113.88px;top:205.44px" class="cls_012"><span class="cls_012">Terminology</span></div>
<div style="position:absolute;left:492.96px;top:204.48px" class="cls_013"><span class="cls_013">xii</span></div>
<div style="position:absolute;left:113.88px;top:218.16px" class="cls_012"><span class="cls_012">Organization of This Book</span></div>
<div style="position:absolute;left:490.03px;top:217.20px" class="cls_013"><span class="cls_013">xiii</span></div>
<div style="position:absolute;left:101.88px;top:230.88px" class="cls_012"><span class="cls_012">Chapter 1. The Tracing War Story</span></div>
<div style="position:absolute;left:499.20px;top:229.92px" class="cls_013"><span class="cls_013">1</span></div>
<div style="position:absolute;left:113.88px;top:243.60px" class="cls_012"><span class="cls_012">Our Initial Trace Implementation</span></div>
<div style="position:absolute;left:499.20px;top:242.64px" class="cls_013"><span class="cls_013">2</span></div>
<div style="position:absolute;left:113.88px;top:256.32px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:499.20px;top:255.36px" class="cls_013"><span class="cls_013">7</span></div>
<div style="position:absolute;left:101.88px;top:268.92px" class="cls_012"><span class="cls_012">Chapter 2. Constructors and Destructors</span></div>
<div style="position:absolute;left:499.20px;top:267.96px" class="cls_013"><span class="cls_013">9</span></div>
<div style="position:absolute;left:113.88px;top:281.64px" class="cls_012"><span class="cls_012">Inheritance</span></div>
<div style="position:absolute;left:499.20px;top:280.68px" class="cls_013"><span class="cls_013">9</span></div>
<div style="position:absolute;left:113.88px;top:294.36px" class="cls_012"><span class="cls_012">Composition</span></div>
<div style="position:absolute;left:493.68px;top:293.40px" class="cls_013"><span class="cls_013">18</span></div>
<div style="position:absolute;left:113.88px;top:307.08px" class="cls_012"><span class="cls_012">Lazy Construction</span></div>
<div style="position:absolute;left:493.68px;top:306.12px" class="cls_013"><span class="cls_013">19</span></div>
<div style="position:absolute;left:113.88px;top:319.80px" class="cls_012"><span class="cls_012">Redundant Construction</span></div>
<div style="position:absolute;left:493.68px;top:318.84px" class="cls_013"><span class="cls_013">21</span></div>
<div style="position:absolute;left:113.88px;top:332.40px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:493.68px;top:331.44px" class="cls_013"><span class="cls_013">25</span></div>
<div style="position:absolute;left:101.88px;top:345.12px" class="cls_012"><span class="cls_012">Chapter 3. Virtual Functions</span></div>
<div style="position:absolute;left:493.68px;top:344.16px" class="cls_013"><span class="cls_013">26</span></div>
<div style="position:absolute;left:113.88px;top:357.84px" class="cls_012"><span class="cls_012">Virtual Function Mechanics</span></div>
<div style="position:absolute;left:493.68px;top:356.88px" class="cls_013"><span class="cls_013">26</span></div>
<div style="position:absolute;left:113.88px;top:370.56px" class="cls_012"><span class="cls_012">Templates and Inheritance</span></div>
<div style="position:absolute;left:493.68px;top:369.60px" class="cls_013"><span class="cls_013">28</span></div>
<div style="position:absolute;left:113.88px;top:383.28px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:493.68px;top:382.32px" class="cls_013"><span class="cls_013">31</span></div>
<div style="position:absolute;left:101.88px;top:395.88px" class="cls_012"><span class="cls_012">Chapter 4. The Return Value Optimization</span></div>
<div style="position:absolute;left:493.68px;top:394.92px" class="cls_013"><span class="cls_013">32</span></div>
<div style="position:absolute;left:113.88px;top:408.60px" class="cls_012"><span class="cls_012">The Mechanics of Return-by-Value</span></div>
<div style="position:absolute;left:493.68px;top:407.64px" class="cls_013"><span class="cls_013">32</span></div>
<div style="position:absolute;left:113.88px;top:421.32px" class="cls_012"><span class="cls_012">The Return Value Optimization</span></div>
<div style="position:absolute;left:493.68px;top:420.36px" class="cls_013"><span class="cls_013">33</span></div>
<div style="position:absolute;left:113.88px;top:434.04px" class="cls_012"><span class="cls_012">Computational Constructors</span></div>
<div style="position:absolute;left:493.68px;top:433.08px" class="cls_013"><span class="cls_013">35</span></div>
<div style="position:absolute;left:113.88px;top:446.76px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:493.68px;top:445.80px" class="cls_013"><span class="cls_013">36</span></div>
<div style="position:absolute;left:101.88px;top:459.36px" class="cls_012"><span class="cls_012">Chapter 5. Temporaries</span></div>
<div style="position:absolute;left:493.68px;top:458.40px" class="cls_013"><span class="cls_013">37</span></div>
<div style="position:absolute;left:113.88px;top:472.08px" class="cls_012"><span class="cls_012">Object Definition</span></div>
<div style="position:absolute;left:493.68px;top:471.12px" class="cls_013"><span class="cls_013">37</span></div>
<div style="position:absolute;left:113.88px;top:484.80px" class="cls_012"><span class="cls_012">Type Mismatch</span></div>
<div style="position:absolute;left:493.68px;top:483.84px" class="cls_013"><span class="cls_013">38</span></div>
<div style="position:absolute;left:113.88px;top:497.52px" class="cls_012"><span class="cls_012">Pass by Value</span></div>
<div style="position:absolute;left:493.68px;top:496.56px" class="cls_013"><span class="cls_013">40</span></div>
<div style="position:absolute;left:113.88px;top:510.24px" class="cls_012"><span class="cls_012">Return by Value</span></div>
<div style="position:absolute;left:493.68px;top:509.28px" class="cls_013"><span class="cls_013">40</span></div>
<div style="position:absolute;left:113.88px;top:523.56px" class="cls_012"><span class="cls_012">Eliminate Temporaries with </span><span class="cls_014">op=()</span></div>
<div style="position:absolute;left:493.68px;top:522.60px" class="cls_013"><span class="cls_013">42</span></div>
<div style="position:absolute;left:113.88px;top:536.52px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:493.68px;top:535.56px" class="cls_013"><span class="cls_013">43</span></div>
<div style="position:absolute;left:101.88px;top:549.24px" class="cls_012"><span class="cls_012">Chapter 6. Single-Threaded Memory Pooling</span></div>
<div style="position:absolute;left:493.68px;top:548.28px" class="cls_013"><span class="cls_013">44</span></div>
<div style="position:absolute;left:113.88px;top:562.56px" class="cls_012"><span class="cls_012">Version 0: The Global </span><span class="cls_014">new()</span><span class="cls_012"> and </span><span class="cls_014">delete()</span></div>
<div style="position:absolute;left:493.68px;top:561.60px" class="cls_013"><span class="cls_013">44</span></div>
<div style="position:absolute;left:113.88px;top:575.52px" class="cls_012"><span class="cls_012">Version 1: Specialized Rational Memory Manager</span></div>
<div style="position:absolute;left:493.68px;top:574.56px" class="cls_013"><span class="cls_013">45</span></div>
<div style="position:absolute;left:113.88px;top:588.24px" class="cls_012"><span class="cls_012">Version 2: Fixed-Size Object Memory Pool</span></div>
<div style="position:absolute;left:493.68px;top:587.28px" class="cls_013"><span class="cls_013">49</span></div>
<div style="position:absolute;left:113.88px;top:600.96px" class="cls_012"><span class="cls_012">Version 3: Single-Threaded Variable-Size Memory Manager</span></div>
<div style="position:absolute;left:493.68px;top:600.00px" class="cls_013"><span class="cls_013">52</span></div>
<div style="position:absolute;left:113.88px;top:613.68px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:493.68px;top:612.72px" class="cls_013"><span class="cls_013">58</span></div>
<div style="position:absolute;left:101.88px;top:626.28px" class="cls_012"><span class="cls_012">Chapter 7. Multithreaded Memory Pooling</span></div>
<div style="position:absolute;left:493.68px;top:625.32px" class="cls_013"><span class="cls_013">59</span></div>
<div style="position:absolute;left:113.88px;top:639.00px" class="cls_012"><span class="cls_012">Version 4: Implementation</span></div>
<div style="position:absolute;left:493.68px;top:638.04px" class="cls_013"><span class="cls_013">59</span></div>
<div style="position:absolute;left:113.88px;top:651.72px" class="cls_012"><span class="cls_012">Version 5: Faster Locking</span></div>
<div style="position:absolute;left:493.68px;top:650.76px" class="cls_013"><span class="cls_013">61</span></div>
<div style="position:absolute;left:113.88px;top:664.44px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:493.68px;top:663.48px" class="cls_013"><span class="cls_013">64</span></div>
<div style="position:absolute;left:101.88px;top:677.16px" class="cls_012"><span class="cls_012">Chapter 8. Inlining Basics</span></div>
<div style="position:absolute;left:493.68px;top:676.20px" class="cls_013"><span class="cls_013">66</span></div>
<div style="position:absolute;left:113.88px;top:689.76px" class="cls_012"><span class="cls_012">What Is Inlining?</span></div>
<div style="position:absolute;left:493.68px;top:688.80px" class="cls_013"><span class="cls_013">66</span></div>
<div style="position:absolute;left:113.88px;top:702.48px" class="cls_012"><span class="cls_012">Method Invocation Costs</span></div>
<div style="position:absolute;left:493.68px;top:701.52px" class="cls_013"><span class="cls_013">69</span></div>
<div style="position:absolute;left:113.88px;top:715.20px" class="cls_012"><span class="cls_012">Why Inline?</span></div>
<div style="position:absolute;left:493.68px;top:714.24px" class="cls_013"><span class="cls_013">72</span></div>
<div style="position:absolute;left:113.88px;top:727.92px" class="cls_012"><span class="cls_012">Inlining Details</span></div>
<div style="position:absolute;left:493.68px;top:726.96px" class="cls_013"><span class="cls_013">73</span></div>
<div style="position:absolute;left:113.88px;top:740.64px" class="cls_012"><span class="cls_012">Inlining Virtual Methods</span></div>
<div style="position:absolute;left:493.68px;top:739.68px" class="cls_013"><span class="cls_013">73</span></div>
<div style="position:absolute;left:113.88px;top:753.36px" class="cls_012"><span class="cls_012">Performance Gains from Inlining</span></div>
<div style="position:absolute;left:493.68px;top:752.40px" class="cls_013"><span class="cls_013">74</span></div>
<div style="position:absolute;left:294.36px;top:791.52px" class="cls_003"><span class="cls_003">ii</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:1704px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background003.jpg" width=595 height=842></div>
<div style="position:absolute;left:113.88px;top:70.92px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:493.68px;top:69.96px" class="cls_013"><span class="cls_013">75</span></div>
<div style="position:absolute;left:101.88px;top:83.64px" class="cls_012"><span class="cls_012">Chapter 9. Inlining—Performance Considerations</span></div>
<div style="position:absolute;left:493.68px;top:82.68px" class="cls_013"><span class="cls_013">76</span></div>
<div style="position:absolute;left:113.88px;top:96.36px" class="cls_012"><span class="cls_012">Cross-Call Optimization</span></div>
<div style="position:absolute;left:493.68px;top:95.40px" class="cls_013"><span class="cls_013">76</span></div>
<div style="position:absolute;left:113.88px;top:108.96px" class="cls_012"><span class="cls_012">Why Not Inline?</span></div>
<div style="position:absolute;left:493.68px;top:108.00px" class="cls_013"><span class="cls_013">80</span></div>
<div style="position:absolute;left:113.88px;top:121.68px" class="cls_012"><span class="cls_012">Development and Compile-Time Inlining Considerations</span></div>
<div style="position:absolute;left:493.68px;top:120.72px" class="cls_013"><span class="cls_013">82</span></div>
<div style="position:absolute;left:113.88px;top:134.40px" class="cls_012"><span class="cls_012">Profile-Based Inlining</span></div>
<div style="position:absolute;left:493.68px;top:133.44px" class="cls_013"><span class="cls_013">82</span></div>
<div style="position:absolute;left:113.88px;top:147.12px" class="cls_012"><span class="cls_012">Inlining Rules</span></div>
<div style="position:absolute;left:493.68px;top:146.16px" class="cls_013"><span class="cls_013">85</span></div>
<div style="position:absolute;left:113.88px;top:159.84px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:493.68px;top:158.88px" class="cls_013"><span class="cls_013">86</span></div>
<div style="position:absolute;left:101.88px;top:172.44px" class="cls_012"><span class="cls_012">Chapter 10. Inlining Tricks</span></div>
<div style="position:absolute;left:493.68px;top:171.48px" class="cls_013"><span class="cls_013">87</span></div>
<div style="position:absolute;left:113.88px;top:185.16px" class="cls_012"><span class="cls_012">Conditional Inlining</span></div>
<div style="position:absolute;left:493.68px;top:184.20px" class="cls_013"><span class="cls_013">87</span></div>
<div style="position:absolute;left:113.88px;top:197.88px" class="cls_012"><span class="cls_012">Selective Inlining</span></div>
<div style="position:absolute;left:493.68px;top:196.92px" class="cls_013"><span class="cls_013">88</span></div>
<div style="position:absolute;left:113.88px;top:210.60px" class="cls_012"><span class="cls_012">Recursive Inlining</span></div>
<div style="position:absolute;left:493.68px;top:209.64px" class="cls_013"><span class="cls_013">89</span></div>
<div style="position:absolute;left:113.88px;top:223.32px" class="cls_012"><span class="cls_012">Inlining with Static Local Variables</span></div>
<div style="position:absolute;left:493.68px;top:222.36px" class="cls_013"><span class="cls_013">92</span></div>
<div style="position:absolute;left:113.88px;top:236.04px" class="cls_012"><span class="cls_012">Architectural Caveat: Multiple Register Sets</span></div>
<div style="position:absolute;left:493.68px;top:235.08px" class="cls_013"><span class="cls_013">94</span></div>
<div style="position:absolute;left:113.88px;top:248.64px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:493.68px;top:247.68px" class="cls_013"><span class="cls_013">94</span></div>
<div style="position:absolute;left:101.88px;top:261.36px" class="cls_012"><span class="cls_012">Chapter 11. Standard Template Library</span></div>
<div style="position:absolute;left:493.68px;top:260.40px" class="cls_013"><span class="cls_013">96</span></div>
<div style="position:absolute;left:113.88px;top:274.08px" class="cls_012"><span class="cls_012">Asymptotic Complexity</span></div>
<div style="position:absolute;left:493.68px;top:273.12px" class="cls_013"><span class="cls_013">96</span></div>
<div style="position:absolute;left:113.88px;top:286.80px" class="cls_012"><span class="cls_012">Insertion</span></div>
<div style="position:absolute;left:493.68px;top:285.84px" class="cls_013"><span class="cls_013">96</span></div>
<div style="position:absolute;left:113.88px;top:299.52px" class="cls_012"><span class="cls_012">Deletion</span></div>
<div style="position:absolute;left:488.16px;top:298.56px" class="cls_013"><span class="cls_013">103</span></div>
<div style="position:absolute;left:113.88px;top:312.12px" class="cls_012"><span class="cls_012">Traversal</span></div>
<div style="position:absolute;left:488.16px;top:311.16px" class="cls_013"><span class="cls_013">105</span></div>
<div style="position:absolute;left:113.88px;top:324.84px" class="cls_012"><span class="cls_012">Find</span></div>
<div style="position:absolute;left:488.16px;top:323.88px" class="cls_013"><span class="cls_013">106</span></div>
<div style="position:absolute;left:113.88px;top:337.56px" class="cls_012"><span class="cls_012">Function Objects</span></div>
<div style="position:absolute;left:488.16px;top:336.60px" class="cls_013"><span class="cls_013">108</span></div>
<div style="position:absolute;left:113.88px;top:350.28px" class="cls_012"><span class="cls_012">Better than STL?</span></div>
<div style="position:absolute;left:488.16px;top:349.32px" class="cls_013"><span class="cls_013">110</span></div>
<div style="position:absolute;left:113.88px;top:363.00px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:488.16px;top:362.04px" class="cls_013"><span class="cls_013">112</span></div>
<div style="position:absolute;left:101.88px;top:375.60px" class="cls_012"><span class="cls_012">Chapter 12. Reference Counting</span></div>
<div style="position:absolute;left:488.16px;top:374.64px" class="cls_013"><span class="cls_013">113</span></div>
<div style="position:absolute;left:113.88px;top:388.32px" class="cls_012"><span class="cls_012">Implementation Details</span></div>
<div style="position:absolute;left:488.16px;top:387.36px" class="cls_013"><span class="cls_013">114</span></div>
<div style="position:absolute;left:113.88px;top:401.04px" class="cls_012"><span class="cls_012">Preexisting Classes</span></div>
<div style="position:absolute;left:488.16px;top:400.08px" class="cls_013"><span class="cls_013">123</span></div>
<div style="position:absolute;left:113.88px;top:413.76px" class="cls_012"><span class="cls_012">Concurrent Reference Counting</span></div>
<div style="position:absolute;left:488.16px;top:412.80px" class="cls_013"><span class="cls_013">126</span></div>
<div style="position:absolute;left:113.88px;top:426.48px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:488.16px;top:425.52px" class="cls_013"><span class="cls_013">129</span></div>
<div style="position:absolute;left:101.88px;top:439.20px" class="cls_012"><span class="cls_012">Chapter 13. Coding Optimizations</span></div>
<div style="position:absolute;left:488.16px;top:438.24px" class="cls_013"><span class="cls_013">131</span></div>
<div style="position:absolute;left:113.88px;top:451.80px" class="cls_012"><span class="cls_012">Caching</span></div>
<div style="position:absolute;left:488.16px;top:450.84px" class="cls_013"><span class="cls_013">132</span></div>
<div style="position:absolute;left:113.88px;top:464.52px" class="cls_012"><span class="cls_012">Precompute</span></div>
<div style="position:absolute;left:488.16px;top:463.56px" class="cls_013"><span class="cls_013">133</span></div>
<div style="position:absolute;left:113.88px;top:477.24px" class="cls_012"><span class="cls_012">Reduce Flexibility</span></div>
<div style="position:absolute;left:488.16px;top:476.28px" class="cls_013"><span class="cls_013">134</span></div>
<div style="position:absolute;left:113.88px;top:489.96px" class="cls_012"><span class="cls_012">80-20 Rule: Speed Up the Common Path</span></div>
<div style="position:absolute;left:488.16px;top:489.00px" class="cls_013"><span class="cls_013">134</span></div>
<div style="position:absolute;left:113.88px;top:502.68px" class="cls_012"><span class="cls_012">Lazy Evaluation</span></div>
<div style="position:absolute;left:488.16px;top:501.72px" class="cls_013"><span class="cls_013">137</span></div>
<div style="position:absolute;left:113.88px;top:515.28px" class="cls_012"><span class="cls_012">Useless Computations</span></div>
<div style="position:absolute;left:488.16px;top:514.32px" class="cls_013"><span class="cls_013">139</span></div>
<div style="position:absolute;left:113.88px;top:528.00px" class="cls_012"><span class="cls_012">System Architecture</span></div>
<div style="position:absolute;left:488.16px;top:527.04px" class="cls_013"><span class="cls_013">140</span></div>
<div style="position:absolute;left:113.88px;top:540.72px" class="cls_012"><span class="cls_012">Memory Management</span></div>
<div style="position:absolute;left:488.16px;top:539.76px" class="cls_013"><span class="cls_013">140</span></div>
<div style="position:absolute;left:113.88px;top:553.44px" class="cls_012"><span class="cls_012">Library and System Calls</span></div>
<div style="position:absolute;left:488.16px;top:552.48px" class="cls_013"><span class="cls_013">142</span></div>
<div style="position:absolute;left:113.88px;top:566.16px" class="cls_012"><span class="cls_012">Compiler Optimization</span></div>
<div style="position:absolute;left:488.16px;top:565.20px" class="cls_013"><span class="cls_013">143</span></div>
<div style="position:absolute;left:113.88px;top:578.76px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:488.16px;top:577.80px" class="cls_013"><span class="cls_013">144</span></div>
<div style="position:absolute;left:101.88px;top:591.48px" class="cls_012"><span class="cls_012">Chapter 14. Design Optimizations</span></div>
<div style="position:absolute;left:488.16px;top:590.52px" class="cls_013"><span class="cls_013">145</span></div>
<div style="position:absolute;left:113.88px;top:604.20px" class="cls_012"><span class="cls_012">Design Flexibility</span></div>
<div style="position:absolute;left:488.16px;top:603.24px" class="cls_013"><span class="cls_013">145</span></div>
<div style="position:absolute;left:113.88px;top:616.92px" class="cls_012"><span class="cls_012">Caching</span></div>
<div style="position:absolute;left:488.16px;top:615.96px" class="cls_013"><span class="cls_013">148</span></div>
<div style="position:absolute;left:113.88px;top:629.64px" class="cls_012"><span class="cls_012">Efficient Data Structures</span></div>
<div style="position:absolute;left:488.16px;top:628.68px" class="cls_013"><span class="cls_013">150</span></div>
<div style="position:absolute;left:113.88px;top:642.24px" class="cls_012"><span class="cls_012">Lazy Evaluation</span></div>
<div style="position:absolute;left:488.16px;top:641.28px" class="cls_013"><span class="cls_013">151</span></div>
<div style="position:absolute;left:113.88px;top:654.96px" class="cls_012"><span class="cls_012">Useless Computations</span></div>
<div style="position:absolute;left:488.16px;top:654.00px" class="cls_013"><span class="cls_013">153</span></div>
<div style="position:absolute;left:113.88px;top:667.68px" class="cls_012"><span class="cls_012">Obsolete Code</span></div>
<div style="position:absolute;left:488.16px;top:666.72px" class="cls_013"><span class="cls_013">154</span></div>
<div style="position:absolute;left:113.88px;top:680.40px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:488.16px;top:679.44px" class="cls_013"><span class="cls_013">155</span></div>
<div style="position:absolute;left:101.88px;top:693.12px" class="cls_012"><span class="cls_012">Chapter 15. Scalability</span></div>
<div style="position:absolute;left:488.16px;top:692.16px" class="cls_013"><span class="cls_013">156</span></div>
<div style="position:absolute;left:113.88px;top:705.84px" class="cls_012"><span class="cls_012">The SMP Architecture</span></div>
<div style="position:absolute;left:488.16px;top:704.88px" class="cls_013"><span class="cls_013">158</span></div>
<div style="position:absolute;left:113.88px;top:718.44px" class="cls_012"><span class="cls_012">Amdahl's Law</span></div>
<div style="position:absolute;left:488.16px;top:717.48px" class="cls_013"><span class="cls_013">160</span></div>
<div style="position:absolute;left:113.88px;top:731.16px" class="cls_012"><span class="cls_012">Multithreaded and Synchronization Terminology</span></div>
<div style="position:absolute;left:488.16px;top:730.20px" class="cls_013"><span class="cls_013">161</span></div>
<div style="position:absolute;left:113.88px;top:743.88px" class="cls_012"><span class="cls_012">Break Up a Task into Multiple Subtasks</span></div>
<div style="position:absolute;left:488.16px;top:742.92px" class="cls_013"><span class="cls_013">162</span></div>
<div style="position:absolute;left:292.68px;top:791.52px" class="cls_003"><span class="cls_003">iii</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:2556px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background004.jpg" width=595 height=842></div>
<div style="position:absolute;left:113.88px;top:70.92px" class="cls_012"><span class="cls_012">Cache Shared Data</span></div>
<div style="position:absolute;left:488.16px;top:69.96px" class="cls_013"><span class="cls_013">163</span></div>
<div style="position:absolute;left:113.88px;top:83.64px" class="cls_012"><span class="cls_012">Share Nothing</span></div>
<div style="position:absolute;left:488.16px;top:82.68px" class="cls_013"><span class="cls_013">164</span></div>
<div style="position:absolute;left:113.88px;top:96.36px" class="cls_012"><span class="cls_012">Partial Sharing</span></div>
<div style="position:absolute;left:488.16px;top:95.40px" class="cls_013"><span class="cls_013">166</span></div>
<div style="position:absolute;left:113.88px;top:108.96px" class="cls_012"><span class="cls_012">Lock Granularity</span></div>
<div style="position:absolute;left:488.16px;top:108.00px" class="cls_013"><span class="cls_013">167</span></div>
<div style="position:absolute;left:113.88px;top:121.68px" class="cls_012"><span class="cls_012">False Sharing</span></div>
<div style="position:absolute;left:488.16px;top:120.72px" class="cls_013"><span class="cls_013">169</span></div>
<div style="position:absolute;left:113.88px;top:134.40px" class="cls_012"><span class="cls_012">Thundering Herd</span></div>
<div style="position:absolute;left:488.16px;top:133.44px" class="cls_013"><span class="cls_013">170</span></div>
<div style="position:absolute;left:113.88px;top:147.12px" class="cls_012"><span class="cls_012">Reader/Writer Locks</span></div>
<div style="position:absolute;left:488.16px;top:146.16px" class="cls_013"><span class="cls_013">171</span></div>
<div style="position:absolute;left:113.88px;top:159.84px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:488.16px;top:158.88px" class="cls_013"><span class="cls_013">172</span></div>
<div style="position:absolute;left:101.88px;top:172.44px" class="cls_012"><span class="cls_012">Chapter 16. System Architecture Dependencies</span></div>
<div style="position:absolute;left:488.16px;top:171.48px" class="cls_013"><span class="cls_013">173</span></div>
<div style="position:absolute;left:113.88px;top:185.16px" class="cls_012"><span class="cls_012">Memory Hierarchies</span></div>
<div style="position:absolute;left:488.16px;top:184.20px" class="cls_013"><span class="cls_013">173</span></div>
<div style="position:absolute;left:113.88px;top:197.88px" class="cls_012"><span class="cls_012">Registers: Kings of Memory</span></div>
<div style="position:absolute;left:488.16px;top:196.92px" class="cls_013"><span class="cls_013">174</span></div>
<div style="position:absolute;left:113.88px;top:210.60px" class="cls_012"><span class="cls_012">Disk and Memory Structures</span></div>
<div style="position:absolute;left:488.16px;top:209.64px" class="cls_013"><span class="cls_013">177</span></div>
<div style="position:absolute;left:113.88px;top:223.32px" class="cls_012"><span class="cls_012">Cache Effects</span></div>
<div style="position:absolute;left:488.16px;top:222.36px" class="cls_013"><span class="cls_013">179</span></div>
<div style="position:absolute;left:113.88px;top:236.04px" class="cls_012"><span class="cls_012">Cache Thrash</span></div>
<div style="position:absolute;left:488.16px;top:235.08px" class="cls_013"><span class="cls_013">180</span></div>
<div style="position:absolute;left:113.88px;top:248.64px" class="cls_012"><span class="cls_012">Avoid Branching</span></div>
<div style="position:absolute;left:488.16px;top:247.68px" class="cls_013"><span class="cls_013">181</span></div>
<div style="position:absolute;left:113.88px;top:261.36px" class="cls_012"><span class="cls_012">Prefer Simple Calculations to Small Branches</span></div>
<div style="position:absolute;left:488.16px;top:260.40px" class="cls_013"><span class="cls_013">182</span></div>
<div style="position:absolute;left:113.88px;top:274.08px" class="cls_012"><span class="cls_012">Threading Effects</span></div>
<div style="position:absolute;left:488.16px;top:273.12px" class="cls_013"><span class="cls_013">183</span></div>
<div style="position:absolute;left:113.88px;top:286.80px" class="cls_012"><span class="cls_012">Context Switching</span></div>
<div style="position:absolute;left:488.16px;top:285.84px" class="cls_013"><span class="cls_013">184</span></div>
<div style="position:absolute;left:113.88px;top:299.52px" class="cls_012"><span class="cls_012">Kernel Crossing</span></div>
<div style="position:absolute;left:488.16px;top:298.56px" class="cls_013"><span class="cls_013">186</span></div>
<div style="position:absolute;left:113.88px;top:312.12px" class="cls_012"><span class="cls_012">Threading Choices</span></div>
<div style="position:absolute;left:488.16px;top:311.16px" class="cls_013"><span class="cls_013">187</span></div>
<div style="position:absolute;left:113.88px;top:324.84px" class="cls_012"><span class="cls_012">Key Points</span></div>
<div style="position:absolute;left:488.16px;top:323.88px" class="cls_013"><span class="cls_013">189</span></div>
<div style="position:absolute;left:101.88px;top:337.56px" class="cls_012"><span class="cls_012">Bibliography</span></div>
<div style="position:absolute;left:488.16px;top:336.60px" class="cls_013"><span class="cls_013">190</span></div>
<div style="position:absolute;left:292.92px;top:791.52px" class="cls_003"><span class="cls_003">iv</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:3408px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background005.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Copyright</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">Many of the designations used by manufacturers and sellers to distinguish their products are claimed as</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">trademarks. Where those designations appear in this book and Addison-Wesley was aware of a trademark</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">claim, the designations have been printed in initial caps or all caps.</span></div>
<div style="position:absolute;left:72.00px;top:168.12px" class="cls_006"><span class="cls_006">The authors and publishers have taken care in the preparation of this book, but make no expressed or</span></div>
<div style="position:absolute;left:72.00px;top:180.24px" class="cls_006"><span class="cls_006">implied warranty of any kind and assume no responsibility for errors or omissions. No liability is assumed</span></div>
<div style="position:absolute;left:72.00px;top:192.24px" class="cls_006"><span class="cls_006">for incidental or consequential damages in connection with or arising out of the use of the information or</span></div>
<div style="position:absolute;left:72.00px;top:204.36px" class="cls_006"><span class="cls_006">programs contained herein.</span></div>
<div style="position:absolute;left:72.00px;top:230.40px" class="cls_006"><span class="cls_006">The publisher offers discounts on this book when ordered in quantity for special sales. For more</span></div>
<div style="position:absolute;left:72.00px;top:242.52px" class="cls_006"><span class="cls_006">information, please contact:</span></div>
<div style="position:absolute;left:72.00px;top:268.56px" class="cls_006"><span class="cls_006">Corporate Government and Special Sales</span></div>
<div style="position:absolute;left:72.00px;top:294.60px" class="cls_006"><span class="cls_006">Addison Wesley Longman, Inc.</span></div>
<div style="position:absolute;left:72.00px;top:320.76px" class="cls_006"><span class="cls_006">One Jacob Way</span></div>
<div style="position:absolute;left:72.00px;top:346.80px" class="cls_006"><span class="cls_006">Reading, Massachusetts 01867</span></div>
<div style="position:absolute;left:72.00px;top:373.08px" class="cls_015"><span class="cls_015">Library of Congress Cataloging-in-Publication Data</span></div>
<div style="position:absolute;left:72.00px;top:398.88px" class="cls_006"><span class="cls_006">Bulka, Dov.</span></div>
<div style="position:absolute;left:72.00px;top:425.04px" class="cls_006"><span class="cls_006">Efficient C++ : performance programming techniques / Dov Bulka,</span></div>
<div style="position:absolute;left:72.00px;top:451.08px" class="cls_006"><span class="cls_006">David Mayhew.</span></div>
<div style="position:absolute;left:72.00px;top:477.12px" class="cls_006"><span class="cls_006">p. m.</span></div>
<div style="position:absolute;left:72.00px;top:503.28px" class="cls_006"><span class="cls_006">Includes bibliographical references (p. ).</span></div>
<div style="position:absolute;left:72.00px;top:529.32px" class="cls_006"><span class="cls_006">ISBN 0-201-37950-3</span></div>
<div style="position:absolute;left:72.00px;top:555.36px" class="cls_006"><span class="cls_006">1. C++ (Computer program language) I. Mayhew, David. II. Title.</span></div>
<div style="position:absolute;left:72.00px;top:581.40px" class="cls_006"><span class="cls_006">QA76.73.C153B85 1999</span></div>
<div style="position:absolute;left:72.00px;top:607.56px" class="cls_006"><span class="cls_006">005.13 ‘ 3—dc21 99-39175</span></div>
<div style="position:absolute;left:72.00px;top:633.60px" class="cls_006"><span class="cls_006">CIP</span></div>
<div style="position:absolute;left:72.00px;top:659.64px" class="cls_006"><span class="cls_006">Copyright © 2000 by Addison Wesley Longman, Inc.</span></div>
<div style="position:absolute;left:72.00px;top:685.80px" class="cls_006"><span class="cls_006">All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or</span></div>
<div style="position:absolute;left:72.00px;top:697.80px" class="cls_006"><span class="cls_006">transmitted, in any form, or by any means, electronic, mechanical, photocopying, recording, or otherwise,</span></div>
<div style="position:absolute;left:72.00px;top:709.92px" class="cls_006"><span class="cls_006">without the prior consent of the publisher. Printed in the United States of America. Published</span></div>
<div style="position:absolute;left:72.00px;top:721.92px" class="cls_006"><span class="cls_006">simultaneously in Canada.</span></div>
<div style="position:absolute;left:72.00px;top:748.08px" class="cls_006"><span class="cls_006">Text printed on recycled and acid-free paper.</span></div>
<div style="position:absolute;left:294.60px;top:791.64px" class="cls_003"><span class="cls_003">v</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:4260px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background006.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">1 2 3 4 5 6 7 8 9 10 —CRS—03 02 01 00 99</span></div>
<div style="position:absolute;left:72.00px;top:96.96px" class="cls_006"><span class="cls_006">First printing, October 1999</span></div>
<div style="position:absolute;left:72.00px;top:154.20px" class="cls_016"><span class="cls_016">Dedication</span></div>
<div style="position:absolute;left:72.00px;top:185.52px" class="cls_006"><span class="cls_006">To my mother, Rivka Bulka and to the memory of my father Yacov Bulka, survivor of the Auschwitz</span></div>
<div style="position:absolute;left:72.00px;top:197.64px" class="cls_006"><span class="cls_006">concentration camp. They could not take away his kindness, compassion and optimism, which was his</span></div>
<div style="position:absolute;left:72.00px;top:209.76px" class="cls_006"><span class="cls_006">ultimate triumph. He passed away during the writing of this book.</span></div>
<div style="position:absolute;left:72.00px;top:235.80px" class="cls_006"><span class="cls_006">D.B</span></div>
<div style="position:absolute;left:72.00px;top:261.84px" class="cls_006"><span class="cls_006">To Ruth, the love of my life, who made time for me to write this. To the boys, Austin, Alex, and Steve,</span></div>
<div style="position:absolute;left:72.00px;top:273.96px" class="cls_006"><span class="cls_006">who missed their dad for a while. To my parents, Mom and Dad, who have always loved and supported me</span></div>
<div style="position:absolute;left:72.00px;top:300.00px" class="cls_006"><span class="cls_006">D.M.</span></div>
<div style="position:absolute;left:72.00px;top:325.68px" class="cls_008"><span class="cls_008">Preface</span></div>
<div style="position:absolute;left:72.00px;top:359.04px" class="cls_006"><span class="cls_006">If you conducted an informal survey of software developers on the issue of C++ performance, you would</span></div>
<div style="position:absolute;left:72.00px;top:371.16px" class="cls_006"><span class="cls_006">undoubtedly find that the vast majority of them view performance issues as the Achilles’ heel of an</span></div>
<div style="position:absolute;left:72.00px;top:383.16px" class="cls_006"><span class="cls_006">otherwise fine language. We have heard it repeatedly ever since C++ burst on the corporate scene: C++ is</span></div>
<div style="position:absolute;left:72.00px;top:395.28px" class="cls_006"><span class="cls_006">a poor choice for implementing performance-critical applications. In the mind of developers, this particular</span></div>
<div style="position:absolute;left:72.00px;top:407.40px" class="cls_006"><span class="cls_006">application domain was ruled by plain C and, occasionally, even assembly language.</span></div>
<div style="position:absolute;left:72.00px;top:433.44px" class="cls_006"><span class="cls_006">As part of that software community we had the opportunity to watch that myth develop and gather steam.</span></div>
<div style="position:absolute;left:72.00px;top:445.56px" class="cls_006"><span class="cls_006">Years ago, we participated in the wave that embraced C++ with enthusiasm. All around us, many</span></div>
<div style="position:absolute;left:72.00px;top:457.56px" class="cls_006"><span class="cls_006">development projects plunged in headfirst. Some time later, software solutions implemented in C++ began</span></div>
<div style="position:absolute;left:72.00px;top:469.68px" class="cls_006"><span class="cls_006">rolling out. Their performance was typically less than optimal, to put it gently. Enthusiasm over C++ in</span></div>
<div style="position:absolute;left:72.00px;top:481.68px" class="cls_006"><span class="cls_006">performance-critical domains has cooled. We were in the business of supplying networking software</span></div>
<div style="position:absolute;left:72.00px;top:493.80px" class="cls_006"><span class="cls_006">whose execution speed was not up for negotiation—speed was top priority. Since networking software is</span></div>
<div style="position:absolute;left:72.00px;top:505.92px" class="cls_006"><span class="cls_006">pretty low on the software food-chain, its performance is crucial. Large numbers of applications were</span></div>
<div style="position:absolute;left:72.00px;top:517.92px" class="cls_006"><span class="cls_006">going to sit on top of it and depend on it. Poor performance in the low levels ripples all the way up to</span></div>
<div style="position:absolute;left:72.00px;top:530.04px" class="cls_006"><span class="cls_006">higher level applications.</span></div>
<div style="position:absolute;left:72.00px;top:556.08px" class="cls_006"><span class="cls_006">Our experience was not unique. All around, early adopters of C++ had difficulties with the resulting</span></div>
<div style="position:absolute;left:72.00px;top:568.20px" class="cls_006"><span class="cls_006">performance of their C++ code. Instead of attributing the difficulties to the steep learning curve of the new</span></div>
<div style="position:absolute;left:72.00px;top:580.20px" class="cls_006"><span class="cls_006">object-oriented software development paradigm, we blamed it on C++, the dominant language for the</span></div>
<div style="position:absolute;left:72.00px;top:592.32px" class="cls_006"><span class="cls_006">expression of the paradigm. Even though C++ compilers were still essentially in their infancy, the</span></div>
<div style="position:absolute;left:72.00px;top:604.44px" class="cls_006"><span class="cls_006">language was branded as inherently slow. This belief spread quickly and is now widely accepted as fact.</span></div>
<div style="position:absolute;left:72.00px;top:616.44px" class="cls_006"><span class="cls_006">Software organizations that passed on C++ frequently pointed to performance as their key concern. That</span></div>
<div style="position:absolute;left:72.00px;top:628.56px" class="cls_006"><span class="cls_006">concern was rooted in the perception that C++ cannot match the performance delivered by its C</span></div>
<div style="position:absolute;left:72.00px;top:640.56px" class="cls_006"><span class="cls_006">counterpart. Consequently, C++ has had little success penetrating software domains that view performance</span></div>
<div style="position:absolute;left:72.00px;top:652.68px" class="cls_006"><span class="cls_006">as top priority: operating system kernels, device drivers, networking systems (routers, gateways, protocol</span></div>
<div style="position:absolute;left:72.00px;top:664.80px" class="cls_006"><span class="cls_006">stacks), and more.</span></div>
<div style="position:absolute;left:72.00px;top:690.84px" class="cls_006"><span class="cls_006">We have spent years dissecting large systems of C and C++ code trying to squeeze every ounce of</span></div>
<div style="position:absolute;left:72.00px;top:702.96px" class="cls_006"><span class="cls_006">performance out of them. It is through our experience of slugging it out in the trenches that we have come</span></div>
<div style="position:absolute;left:72.00px;top:714.96px" class="cls_006"><span class="cls_006">to appreciate the potential of C++ to produce highly efficient programs. We’ve seen it done in practice.</span></div>
<div style="position:absolute;left:72.00px;top:727.08px" class="cls_006"><span class="cls_006">This book is our attempt to share that experience and document the many lessons we have learned in our</span></div>
<div style="position:absolute;left:72.00px;top:739.08px" class="cls_006"><span class="cls_006">own pursuit of C++ efficiency. Writing efficient C++ is not trivial, nor is it rocket science. It takes the</span></div>
<div style="position:absolute;left:292.92px;top:791.64px" class="cls_003"><span class="cls_003">vi</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:5112px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background007.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">understanding of some performance principles, as well as information on C++ performance traps and</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">pitfalls.</span></div>
<div style="position:absolute;left:72.00px;top:109.08px" class="cls_006"><span class="cls_006">The 80-20 rule is an important principle in the world of software construction. We adopt it in the writing of</span></div>
<div style="position:absolute;left:72.00px;top:121.20px" class="cls_006"><span class="cls_006">this book as well: 20% of all performance bugs will show up 80% of the time. We therefore chose to</span></div>
<div style="position:absolute;left:72.00px;top:133.20px" class="cls_006"><span class="cls_006">concentrate our efforts where it counts the most. We are interested in those performance issues that arise</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_006"><span class="cls_006">frequently in industrial code and have significant impact. This book is not an exhaustive discussion of the</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">set of all possible performance bugs and their solutions; hence, we will not cover what we consider</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">esoteric and rare performance pitfalls.</span></div>
<div style="position:absolute;left:72.00px;top:195.48px" class="cls_006"><span class="cls_006">Our point of view is undoubtedly biased by our practical experience as programmers of server-side,</span></div>
<div style="position:absolute;left:72.00px;top:207.60px" class="cls_006"><span class="cls_006">performance-critical communications software. This bias impacts the book in several ways:</span></div>
<div style="position:absolute;left:90.00px;top:233.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The profile of performance issues that we encounter in practice may be slightly different in nature</span></div>
<div style="position:absolute;left:108.00px;top:246.00px" class="cls_006"><span class="cls_006">than those found in scientific computing, database applications, and other domains. That’s not a</span></div>
<div style="position:absolute;left:108.00px;top:258.00px" class="cls_006"><span class="cls_006">problem. Generic performance principles transcend distinct domains, and apply equally well in</span></div>
<div style="position:absolute;left:108.00px;top:270.12px" class="cls_006"><span class="cls_006">domains other than networking software.</span></div>
<div style="position:absolute;left:90.00px;top:282.48px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   At times, we invented contrived examples to drive a point home, although we tried to minimize</span></div>
<div style="position:absolute;left:108.00px;top:294.48px" class="cls_006"><span class="cls_006">this. We have made enough coding mistakes in the past to have a sizable collection of samples</span></div>
<div style="position:absolute;left:108.00px;top:306.60px" class="cls_006"><span class="cls_006">taken from real production-level code that we have worked on. Our expertise was earned the hard</span></div>
<div style="position:absolute;left:108.00px;top:318.72px" class="cls_006"><span class="cls_006">way—by learning from our own mistakes as well as those of our colleagues. As much as possible,</span></div>
<div style="position:absolute;left:108.00px;top:330.72px" class="cls_006"><span class="cls_006">we illustrated our points with real code samples.</span></div>
<div style="position:absolute;left:90.00px;top:343.08px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   We do not delve into the asymptotic complexity of algorithms, data structures, and the latest and</span></div>
<div style="position:absolute;left:108.00px;top:355.20px" class="cls_006"><span class="cls_006">greatest techniques for accessing, sorting, searching, and compressing data. These are important</span></div>
<div style="position:absolute;left:108.00px;top:367.20px" class="cls_006"><span class="cls_006">topics, but they have been extensively covered elsewhere [Knu73, </span><span class="cls_036">BR95</span><span class="cls_006">, </span><span class="cls_036">KP74</span><span class="cls_006">]. Instead, we</span></div>
<div style="position:absolute;left:108.00px;top:379.32px" class="cls_006"><span class="cls_006">focus on simple, practical, everyday coding and design principles that yield large performance</span></div>
<div style="position:absolute;left:108.00px;top:391.32px" class="cls_006"><span class="cls_006">improvements. We point out common design and coding practices that lead to poor performance,</span></div>
<div style="position:absolute;left:108.00px;top:403.44px" class="cls_006"><span class="cls_006">whether it be through the unwitting use of language features that carry high hidden costs or</span></div>
<div style="position:absolute;left:108.00px;top:415.56px" class="cls_006"><span class="cls_006">through violating any number of subtle (and not so subtle) performance principles.</span></div>
<div style="position:absolute;left:72.00px;top:441.60px" class="cls_006"><span class="cls_006">So how do we separate myth from reality? Is C++ performance truly inferior to that of C? It is our</span></div>
<div style="position:absolute;left:72.00px;top:453.72px" class="cls_006"><span class="cls_006">contention that the common perception of inferior C++ performance is invalid. We concede that in general,</span></div>
<div style="position:absolute;left:72.00px;top:465.72px" class="cls_006"><span class="cls_006">when comparing a C program to a C++ version of what appears to be the same thing, the C program is</span></div>
<div style="position:absolute;left:72.00px;top:477.84px" class="cls_006"><span class="cls_006">generally faster. However, we also claim that the apparent similarity of the two programs typically is based</span></div>
<div style="position:absolute;left:72.00px;top:489.84px" class="cls_006"><span class="cls_006">on their data handling functionality, not their correctness, robustness, or ease of maintenance. Our</span></div>
<div style="position:absolute;left:72.00px;top:501.96px" class="cls_006"><span class="cls_006">contention is that when C programs are brought up to the level of C++ programs in these regards, the speed</span></div>
<div style="position:absolute;left:72.00px;top:514.08px" class="cls_006"><span class="cls_006">differences disappear, or the C++ versions are faster.</span></div>
<div style="position:absolute;left:72.00px;top:540.12px" class="cls_006"><span class="cls_006">Thus C++ is inherently neither slower nor faster. It could be either, depending on how it is used and what</span></div>
<div style="position:absolute;left:72.00px;top:552.24px" class="cls_006"><span class="cls_006">is required from it. It’s the way it is used that matters: If used properly, C++ can yield software systems</span></div>
<div style="position:absolute;left:72.00px;top:564.24px" class="cls_006"><span class="cls_006">exhibiting not just acceptable performance, but yield superior software performance.</span></div>
<div style="position:absolute;left:72.00px;top:590.28px" class="cls_006"><span class="cls_006">We would like to thank the many people who contributed to this work. The toughest part was getting</span></div>
<div style="position:absolute;left:72.00px;top:602.40px" class="cls_006"><span class="cls_006">started and it was our editor, Marina Lang, who was instrumental in getting this project off the ground.</span></div>
<div style="position:absolute;left:72.00px;top:614.52px" class="cls_006"><span class="cls_006">Julia Sime made a significant contribution to the early draft and Yomtov Meged contributed many valuable</span></div>
<div style="position:absolute;left:72.00px;top:626.52px" class="cls_006"><span class="cls_006">suggestions as well. He also was the one who pointed out to us the subtle difference between our opinions</span></div>
<div style="position:absolute;left:72.00px;top:638.64px" class="cls_006"><span class="cls_006">and the absolute truth. Although those two notions may coincide at times, they are still distinct.</span></div>
<div style="position:absolute;left:72.00px;top:664.68px" class="cls_006"><span class="cls_006">Many thanks to the reviewers hired by Addison-Wesley; their feedback was extremely valuable.</span></div>
<div style="position:absolute;left:72.00px;top:690.72px" class="cls_006"><span class="cls_006">Thanks also to our friends and colleagues who reviewed portions of the manuscript. They are, in no</span></div>
<div style="position:absolute;left:72.00px;top:702.84px" class="cls_006"><span class="cls_006">particular order, Cyndy Ross, Art Francis, Scott Snyder, Tricia York, Michael Fraenkel, Carol Jones,</span></div>
<div style="position:absolute;left:72.00px;top:714.96px" class="cls_006"><span class="cls_006">Heather Kreger, Kathryn Britton, Ruth Willenborg, David Wisler, Bala Rajaraman, Don “Spike”</span></div>
<div style="position:absolute;left:72.00px;top:726.96px" class="cls_006"><span class="cls_006">Washburn, and Nils Brubaker.</span></div>
<div style="position:absolute;left:72.00px;top:753.12px" class="cls_006"><span class="cls_006">Last but not least, we would like to thank our wives, Cynthia Powers Bulka and Ruth Washington Mayhew.</span></div>
<div style="position:absolute;left:291.36px;top:791.64px" class="cls_003"><span class="cls_003">vii</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:5964px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background008.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_008"><span class="cls_008">Introduction</span></div>
<div style="position:absolute;left:72.00px;top:103.92px" class="cls_006"><span class="cls_006">In the days of assembler language programming, experienced programmers estimated the execution speed</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_006"><span class="cls_006">of their source code by counting the number of assembly language instructions. On some architectures,</span></div>
<div style="position:absolute;left:72.00px;top:128.04px" class="cls_006"><span class="cls_006">such as RISC, most assembler instructions executed in one clock cycle each. Other architectures featured</span></div>
<div style="position:absolute;left:72.00px;top:140.16px" class="cls_006"><span class="cls_006">wide variations in instruction to instruction execution speed, but experienced programmers were able to</span></div>
<div style="position:absolute;left:72.00px;top:152.16px" class="cls_006"><span class="cls_006">develop a good feel for average instruction latency. If you knew how many instructions your code</span></div>
<div style="position:absolute;left:72.00px;top:164.28px" class="cls_006"><span class="cls_006">fragment contained, you could estimate with accuracy the number of clock cycles their execution would</span></div>
<div style="position:absolute;left:72.00px;top:176.28px" class="cls_006"><span class="cls_006">consume. The mapping from source code to assembler was trivially one-to-one. The assembler code </span><span class="cls_007">was</span></div>
<div style="position:absolute;left:72.00px;top:188.40px" class="cls_006"><span class="cls_006">the source code.</span></div>
<div style="position:absolute;left:72.00px;top:214.44px" class="cls_006"><span class="cls_006">On the ladder of programming languages, C is one step higher than assembler language. C source code is</span></div>
<div style="position:absolute;left:72.00px;top:226.56px" class="cls_006"><span class="cls_006">not identical to the corresponding compiler-generated assembler code. It is the compiler’s task to bridge</span></div>
<div style="position:absolute;left:72.00px;top:238.68px" class="cls_006"><span class="cls_006">the gap from source code to assembler. The mapping of source-to-assembler code is no longer the one-to-</span></div>
<div style="position:absolute;left:72.00px;top:250.68px" class="cls_006"><span class="cls_006">one identity mapping. It remains, however, a linear relationship: Each source level statement in C</span></div>
<div style="position:absolute;left:72.00px;top:262.80px" class="cls_006"><span class="cls_006">corresponds to a small number of assembler instructions. If you estimate that each C statement translates</span></div>
<div style="position:absolute;left:72.00px;top:274.80px" class="cls_006"><span class="cls_006">into five to eight assembler instructions, chances are you will be in the ballpark.</span></div>
<div style="position:absolute;left:72.00px;top:300.96px" class="cls_006"><span class="cls_006">C++ has shattered this nice linear relationship between the number of source level statements and</span></div>
<div style="position:absolute;left:72.00px;top:312.96px" class="cls_006"><span class="cls_006">compiler</span><span class="cls_019">-</span><span class="cls_006">generated assembly statement count. Whereas the cost of C statements is largely uniform, the</span></div>
<div style="position:absolute;left:72.00px;top:325.08px" class="cls_006"><span class="cls_006">cost of C++ statements fluctuates wildly. One C++ statement can generate three assembler instructions,</span></div>
<div style="position:absolute;left:72.00px;top:337.20px" class="cls_006"><span class="cls_006">whereas another can generate 300. Implementing high-performance C++ code has placed a new and</span></div>
<div style="position:absolute;left:72.00px;top:349.20px" class="cls_006"><span class="cls_006">unexpected demand on programmers: the need to navigate through a performance minefield, trying to stay</span></div>
<div style="position:absolute;left:72.00px;top:361.32px" class="cls_006"><span class="cls_006">on a safe three-instruction-per-statement path and to avoid usage of routes that contain 300-instruction land</span></div>
<div style="position:absolute;left:72.00px;top:373.32px" class="cls_006"><span class="cls_006">mines. Programmers must identify language constructs likely to generate large overhead and know how to</span></div>
<div style="position:absolute;left:72.00px;top:385.44px" class="cls_006"><span class="cls_006">code or design around them. These are considerations that C and assembler language programmers have</span></div>
<div style="position:absolute;left:72.00px;top:397.56px" class="cls_006"><span class="cls_006">never had to worry about. The only exception may be the use of macros in C, but those are hardly as</span></div>
<div style="position:absolute;left:72.00px;top:409.56px" class="cls_006"><span class="cls_006">frequent as the invocations of constructors and destructors in C++ code.</span></div>
<div style="position:absolute;left:72.00px;top:435.72px" class="cls_006"><span class="cls_006">The C++ compiler might also insert code into the execution flow of your program “behind your back.”</span></div>
<div style="position:absolute;left:72.00px;top:447.72px" class="cls_006"><span class="cls_006">This is news to the unsuspecting C programmer migrating to C++ (which is where many of us are coming</span></div>
<div style="position:absolute;left:72.00px;top:459.84px" class="cls_006"><span class="cls_006">from). The task of writing efficient C++ programs requires C++ developers to acquire new performance</span></div>
<div style="position:absolute;left:72.00px;top:471.84px" class="cls_006"><span class="cls_006">skills that are specific to C++ and that transcend the generic software performance principles. In C</span></div>
<div style="position:absolute;left:72.00px;top:483.96px" class="cls_006"><span class="cls_006">programming, you are not likely to be blindsided by hidden overhead, so it is possible to stumble upon</span></div>
<div style="position:absolute;left:72.00px;top:496.08px" class="cls_006"><span class="cls_006">good performance in a C program. In contrast, this is unlikely to happen in C++: You are not going to</span></div>
<div style="position:absolute;left:72.00px;top:508.08px" class="cls_006"><span class="cls_006">achieve good performance accidentally, without knowing the pitfalls lurking about.</span></div>
<div style="position:absolute;left:72.00px;top:534.24px" class="cls_006"><span class="cls_006">To be fair, we have seen many examples of poor performance that were rooted in inefficient object-</span></div>
<div style="position:absolute;left:72.00px;top:546.24px" class="cls_006"><span class="cls_006">oriented (OO) design. The ideas of software flexibility and reuse have been promoted aggressively ever</span></div>
<div style="position:absolute;left:72.00px;top:558.36px" class="cls_006"><span class="cls_006">since OO moved into the mainstream. However, flexibility and reuse seldom go hand-in-hand with</span></div>
<div style="position:absolute;left:72.00px;top:570.36px" class="cls_006"><span class="cls_006">performance and efficiency. In mathematics, it would be painful to reduce every theorem back to basic</span></div>
<div style="position:absolute;left:72.00px;top:582.48px" class="cls_006"><span class="cls_006">principles. Mathematicians try to reuse results that have already been proven. Outside mathematics,</span></div>
<div style="position:absolute;left:72.00px;top:594.60px" class="cls_006"><span class="cls_006">however, it often makes sense to leverage special circumstances and to take shortcuts. In software design,</span></div>
<div style="position:absolute;left:72.00px;top:606.60px" class="cls_006"><span class="cls_006">it is acceptable under some circumstances to place higher priority on performance than reuse. When you</span></div>
<div style="position:absolute;left:72.00px;top:619.20px" class="cls_006"><span class="cls_006">implement the </span><span class="cls_020">read()</span><span class="cls_006"> or </span><span class="cls_020">write()</span><span class="cls_006"> function of a device driver, the known performance requirements are</span></div>
<div style="position:absolute;left:72.00px;top:631.56px" class="cls_006"><span class="cls_006">generally much more important to your software’s success than the possibility that at some point in the</span></div>
<div style="position:absolute;left:72.00px;top:643.56px" class="cls_006"><span class="cls_006">future it might be reused. Some performance problems in OO design are due to putting the emphasis on the</span></div>
<div style="position:absolute;left:72.00px;top:655.68px" class="cls_006"><span class="cls_006">wrong place at the wrong time. Programmers should focus on solving the problem they have, not on</span></div>
<div style="position:absolute;left:72.00px;top:667.68px" class="cls_006"><span class="cls_006">making their current solution amenable to some unidentified set of possible future requirements.</span></div>
<div style="position:absolute;left:72.00px;top:693.72px" class="cls_016"><span class="cls_016">Roots of Software Inefficiency</span></div>
<div style="position:absolute;left:72.00px;top:725.04px" class="cls_006"><span class="cls_006">Silent C++ overhead is not the root of all performance evil. Even eliminating compiler-generated overhead</span></div>
<div style="position:absolute;left:72.00px;top:737.16px" class="cls_006"><span class="cls_006">would not always be sufficient. If that were the case, then every C program would enjoy automatic</span></div>
<div style="position:absolute;left:72.00px;top:749.16px" class="cls_006"><span class="cls_006">awesome performance due to the lack of silent overhead. Additional factors affect software performance in</span></div>
<div style="position:absolute;left:289.68px;top:791.64px" class="cls_003"><span class="cls_003">viii</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:6816px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background009.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">general and C++ performance in particular. What are those factors? The first level of performance</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">classification is given in </span><span class="cls_036">Figure 1</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:149.76px;top:109.20px" class="cls_021"><span class="cls_021">Figure 1. High-level classification of software performance.</span></div>
<div style="position:absolute;left:72.00px;top:283.44px" class="cls_006"><span class="cls_006">At the highest level, software efficiency is determined by the efficiency of two main ingredients:</span></div>
<div style="position:absolute;left:90.00px;top:309.72px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Design efficiency</span><span class="cls_006"> This involves the program’s high-level design. To fix performance problems at</span></div>
<div style="position:absolute;left:108.00px;top:321.84px" class="cls_006"><span class="cls_006">that level you must understand the program’s big picture. To a large extent, this item is language</span></div>
<div style="position:absolute;left:108.00px;top:333.84px" class="cls_006"><span class="cls_006">independent. No amount of coding efficiency can provide shelter for a bad design.</span></div>
<div style="position:absolute;left:90.00px;top:346.20px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Coding efficiency</span><span class="cls_006"> Small- to medium-scale implementation issues fall into this category. Fixing</span></div>
<div style="position:absolute;left:108.00px;top:358.32px" class="cls_006"><span class="cls_006">performance in this category generally involves local modifications. For example, you do not need</span></div>
<div style="position:absolute;left:108.00px;top:370.32px" class="cls_006"><span class="cls_006">to look very far into a code fragment in order to lift a constant expression out of a loop and</span></div>
<div style="position:absolute;left:108.00px;top:382.44px" class="cls_006"><span class="cls_006">prevent redundant computations. The code fragment you need to understand is limited in scope to</span></div>
<div style="position:absolute;left:108.00px;top:394.44px" class="cls_006"><span class="cls_006">the loop body.</span></div>
<div style="position:absolute;left:72.00px;top:420.60px" class="cls_006"><span class="cls_006">This high-level classification can be broken down further into finer subtopics, as shown in </span><span class="cls_036">Figure 2</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:163.44px;top:446.76px" class="cls_021"><span class="cls_021">Figure 2. Refinement of the design performance view.</span></div>
<div style="position:absolute;left:72.00px;top:615.72px" class="cls_006"><span class="cls_006">Design efficiency is broken down further into two items:</span></div>
<div style="position:absolute;left:90.00px;top:642.00px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Algorithms and data structures</span><span class="cls_006"> Technically speaking, every program is an algorithm in itself.</span></div>
<div style="position:absolute;left:108.00px;top:654.12px" class="cls_006"><span class="cls_006">Referring to “algorithms and data structures” actually refers to the well-known subset of</span></div>
<div style="position:absolute;left:108.00px;top:666.24px" class="cls_006"><span class="cls_006">algorithms for accessing, searching, sorting, compressing, and otherwise manipulating large</span></div>
<div style="position:absolute;left:108.00px;top:678.24px" class="cls_006"><span class="cls_006">collections of data.</span></div>
<div style="position:absolute;left:108.00px;top:704.28px" class="cls_006"><span class="cls_006">Oftentimes performance automatically is associated with the efficiency of the algorithms and data</span></div>
<div style="position:absolute;left:108.00px;top:716.40px" class="cls_006"><span class="cls_006">structures used in a program, as if nothing else matters. To claim that software performance can be</span></div>
<div style="position:absolute;left:108.00px;top:728.52px" class="cls_006"><span class="cls_006">reduced to that aspect alone is inaccurate. The efficiency of algorithms and data structures is</span></div>
<div style="position:absolute;left:108.00px;top:740.52px" class="cls_006"><span class="cls_006">necessary but not sufficient: By itself, it does not guarantee good overall program efficiency.</span></div>
<div style="position:absolute;left:292.92px;top:791.64px" class="cls_003"><span class="cls_003">ix</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:7668px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background010.jpg" width=595 height=842></div>
<div style="position:absolute;left:90.00px;top:71.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Program decomposition</span><span class="cls_006"> This involves decomposition of the overall task into communicating</span></div>
<div style="position:absolute;left:108.00px;top:83.28px" class="cls_006"><span class="cls_006">subtasks, object hierarchies, functions, data, and function flow. It is the program’s high-level</span></div>
<div style="position:absolute;left:108.00px;top:95.28px" class="cls_006"><span class="cls_006">design and includes component design as well as intercomponent communication. Few programs</span></div>
<div style="position:absolute;left:108.00px;top:107.40px" class="cls_006"><span class="cls_006">consist of a single component. A typical Web application interacts (via API) with a Web server,</span></div>
<div style="position:absolute;left:108.00px;top:119.52px" class="cls_006"><span class="cls_006">TCP sockets, and a database, at the very least. There are efficiency tricks and pitfalls with respect</span></div>
<div style="position:absolute;left:108.00px;top:131.52px" class="cls_006"><span class="cls_006">to crossing the API layer with each of those components.</span></div>
<div style="position:absolute;left:72.00px;top:157.56px" class="cls_006"><span class="cls_006">Coding efficiency can also be subdivided, as shown in </span><span class="cls_036">Figure 3</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:163.20px;top:183.84px" class="cls_021"><span class="cls_021">Figure 3. Refinement of the coding performance view.</span></div>
<div style="position:absolute;left:72.00px;top:340.80px" class="cls_006"><span class="cls_006">We split up coding efficiency into four items:</span></div>
<div style="position:absolute;left:90.00px;top:367.68px" class="cls_017"><span class="cls_017">•</span></div>
<div style="position:absolute;left:108.00px;top:367.08px" class="cls_015"><span class="cls_015">Language constructs</span><span class="cls_006"> C++ adds power and flexibility to its C ancestor. These added benefits do</span></div>
<div style="position:absolute;left:108.00px;top:379.20px" class="cls_006"><span class="cls_006">not come for free—some C++ language constructs may produce overhead in exchange. We will</span></div>
<div style="position:absolute;left:108.00px;top:391.20px" class="cls_006"><span class="cls_006">discuss this issue throughout the book. This topic is, by nature, C++ specific.</span></div>
<div style="position:absolute;left:90.00px;top:404.16px" class="cls_017"><span class="cls_017">•</span></div>
<div style="position:absolute;left:108.00px;top:403.56px" class="cls_015"><span class="cls_015">System architecture</span><span class="cls_006"> System designers invest considerable effort to present the programmer with</span></div>
<div style="position:absolute;left:108.00px;top:415.68px" class="cls_006"><span class="cls_006">an idealistic view of the system: infinite memory, dedicated CPU, parallel thread execution, and</span></div>
<div style="position:absolute;left:108.00px;top:427.68px" class="cls_006"><span class="cls_006">uniform-cost memory access. Of course, none of these is true—it just feels that way. Developing</span></div>
<div style="position:absolute;left:108.00px;top:439.80px" class="cls_006"><span class="cls_006">software free of system architecture considerations is also convenient. To achieve high</span></div>
<div style="position:absolute;left:108.00px;top:451.80px" class="cls_006"><span class="cls_006">performance, however, these architectural issues cannot be ignored since they can impact</span></div>
<div style="position:absolute;left:108.00px;top:463.92px" class="cls_006"><span class="cls_006">performance drastically. When it comes to performance we must bear in mind that</span></div>
<div style="position:absolute;left:126.00px;top:476.04px" class="cls_022"><span class="cls_022">o </span><span class="cls_006"> Memory is not infinite. It is the virtual memory system that makes it appear that way.</span></div>
<div style="position:absolute;left:126.00px;top:488.04px" class="cls_022"><span class="cls_022">o </span><span class="cls_006"> The cost of memory access is nonuniform. There are orders of magnitude difference</span></div>
<div style="position:absolute;left:144.00px;top:500.16px" class="cls_006"><span class="cls_006">among cache, main memory, and disk access.</span></div>
<div style="position:absolute;left:126.00px;top:512.28px" class="cls_022"><span class="cls_022">o </span><span class="cls_006"> Our program does not have a dedicated CPU. We get a time slice only once in a while.</span></div>
<div style="position:absolute;left:126.00px;top:524.28px" class="cls_022"><span class="cls_022">o </span><span class="cls_006"> On a uniprocessor machine, parallel threads do not truly execute in parallel—they take</span></div>
<div style="position:absolute;left:144.00px;top:536.40px" class="cls_006"><span class="cls_006">turns.</span></div>
<div style="position:absolute;left:108.00px;top:562.44px" class="cls_006"><span class="cls_006">Awareness of these issues helps software performance.</span></div>
<div style="position:absolute;left:90.00px;top:589.32px" class="cls_017"><span class="cls_017">•</span></div>
<div style="position:absolute;left:108.00px;top:588.72px" class="cls_015"><span class="cls_015">Libraries</span><span class="cls_006"> The choice of libraries used by an implementation can also affect performance. For</span></div>
<div style="position:absolute;left:108.00px;top:600.84px" class="cls_006"><span class="cls_006">starters, some libraries may perform a task faster than others. Because you typically don’t have</span></div>
<div style="position:absolute;left:108.00px;top:612.96px" class="cls_006"><span class="cls_006">access to the library’s source code, it is hard to tell how library calls implement their services. For</span></div>
<div style="position:absolute;left:108.00px;top:624.96px" class="cls_006"><span class="cls_006">example, to convert an integer to a character string, you can choose between</span></div>
<div style="position:absolute;left:108.00px;top:650.76px" class="cls_020"><span class="cls_020">sprintf(string, “%d”, i);</span></div>
<div style="position:absolute;left:108.00px;top:676.32px" class="cls_006"><span class="cls_006">or an integer-to-ASCII function call [</span><span class="cls_036">KR88</span><span class="cls_006">],</span></div>
<div style="position:absolute;left:108.00px;top:702.12px" class="cls_020"><span class="cls_020">itoa(i, string);</span></div>
<div style="position:absolute;left:108.00px;top:727.68px" class="cls_006"><span class="cls_006">Which one is more efficient? Is the difference significant?</span></div>
<div style="position:absolute;left:294.60px;top:791.64px" class="cls_003"><span class="cls_003">x</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:8520px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background011.jpg" width=595 height=842></div>
<div style="position:absolute;left:108.00px;top:70.92px" class="cls_006"><span class="cls_006">There is also the option of rolling your own version even if a particular service is already available</span></div>
<div style="position:absolute;left:108.00px;top:83.04px" class="cls_006"><span class="cls_006">in a library. Libraries are often designed with flexibility and reusability in mind. Often, flexibility</span></div>
<div style="position:absolute;left:108.00px;top:95.04px" class="cls_006"><span class="cls_006">and reusability trade off with performance. If, for some critical code fragment, you choose to put</span></div>
<div style="position:absolute;left:108.00px;top:107.16px" class="cls_006"><span class="cls_006">performance considerations above the other two, it might be reasonable to override a library</span></div>
<div style="position:absolute;left:108.00px;top:119.16px" class="cls_006"><span class="cls_006">service with your own home-grown implementation. Applications are so diverse in their specific</span></div>
<div style="position:absolute;left:108.00px;top:131.28px" class="cls_006"><span class="cls_006">needs, it is hard to design a library that will be the perfect solution for everybody, everywhere, all</span></div>
<div style="position:absolute;left:108.00px;top:143.40px" class="cls_006"><span class="cls_006">the time.</span></div>
<div style="position:absolute;left:90.00px;top:169.68px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Compiler optimizations</span><span class="cls_006"> Simply a more descriptive name than “miscellaneous,” this category</span></div>
<div style="position:absolute;left:108.00px;top:181.80px" class="cls_006"><span class="cls_006">includes all those small coding tricks that don’t fit in the other coding categories, such as loop</span></div>
<div style="position:absolute;left:108.00px;top:193.80px" class="cls_006"><span class="cls_006">unrolling, lifting constant expressions out of loops, and similar techniques for elimination of</span></div>
<div style="position:absolute;left:108.00px;top:205.92px" class="cls_006"><span class="cls_006">computational redundancies. Most compilers will perform many of those optimizations for you.</span></div>
<div style="position:absolute;left:108.00px;top:218.04px" class="cls_006"><span class="cls_006">But you cannot count on any specific compiler to perform a specific optimization. One compiler</span></div>
<div style="position:absolute;left:108.00px;top:230.04px" class="cls_006"><span class="cls_006">may unroll a loop twice, another will unroll it four times, and yet another compiler will not unroll</span></div>
<div style="position:absolute;left:108.00px;top:242.16px" class="cls_006"><span class="cls_006">it at all. For ultimate control, you have to take coding matters into your own hands.</span></div>
<div style="position:absolute;left:72.00px;top:295.92px" class="cls_016"><span class="cls_016">Our Goal</span></div>
<div style="position:absolute;left:72.00px;top:327.24px" class="cls_006"><span class="cls_006">Many books and articles have extolled the virtues of C++ as a language supporting the OO paradigm. C++</span></div>
<div style="position:absolute;left:72.00px;top:339.36px" class="cls_006"><span class="cls_006">is positioned as the latest cure for the software crisis. For those not familiar with the term, the software</span></div>
<div style="position:absolute;left:72.00px;top:351.36px" class="cls_006"><span class="cls_006">crisis is our current inability to develop code that is simple enough to be understood, maintained, and</span></div>
<div style="position:absolute;left:72.00px;top:363.48px" class="cls_006"><span class="cls_006">extended by a mere mortal, yet powerful enough to provide solutions to complex problems [</span><span class="cls_036">CE95</span><span class="cls_006">].</span></div>
<div style="position:absolute;left:72.00px;top:375.60px" class="cls_006"><span class="cls_006">Developers who migrate from other structured languages to C++ have been bombarded with information</span></div>
<div style="position:absolute;left:72.00px;top:387.60px" class="cls_006"><span class="cls_006">pertaining to the use of C++ in creating highly flexible and reusable code that will lend itself nicely to easy</span></div>
<div style="position:absolute;left:72.00px;top:399.72px" class="cls_006"><span class="cls_006">maintenance and extension. One important issue, however, has received little attention: run-time efficiency.</span></div>
<div style="position:absolute;left:72.00px;top:411.72px" class="cls_006"><span class="cls_006">We will examine the relevant performance topics from the perspective of C++ programming. After reading</span></div>
<div style="position:absolute;left:72.00px;top:423.84px" class="cls_006"><span class="cls_006">this book you should emerge with a clear understanding of the common C++ performance pitfalls and how</span></div>
<div style="position:absolute;left:72.00px;top:435.96px" class="cls_006"><span class="cls_006">to avoid them without compromising the clarity and simplicity of your design. In fact, the high-</span></div>
<div style="position:absolute;left:72.00px;top:447.96px" class="cls_006"><span class="cls_006">performance solution is frequently also the simplest solution. This book should also help developers</span></div>
<div style="position:absolute;left:72.00px;top:460.08px" class="cls_006"><span class="cls_006">produce C++ code as efficient as its C counterpart while still benefiting from the extended features of C++</span></div>
<div style="position:absolute;left:72.00px;top:472.20px" class="cls_006"><span class="cls_006">and the inherent superiority of the OO paradigm. A famous physicist once said that an expert is one who</span></div>
<div style="position:absolute;left:72.00px;top:484.20px" class="cls_006"><span class="cls_006">has made all possible mistakes in a very narrow field. Although making mistakes is a good way to learn,</span></div>
<div style="position:absolute;left:72.00px;top:496.32px" class="cls_006"><span class="cls_006">learning from the mistakes of others (the authors, in this case) is even better.</span></div>
<div style="position:absolute;left:72.00px;top:522.36px" class="cls_006"><span class="cls_006">A secondary goal of this book is to construct a one-stop shop for C++ performance issues. As a C++</span></div>
<div style="position:absolute;left:72.00px;top:534.48px" class="cls_006"><span class="cls_006">developer, the answers to your performance concerns are not readily available. They are scattered over a</span></div>
<div style="position:absolute;left:72.00px;top:546.48px" class="cls_006"><span class="cls_006">long list of books and magazine articles that address different pieces of this puzzle. You would have to</span></div>
<div style="position:absolute;left:72.00px;top:558.60px" class="cls_006"><span class="cls_006">research this topic and put it all together yourself. Not many developers are going to do that. We are too</span></div>
<div style="position:absolute;left:72.00px;top:570.60px" class="cls_006"><span class="cls_006">busy. It will be helpful to have a one-stop shop that focuses entirely on the important topic of C++</span></div>
<div style="position:absolute;left:72.00px;top:582.72px" class="cls_006"><span class="cls_006">performance.</span></div>
<div style="position:absolute;left:72.00px;top:636.48px" class="cls_016"><span class="cls_016">Software Efficiency: Does It Matter?</span></div>
<div style="position:absolute;left:72.00px;top:667.80px" class="cls_006"><span class="cls_006">In an era where processor speed doubles every 18 months (Moore's law), do we really need to worry about</span></div>
<div style="position:absolute;left:72.00px;top:679.92px" class="cls_006"><span class="cls_006">software efficiency? The fact is that regardless of phenomenal advances in chip technology, software</span></div>
<div style="position:absolute;left:72.00px;top:692.04px" class="cls_006"><span class="cls_006">efficiency is still a prominent concern. In 1971, the Intel 4004 was the first commercial processor to fit on</span></div>
<div style="position:absolute;left:72.00px;top:704.04px" class="cls_006"><span class="cls_006">a single chip. It was named a microprocessor. Since then, microprocessor technology has embarked on a</span></div>
<div style="position:absolute;left:72.00px;top:716.16px" class="cls_006"><span class="cls_006">25-year streak of doubling processor speed every 18 months. Today's microprocessors are tens of</span></div>
<div style="position:absolute;left:72.00px;top:728.28px" class="cls_006"><span class="cls_006">thousands of times faster than the Intel 4004. If processor speed was the answer to inefficient software, the</span></div>
<div style="position:absolute;left:72.00px;top:740.28px" class="cls_006"><span class="cls_006">issue would have been resolved and long forgotten. Yet, software efficiency is still a concern with most</span></div>
<div style="position:absolute;left:72.00px;top:752.40px" class="cls_006"><span class="cls_006">development organizations. Why?</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:9372px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background012.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">Imagine that you are trying to sell your product, say a Web application server, to a Fortune 500 company.</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">They need 600 transactions per second to run their business online. Your application server can support</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">only 60 transactions per second before running out of steam on the latest and greatest server hardware. If</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">the customer is to use your software, they need to string together a cluster of at least 10 servers to reach</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">their 600-transaction per second goal, raising the cost of your solution in terms of hardware, software</span></div>
<div style="position:absolute;left:72.00px;top:131.28px" class="cls_006"><span class="cls_006">licenses, network administration, and maintenance. To make matters worse, the customer has invited two</span></div>
<div style="position:absolute;left:72.00px;top:143.40px" class="cls_006"><span class="cls_006">of your competitors to pitch their own solutions. If a competitor has a more efficient implementation, they</span></div>
<div style="position:absolute;left:72.00px;top:155.40px" class="cls_006"><span class="cls_006">will need less hardware to deliver the required performance, and they will offer a cheaper solution. The</span></div>
<div style="position:absolute;left:72.00px;top:167.52px" class="cls_006"><span class="cls_006">speed of the processor is a constant in this situation—the software vendors in this story compete over the</span></div>
<div style="position:absolute;left:72.00px;top:179.64px" class="cls_006"><span class="cls_006">same hardware. It is often the case that the most efficient solution wins the bid.</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">You also must examine how processing speed compares to communication speed. If we can transmit data</span></div>
<div style="position:absolute;left:72.00px;top:217.68px" class="cls_006"><span class="cls_006">faster than the computer can generate it, then the computer (processor plus software) is the new bottleneck.</span></div>
<div style="position:absolute;left:72.00px;top:229.80px" class="cls_006"><span class="cls_006">The limits imposed by physics might soon put the brakes on the fantastic growth of processor speed</span></div>
<div style="position:absolute;left:72.00px;top:241.92px" class="cls_006"><span class="cls_006">[</span><span class="cls_036">Lew1</span><span class="cls_006">]. Not so for communication speed. Like processing speed, communication speed has enjoyed</span></div>
<div style="position:absolute;left:72.00px;top:253.92px" class="cls_006"><span class="cls_006">phenomenal growth. Back in 1970, 4800 bits per second was considered high-speed communication.</span></div>
<div style="position:absolute;left:72.00px;top:266.04px" class="cls_006"><span class="cls_006">Today, hundreds of megabits per second is common. The end of the road for communication speed is</span></div>
<div style="position:absolute;left:72.00px;top:278.16px" class="cls_006"><span class="cls_006">nowhere in sight [</span><span class="cls_036">Lew2</span><span class="cls_006">].</span></div>
<div style="position:absolute;left:72.00px;top:304.20px" class="cls_006"><span class="cls_006">Optical communication technology does not seem to have show-stopping technological roadblocks that</span></div>
<div style="position:absolute;left:72.00px;top:316.20px" class="cls_006"><span class="cls_006">will threaten progress in the near future. Several research labs are already experimenting with 100-gigabit-</span></div>
<div style="position:absolute;left:72.00px;top:328.32px" class="cls_006"><span class="cls_006">per-second all-optical networking. The biggest obstacle currently is not of a technical nature; it is the</span></div>
<div style="position:absolute;left:72.00px;top:340.44px" class="cls_006"><span class="cls_006">infrastructure. High-speed networking necessitates the rewiring of the information society from copper</span></div>
<div style="position:absolute;left:72.00px;top:352.44px" class="cls_006"><span class="cls_006">cables to optical fiber. This campaign is already underway. Communication adapters are already faster</span></div>
<div style="position:absolute;left:72.00px;top:364.56px" class="cls_006"><span class="cls_006">than the computing devices attached to them. Emerging network technologies such as 100 Mbps LAN</span></div>
<div style="position:absolute;left:72.00px;top:376.68px" class="cls_006"><span class="cls_006">adapters and high-speed ATM switches make computer speed critical. In the past, inefficient software has</span></div>
<div style="position:absolute;left:72.00px;top:388.68px" class="cls_006"><span class="cls_006">been masked by slow links. Popular communication protocols such as SNA and TCP/IP could easily</span></div>
<div style="position:absolute;left:72.00px;top:400.80px" class="cls_006"><span class="cls_006">overwhelm a 16 Mbps token ring adapter, leaving software performance bottlenecks undetected. Not so</span></div>
<div style="position:absolute;left:72.00px;top:412.80px" class="cls_006"><span class="cls_006">with 100 Mbps FDDI or Fast Ethernet. If 1,000 instructions are added to the protocol's send/receive path,</span></div>
<div style="position:absolute;left:72.00px;top:424.92px" class="cls_006"><span class="cls_006">they may not degrade throughput on a token ring connection because the protocol implementation can still</span></div>
<div style="position:absolute;left:72.00px;top:437.04px" class="cls_006"><span class="cls_006">pump data faster than the token ring can consume it. But an extra 1,000 instructions show up instantly as</span></div>
<div style="position:absolute;left:72.00px;top:449.04px" class="cls_006"><span class="cls_006">degraded throughput on a Fast Ethernet adapter. Today, very few computers are capable of saturating a</span></div>
<div style="position:absolute;left:72.00px;top:461.16px" class="cls_006"><span class="cls_006">high-speed link, and it is only going to get more difficult. Optical communication technology is now</span></div>
<div style="position:absolute;left:72.00px;top:473.16px" class="cls_006"><span class="cls_006">surpassing the growth rate of microprocessor speed. The computer (processor plus software) is quickly</span></div>
<div style="position:absolute;left:72.00px;top:485.28px" class="cls_006"><span class="cls_006">becoming the new bottleneck, and it's going to stay that way.</span></div>
<div style="position:absolute;left:72.00px;top:511.32px" class="cls_006"><span class="cls_006">To make a long story short, software performance is important and always will be. This one is not going</span></div>
<div style="position:absolute;left:72.00px;top:523.44px" class="cls_006"><span class="cls_006">away. As processor and communication technology march on, they redefine what "fast" means. They give</span></div>
<div style="position:absolute;left:72.00px;top:535.56px" class="cls_006"><span class="cls_006">rise to a new breed of bandwidth- and cycle-hungry applications that push the boundaries of technology.</span></div>
<div style="position:absolute;left:72.00px;top:547.56px" class="cls_006"><span class="cls_006">You never have enough horsepower. Software efficiency now becomes even more crucial than before.</span></div>
<div style="position:absolute;left:72.00px;top:559.68px" class="cls_006"><span class="cls_006">Whether the growth of processor speed is coming to an end or not, it will definitely trail communication</span></div>
<div style="position:absolute;left:72.00px;top:571.68px" class="cls_006"><span class="cls_006">speed. This puts the efficiency burden on the software. Further advances in execution speed will depend</span></div>
<div style="position:absolute;left:72.00px;top:583.80px" class="cls_006"><span class="cls_006">heavily on the efficiency of the software, not just the processor.</span></div>
<div style="position:absolute;left:72.00px;top:637.56px" class="cls_016"><span class="cls_016">Terminology</span></div>
<div style="position:absolute;left:72.00px;top:668.88px" class="cls_006"><span class="cls_006">Before moving on, here are a few words to clarify the terminology. "Performance" can stand for various</span></div>
<div style="position:absolute;left:72.00px;top:681.00px" class="cls_006"><span class="cls_006">metrics, the most common ones being space efficiency and time efficiency. Space efficiency seeks to</span></div>
<div style="position:absolute;left:72.00px;top:693.12px" class="cls_006"><span class="cls_006">minimize the use of memory in a software solution. Likewise, time efficiency seeks to minimize the use of</span></div>
<div style="position:absolute;left:72.00px;top:705.12px" class="cls_006"><span class="cls_006">processor cycles. Time efficiency is often represented in terms of response time and throughput. Other</span></div>
<div style="position:absolute;left:72.00px;top:717.24px" class="cls_006"><span class="cls_006">metrics include compile time and executable size.</span></div>
<div style="position:absolute;left:72.00px;top:743.28px" class="cls_006"><span class="cls_006">The rapidly falling price of memory has moved the topic of space efficiency for its own sake to the back</span></div>
<div style="position:absolute;left:72.00px;top:755.40px" class="cls_006"><span class="cls_006">burner. Desktop PCs with plenty of RAM (Random Access Memory) are common. Corporate customers</span></div>
<div style="position:absolute;left:291.36px;top:791.64px" class="cls_003"><span class="cls_003">xii</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:10224px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background013.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">are not that concerned about space issues these days. In our work with customers we have encountered</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">concerns with run-time efficiency for the most part. Since customers drive requirements, we will adopt</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">their focus on time efficiency. From here on, we will restrict performance to its time-efficiency</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">interpretation. Generally we will look at space considerations only when they interfere with run-time</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">performance, as in caching and paging.</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_006"><span class="cls_006">In discussing time efficiency, we will often mention the terms "pathlength" and "instruction count"</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">interchangeably. Both stand for the number of assembler language instructions generated by a fragment of</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">code. In a RISC architecture, if a code fragment exhibits a reasonable "locality of reference" (i.e., cache</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">hits), the ratio between instruction counts and clock cycles will approximate one. On CISC architectures it</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">may average two or more, but in any event, poor instruction counts always indicate poor execution time,</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">regardless of processor architecture. A good instruction count is necessary but not sufficient for high</span></div>
<div style="position:absolute;left:72.00px;top:217.68px" class="cls_006"><span class="cls_006">performance. Consequently, it is a crude performance indicator, but still useful. It will be used in</span></div>
<div style="position:absolute;left:72.00px;top:229.80px" class="cls_006"><span class="cls_006">conjunction with time measurements to evaluate efficiency.</span></div>
<div style="position:absolute;left:72.00px;top:283.56px" class="cls_016"><span class="cls_016">Organization of This Book</span></div>
<div style="position:absolute;left:72.00px;top:314.88px" class="cls_006"><span class="cls_006">We start the performance tour close to home with a real-life example. </span><span class="cls_036">Chapter 1</span><span class="cls_006"> is a war story of C++ code</span></div>
<div style="position:absolute;left:72.00px;top:327.00px" class="cls_006"><span class="cls_006">that exhibited atrocious performance, and what we did to resolve it. This example will drive home some</span></div>
<div style="position:absolute;left:72.00px;top:339.12px" class="cls_006"><span class="cls_006">performance lessons that might very well apply to diverse scenarios.</span></div>
<div style="position:absolute;left:72.00px;top:365.16px" class="cls_006"><span class="cls_006">Object-oriented design in C++ might harbor a performance cost. This is what we pay for the power of OO</span></div>
<div style="position:absolute;left:72.00px;top:377.28px" class="cls_006"><span class="cls_006">support. The significance of this cost, the factors affecting it, and how and when you can get around it are</span></div>
<div style="position:absolute;left:72.00px;top:389.28px" class="cls_006"><span class="cls_006">discussed in </span><span class="cls_036">Chapters 2</span><span class="cls_006">, </span><span class="cls_036">3</span><span class="cls_006">, and </span><span class="cls_036">4</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:415.32px" class="cls_036"><span class="cls_036">Chapter 5</span><span class="cls_006"> is dedicated to temporaries. The creation of temporary objects is a C++ feature that catches new</span></div>
<div style="position:absolute;left:72.00px;top:427.44px" class="cls_006"><span class="cls_006">C++ programmers off guard. C programmers are not used to the C compiler generating significant</span></div>
<div style="position:absolute;left:72.00px;top:439.56px" class="cls_006"><span class="cls_006">overhead "under the covers." If you aim to write high-efficiency C++, it is essential that you know when</span></div>
<div style="position:absolute;left:72.00px;top:451.56px" class="cls_006"><span class="cls_006">temporaries are generated by the C++ compiler and how to avoid them.</span></div>
<div style="position:absolute;left:72.00px;top:477.72px" class="cls_006"><span class="cls_006">Memory management is the subject of </span><span class="cls_036">Chapters 6</span><span class="cls_006"> and </span><span class="cls_036">7</span><span class="cls_006">. Allocating and deallocating memory on the fly is</span></div>
<div style="position:absolute;left:72.00px;top:490.20px" class="cls_006"><span class="cls_006">expensive. Functions such as </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006"> are designed to be flexible and general. They deal</span></div>
<div style="position:absolute;left:72.00px;top:502.56px" class="cls_006"><span class="cls_006">with variable-sized memory chunks in a multithreaded environment. As such, their speed is compromised.</span></div>
<div style="position:absolute;left:72.00px;top:514.68px" class="cls_006"><span class="cls_006">Oftentimes, you are in a position to make simplifying assumptions about your code that will significantly</span></div>
<div style="position:absolute;left:72.00px;top:526.68px" class="cls_006"><span class="cls_006">boost the speed of memory allocation and deallocation. These chapters will discuss several simplifying</span></div>
<div style="position:absolute;left:72.00px;top:538.80px" class="cls_006"><span class="cls_006">assumptions that can be made and the efficient memory managers that are designed to leverage them.</span></div>
<div style="position:absolute;left:72.00px;top:564.84px" class="cls_006"><span class="cls_006">Inlining is probably the second most popular performance tip, right after passing objects by reference. It is</span></div>
<div style="position:absolute;left:72.00px;top:577.44px" class="cls_006"><span class="cls_006">not as simple as it sounds. The </span><span class="cls_020">inline</span><span class="cls_006"> keyword, just like </span><span class="cls_020">register</span><span class="cls_006">, is just a hint that the compiler often</span></div>
<div style="position:absolute;left:72.00px;top:590.16px" class="cls_006"><span class="cls_006">ignores. Situations in which </span><span class="cls_020">inline</span><span class="cls_006"> is likely to be ignored and other unexpected consequences are</span></div>
<div style="position:absolute;left:72.00px;top:602.52px" class="cls_006"><span class="cls_006">discussed in </span><span class="cls_036">Chapters 8</span><span class="cls_006">, </span><span class="cls_036">9</span><span class="cls_006">, and </span><span class="cls_036">10</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:628.56px" class="cls_006"><span class="cls_006">Performance, flexibility, and reuse seldom go hand-in-hand. The Standard Template Library is an attempt</span></div>
<div style="position:absolute;left:72.00px;top:640.68px" class="cls_006"><span class="cls_006">to buck that trend and to combine these three into a powerful component. We will examine the</span></div>
<div style="position:absolute;left:72.00px;top:652.80px" class="cls_006"><span class="cls_006">performance of the STL in </span><span class="cls_036">Chapter 11</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:678.84px" class="cls_006"><span class="cls_006">Reference counting is a technique often used by experienced C++ programmers. You cannot dedicate a</span></div>
<div style="position:absolute;left:72.00px;top:690.84px" class="cls_006"><span class="cls_006">book to C++ performance without coverage of this technique, discussed in </span><span class="cls_036">Chapter 12</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:717.00px" class="cls_006"><span class="cls_006">Software performance cannot always be salvaged by a single "silver bullet" fix. Performance degradation</span></div>
<div style="position:absolute;left:72.00px;top:729.00px" class="cls_006"><span class="cls_006">is often a result of many small local inefficiencies, each of which is insignificant by itself. It is the</span></div>
<div style="position:absolute;left:72.00px;top:741.12px" class="cls_006"><span class="cls_006">combination that results in a significant degradation. Over the years, while resolving many performance</span></div>
<div style="position:absolute;left:72.00px;top:753.24px" class="cls_006"><span class="cls_006">bugs in various C++ products, we have come to identify certain bugs that seem to float to the surface</span></div>
<div style="position:absolute;left:289.68px;top:791.64px" class="cls_003"><span class="cls_003">xiii</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:11076px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background014.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">frequently. We divided the list into two sets: coding and design inefficiencies. The coding set contains</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">"low-hanging fruit"—small-scale, local coding optimizations you can perform without needing to</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">understand the overall design. In </span><span class="cls_036">Chapter 13</span><span class="cls_006"> we discuss various items of that nature. The second set</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">contains design optimizations that are global in nature. Those optimizations modify code that is spread</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">across the source code, and are the subject of </span><span class="cls_036">Chapter 14</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_036"><span class="cls_036">Chapter 15</span><span class="cls_006"> covers scalability issues, unique performance considerations present in a multiprocessor</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">environment that we don't encounter on a uniprocessor. This chapter discusses design and coding issues</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">aimed at exploiting parallelism. This chapter will also provide some help with the terminology and</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">concepts of multithreaded programming and synchronization. We refer to thread synchronization concepts</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">in several other places in the book. If your exposure to those concepts is limited, </span><span class="cls_036">Chapter 15</span><span class="cls_006"> should help</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">level the playing field.</span></div>
<div style="position:absolute;left:72.00px;top:231.72px" class="cls_036"><span class="cls_036">Chapter 16</span><span class="cls_006"> takes a look at the underlying system. Top-notch performance also necessitates a rudimentary</span></div>
<div style="position:absolute;left:72.00px;top:243.84px" class="cls_006"><span class="cls_006">understanding of underlying operating systems and processor architectures. Issues such as caching, paging,</span></div>
<div style="position:absolute;left:72.00px;top:255.84px" class="cls_006"><span class="cls_006">and threading are discussed here.</span></div>
<div style="position:absolute;left:289.92px;top:791.64px" class="cls_003"><span class="cls_003">xiv</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:11928px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background015.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 1. The Tracing War Story</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">Every software product we have ever worked on contained tracing functionality in one form or another.</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">Any time your source code exceeds a few thousand lines, tracing becomes essential. It is important for</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">debugging, maintaining, and understanding execution flow of nontrivial software. You would not expect a</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">trace discussion in a performance book but the reality is, on more than one occasion, we have run into</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">severe performance degradation due to poor implementations of tracing. Even slight inefficiencies can</span></div>
<div style="position:absolute;left:72.00px;top:178.32px" class="cls_006"><span class="cls_006">have a dramatic effect on performance. The goal of this chapter is not necessarily to teach proper trace</span></div>
<div style="position:absolute;left:72.00px;top:190.32px" class="cls_006"><span class="cls_006">implementation, but to use the trace vehicle to deliver some important performance principles that often</span></div>
<div style="position:absolute;left:72.00px;top:202.44px" class="cls_006"><span class="cls_006">surface in C++ code. The implementation of trace functionality runs into typical C++ performance</span></div>
<div style="position:absolute;left:72.00px;top:214.44px" class="cls_006"><span class="cls_006">obstacles, which makes it a good candidate for performance discussion. It is simple and familiar. We don't</span></div>
<div style="position:absolute;left:72.00px;top:226.56px" class="cls_006"><span class="cls_006">have to drown you in a sea of irrelevant details in order to highlight the important issues. Yet, simple or</span></div>
<div style="position:absolute;left:72.00px;top:238.68px" class="cls_006"><span class="cls_006">not, trace implementations drive home many performance issues that you are likely to encounter in any</span></div>
<div style="position:absolute;left:72.00px;top:250.68px" class="cls_006"><span class="cls_006">random fragment of C++ code.</span></div>
<div style="position:absolute;left:72.00px;top:277.32px" class="cls_006"><span class="cls_006">Many C++ programmers define a simple </span><span class="cls_020">Trace</span><span class="cls_006"> class to print diagnostic information to a log file.</span></div>
<div style="position:absolute;left:72.00px;top:290.04px" class="cls_006"><span class="cls_006">Programmers can define a </span><span class="cls_020">Trace</span><span class="cls_006"> object in each function that they want to trace, and the </span><span class="cls_020">Trace</span><span class="cls_006"> class can</span></div>
<div style="position:absolute;left:72.00px;top:302.88px" class="cls_006"><span class="cls_006">write a message on function entry and function exit. The </span><span class="cls_020">Trace</span><span class="cls_006"> objects will add extra execution overhead,</span></div>
<div style="position:absolute;left:72.00px;top:315.24px" class="cls_006"><span class="cls_006">but they will help a programmer find problems without using a debugger. If your C++ code happens to be</span></div>
<div style="position:absolute;left:72.00px;top:327.24px" class="cls_006"><span class="cls_006">embedded as native code in a Java program, using a Java debugger to trace your native code would be a</span></div>
<div style="position:absolute;left:72.00px;top:339.36px" class="cls_006"><span class="cls_006">challenge.</span></div>
<div style="position:absolute;left:72.00px;top:365.40px" class="cls_006"><span class="cls_006">The most extreme form of trace performance optimization would be to eliminate the performance cost</span></div>
<div style="position:absolute;left:72.00px;top:378.00px" class="cls_006"><span class="cls_006">altogether by embedding trace calls inside </span><span class="cls_020">#ifdef</span><span class="cls_006"> blocks:</span></div>
<div style="position:absolute;left:72.00px;top:403.92px" class="cls_020"><span class="cls_020">#ifdef TRACE</span></div>
<div style="position:absolute;left:72.00px;top:415.32px" class="cls_020"><span class="cls_020">Trace t("myFuction"); // Constructor takes a function name argument</span></div>
<div style="position:absolute;left:72.00px;top:426.60px" class="cls_020"><span class="cls_020">t.debug("Some information message");</span></div>
<div style="position:absolute;left:72.00px;top:437.88px" class="cls_020"><span class="cls_020">#endif</span></div>
<div style="position:absolute;left:72.00px;top:464.16px" class="cls_006"><span class="cls_006">The weakness of the </span><span class="cls_020">#ifdef</span><span class="cls_006"> approach is that you must recompile to turn tracing on and off. This is</span></div>
<div style="position:absolute;left:72.00px;top:476.40px" class="cls_006"><span class="cls_006">definitely something your customers will not be able to do unless you jump on the free software</span></div>
<div style="position:absolute;left:72.00px;top:488.52px" class="cls_006"><span class="cls_006">bandwagon and ship them your source code. Alternatively, you can control tracing dynamically by</span></div>
<div style="position:absolute;left:72.00px;top:501.00px" class="cls_006"><span class="cls_006">communicating with the running program. The </span><span class="cls_020">Trace</span><span class="cls_006"> class implementation could check the trace state</span></div>
<div style="position:absolute;left:72.00px;top:513.36px" class="cls_006"><span class="cls_006">prior to logging any trace information:</span></div>
<div style="position:absolute;left:72.00px;top:539.04px" class="cls_020"><span class="cls_020">void</span></div>
<div style="position:absolute;left:72.00px;top:550.44px" class="cls_020"><span class="cls_020">Trace::debug(string &msg)</span></div>
<div style="position:absolute;left:72.00px;top:561.72px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:573.12px" class="cls_020"><span class="cls_020">if (traceIsActive) {</span></div>
<div style="position:absolute;left:119.99px;top:584.40px" class="cls_020"><span class="cls_020">// log message here</span></div>
<div style="position:absolute;left:96.00px;top:595.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:607.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:632.76px" class="cls_006"><span class="cls_006">We don't care about performance when tracing is active. It is assumed that tracing will be turned on only</span></div>
<div style="position:absolute;left:72.00px;top:644.76px" class="cls_006"><span class="cls_006">during problem determination. During normal operation, tracing would be inactive by default, and we</span></div>
<div style="position:absolute;left:72.00px;top:656.88px" class="cls_006"><span class="cls_006">expect our code to exhibit peak performance. For that to happen, the trace overhead must be minimal. A</span></div>
<div style="position:absolute;left:72.00px;top:669.00px" class="cls_006"><span class="cls_006">typical trace statement will look something along the lines of</span></div>
<div style="position:absolute;left:72.00px;top:694.68px" class="cls_020"><span class="cls_020">t.debug("x = " + itoa(x));</span></div>
<div style="position:absolute;left:239.97px;top:694.68px" class="cls_020"><span class="cls_020">// itoa() converts an int to ascii</span></div>
<div style="position:absolute;left:72.00px;top:720.36px" class="cls_006"><span class="cls_006">This typical statement presents a serious performance problem. Even when tracing is off, we still must</span></div>
<div style="position:absolute;left:72.00px;top:732.96px" class="cls_006"><span class="cls_006">create the </span><span class="cls_020">string</span><span class="cls_006"> argument that is passed in to the </span><span class="cls_020">debug()</span><span class="cls_006"> function. This single statement hides</span></div>
<div style="position:absolute;left:72.00px;top:745.20px" class="cls_006"><span class="cls_006">substantial computation:</span></div>
<div style="position:absolute;left:294.60px;top:791.64px" class="cls_003"><span class="cls_003">1</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:12780px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background016.jpg" width=595 height=842></div>
<div style="position:absolute;left:90.00px;top:71.64px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Create a temporary </span><span class="cls_020">string</span><span class="cls_006"> object from </span><span class="cls_020">"x = "</span></div>
<div style="position:absolute;left:90.00px;top:84.72px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Call </span><span class="cls_020">itoa(x)</span></div>
<div style="position:absolute;left:90.00px;top:97.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Create a temporary </span><span class="cls_020">string</span><span class="cls_006"> object from the char pointer returned by </span><span class="cls_020">itoa()</span></div>
<div style="position:absolute;left:90.00px;top:110.76px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Concatenate the preceding </span><span class="cls_020">string</span><span class="cls_006"> objects to create a third temporary </span><span class="cls_020">string</span></div>
<div style="position:absolute;left:90.00px;top:123.84px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Destroy all three </span><span class="cls_020">string</span><span class="cls_006"> temporaries after returning from the </span><span class="cls_020">debug()</span><span class="cls_006"> call</span></div>
<div style="position:absolute;left:72.00px;top:150.72px" class="cls_006"><span class="cls_006">So we go to all this trouble to construct three temporary </span><span class="cls_020">string</span><span class="cls_006"> objects, and proceed to drop them all</span></div>
<div style="position:absolute;left:72.00px;top:162.96px" class="cls_006"><span class="cls_006">over the floor when we find out that trace is inactive. The overhead of creating and destroying those</span></div>
<div style="position:absolute;left:72.00px;top:175.56px" class="cls_020"><span class="cls_020">string</span><span class="cls_006"> and </span><span class="cls_020">Trace</span><span class="cls_006"> objects is at best hundreds of instructions. In typical OO code where functions are</span></div>
<div style="position:absolute;left:72.00px;top:187.92px" class="cls_006"><span class="cls_006">short and call frequencies are high, trace overhead could easily degrade performance by an order of</span></div>
<div style="position:absolute;left:72.00px;top:199.92px" class="cls_006"><span class="cls_006">magnitude. This is not a farfetched figment of our imagination. We have actually experienced it in a real-</span></div>
<div style="position:absolute;left:72.00px;top:212.04px" class="cls_006"><span class="cls_006">life product implementation. It is an educational experience to delve into this particular horror story in</span></div>
<div style="position:absolute;left:72.00px;top:224.16px" class="cls_006"><span class="cls_006">more detail. It is the story of an attempt to add tracing capability to a complex product consisting of a half-</span></div>
<div style="position:absolute;left:72.00px;top:236.16px" class="cls_006"><span class="cls_006">million lines of C++ code. Our first attempt backfired due to atrocious performance.</span></div>
<div style="position:absolute;left:72.00px;top:289.92px" class="cls_016"><span class="cls_016">Our Initial Trace Implementation</span></div>
<div style="position:absolute;left:72.00px;top:321.36px" class="cls_006"><span class="cls_006">Our intent was to have the trace object log event messages such as entering a function, leaving a function,</span></div>
<div style="position:absolute;left:72.00px;top:333.36px" class="cls_006"><span class="cls_006">and possibly other information of interest between those two events.</span></div>
<div style="position:absolute;left:72.00px;top:359.04px" class="cls_020"><span class="cls_020">int myFunction(int x)</span></div>
<div style="position:absolute;left:72.00px;top:370.44px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:381.72px" class="cls_020"><span class="cls_020">string name = "myFunction";</span></div>
<div style="position:absolute;left:96.00px;top:393.12px" class="cls_020"><span class="cls_020">Trace t(name);</span></div>
<div style="position:absolute;left:96.00px;top:415.68px" class="cls_020"><span class="cls_020">string moreInfo = "more interesting info";</span></div>
<div style="position:absolute;left:96.00px;top:427.08px" class="cls_020"><span class="cls_020">t.debug(moreInfo);</span></div>
<div style="position:absolute;left:72.00px;top:449.76px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:96.00px;top:449.76px" class="cls_020"><span class="cls_020">// Trace destructor logs exit event to an output stream</span></div>
<div style="position:absolute;left:72.00px;top:475.92px" class="cls_006"><span class="cls_006">To enable this usage we started out with the following </span><span class="cls_020">Trace</span><span class="cls_006"> implementation:</span></div>
<div style="position:absolute;left:72.00px;top:501.84px" class="cls_020"><span class="cls_020">class Trace {</span></div>
<div style="position:absolute;left:72.00px;top:513.24px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:524.52px" class="cls_020"><span class="cls_020">Trace (const string &name);</span></div>
<div style="position:absolute;left:96.00px;top:535.80px" class="cls_020"><span class="cls_020">~Trace ();</span></div>
<div style="position:absolute;left:96.00px;top:547.20px" class="cls_020"><span class="cls_020">void debug (const string &msg);</span></div>
<div style="position:absolute;left:96.00px;top:569.88px" class="cls_020"><span class="cls_020">static bool traceIsActive;</span></div>
<div style="position:absolute;left:72.00px;top:581.16px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:592.44px" class="cls_020"><span class="cls_020">string theFunctionName;</span></div>
<div style="position:absolute;left:72.00px;top:603.84px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:629.40px" class="cls_006"><span class="cls_006">The Trace constructor stores the function's name.</span></div>
<div style="position:absolute;left:72.00px;top:655.20px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:666.48px" class="cls_020"><span class="cls_020">Trace::Trace(const string &name) : theFunctionName(name)</span></div>
<div style="position:absolute;left:72.00px;top:677.88px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:689.16px" class="cls_020"><span class="cls_020">if (TraceIsActive) {</span></div>
<div style="position:absolute;left:119.99px;top:700.56px" class="cls_020"><span class="cls_020">cout &lt;&lt; "Enter function" &lt;&lt; name &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:711.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:723.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:749.40px" class="cls_006"><span class="cls_006">Additional information messages are logged via calls to the </span><span class="cls_020">debug()</span><span class="cls_006"> method.</span></div>
<div style="position:absolute;left:294.60px;top:791.64px" class="cls_003"><span class="cls_003">2</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:13632px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background017.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">void Trace::debug(const string &msg)</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">if (TraceIsActive) {</span></div>
<div style="position:absolute;left:119.99px;top:115.92px" class="cls_020"><span class="cls_020">cout &lt;&lt; msg &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:127.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:138.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:161.16px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:172.56px" class="cls_020"><span class="cls_020">Trace::~Trace()</span></div>
<div style="position:absolute;left:72.00px;top:183.84px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:195.12px" class="cls_020"><span class="cls_020">if (traceIsActive) {</span></div>
<div style="position:absolute;left:119.99px;top:206.52px" class="cls_020"><span class="cls_020">cout &lt;&lt; "Exit function " &lt;&lt; theFunctionName &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:217.80px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:229.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:255.36px" class="cls_006"><span class="cls_006">Once the </span><span class="cls_020">Trace</span><span class="cls_006"> was designed, coded, and tested, it was deployed and quickly inserted into a large part of</span></div>
<div style="position:absolute;left:72.00px;top:268.08px" class="cls_006"><span class="cls_006">the code. </span><span class="cls_020">Trace</span><span class="cls_006"> objects popped up in most of the functions on the critical execution path. On a subsequent</span></div>
<div style="position:absolute;left:72.00px;top:280.44px" class="cls_006"><span class="cls_006">performance test we were shocked to discover that performance plummeted to 20% of its previous level.</span></div>
<div style="position:absolute;left:72.00px;top:293.04px" class="cls_006"><span class="cls_006">The insertion of </span><span class="cls_020">Trace</span><span class="cls_006"> objects has slowed down performance by a factor of five. We are talking about the</span></div>
<div style="position:absolute;left:72.00px;top:305.28px" class="cls_006"><span class="cls_006">case when tracing was off and performance was supposed to be unaffected.</span></div>
<div style="position:absolute;left:72.00px;top:331.56px" class="cls_023"><span class="cls_023">What Went Wrong</span></div>
<div style="position:absolute;left:72.00px;top:360.36px" class="cls_006"><span class="cls_006">Programmers may have different views on C++ performance depending on their respective experiences.</span></div>
<div style="position:absolute;left:72.00px;top:372.48px" class="cls_006"><span class="cls_006">But there are a few basic principles that we all agree on:</span></div>
<div style="position:absolute;left:90.00px;top:398.76px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   I/O is expensive.</span></div>
<div style="position:absolute;left:90.00px;top:411.12px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Function call overhead is a factor so we should inline short, frequently called functions.</span></div>
<div style="position:absolute;left:90.00px;top:423.36px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Copying objects is expensive. Prefer pass-by-reference over pass-by-value.</span></div>
<div style="position:absolute;left:72.00px;top:450.00px" class="cls_006"><span class="cls_006">Our initial </span><span class="cls_020">Trace</span><span class="cls_006"> implementation has adhered to all three of these principles. We avoided I/O if tracing</span></div>
<div style="position:absolute;left:72.00px;top:462.72px" class="cls_006"><span class="cls_006">was off, all methods were inlined, and all </span><span class="cls_020">string</span><span class="cls_006"> arguments were passed by reference. We stuck by the</span></div>
<div style="position:absolute;left:72.00px;top:475.08px" class="cls_006"><span class="cls_006">rules and yet we got blindsided. Obviously, the collective wisdom of the previous rules fell short of the</span></div>
<div style="position:absolute;left:72.00px;top:487.20px" class="cls_006"><span class="cls_006">expertise required to develop high-performance C++.</span></div>
<div style="position:absolute;left:72.00px;top:513.24px" class="cls_006"><span class="cls_006">Our experience suggests that the dominant issue in C++ performance is not covered by these three</span></div>
<div style="position:absolute;left:72.00px;top:525.36px" class="cls_006"><span class="cls_006">principles. It is the creation (and eventual destruction) of unnecessary objects that were created in</span></div>
<div style="position:absolute;left:72.00px;top:537.84px" class="cls_006"><span class="cls_006">anticipation of being used but are not. The </span><span class="cls_020">Trace</span><span class="cls_006"> implementation is an example of the devastating effect</span></div>
<div style="position:absolute;left:72.00px;top:550.68px" class="cls_006"><span class="cls_006">of useless objects on performance, evident even in the simplest use of a </span><span class="cls_020">Trace</span><span class="cls_006"> object. The minimal usage</span></div>
<div style="position:absolute;left:72.00px;top:563.52px" class="cls_006"><span class="cls_006">of a </span><span class="cls_020">Trace</span><span class="cls_006"> object is to log function entry and exit:</span></div>
<div style="position:absolute;left:72.00px;top:589.44px" class="cls_020"><span class="cls_020">int myFunction(int x)</span></div>
<div style="position:absolute;left:72.00px;top:600.72px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:612.12px" class="cls_020"><span class="cls_020">string name = "myFunction";</span></div>
<div style="position:absolute;left:96.00px;top:623.40px" class="cls_020"><span class="cls_020">Trace t(name);</span></div>
<div style="position:absolute;left:72.00px;top:646.08px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:671.64px" class="cls_006"><span class="cls_006">This minimal trace invokes a sequence of computations:</span></div>
<div style="position:absolute;left:90.00px;top:698.52px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Create the </span><span class="cls_020">string</span><span class="cls_006"> </span><span class="cls_020">name</span><span class="cls_006"> local to </span><span class="cls_020">myFunction.</span></div>
<div style="position:absolute;left:90.00px;top:711.60px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Invoke the </span><span class="cls_020">Trace</span><span class="cls_006"> constructor.</span></div>
<div style="position:absolute;left:90.00px;top:724.68px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The </span><span class="cls_020">Trace</span><span class="cls_006"> constructor invokes the </span><span class="cls_020">string</span><span class="cls_006"> constructor to create the member </span><span class="cls_020">string</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:294.60px;top:791.64px" class="cls_003"><span class="cls_003">3</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:14484px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background018.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">At the end of the scope, which coincides with the end of the function, the </span><span class="cls_020">Trace</span><span class="cls_006"> and two </span><span class="cls_020">string</span><span class="cls_006"> objects</span></div>
<div style="position:absolute;left:72.00px;top:83.76px" class="cls_006"><span class="cls_006">are destroyed:</span></div>
<div style="position:absolute;left:90.00px;top:110.52px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Destroy the </span><span class="cls_020">string</span><span class="cls_006"> </span><span class="cls_020">name</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:90.00px;top:123.60px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Invoke the </span><span class="cls_020">Trace</span><span class="cls_006"> destructor.</span></div>
<div style="position:absolute;left:90.00px;top:136.68px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The </span><span class="cls_020">Trace</span><span class="cls_006"> destructor invokes the </span><span class="cls_020">string</span><span class="cls_006"> destructor for the member </span><span class="cls_020">string</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:163.44px" class="cls_006"><span class="cls_006">When tracing is off, the </span><span class="cls_020">string</span><span class="cls_006"> member object never gets used. You could also make the case that the</span></div>
<div style="position:absolute;left:72.00px;top:176.28px" class="cls_020"><span class="cls_020">Trace</span><span class="cls_006"> object itself is not of much use either (when tracing is off). All the computational effort that goes</span></div>
<div style="position:absolute;left:72.00px;top:188.64px" class="cls_006"><span class="cls_006">into the creation and destruction of those objects is a pure waste. Keep in mind that this is the cost when</span></div>
<div style="position:absolute;left:72.00px;top:200.64px" class="cls_006"><span class="cls_006">tracing is off. This was supposed to be the fast lane.</span></div>
<div style="position:absolute;left:72.00px;top:226.68px" class="cls_006"><span class="cls_006">So how expensive does it get? For a baseline measurement, we timed the execution of a million iterations</span></div>
<div style="position:absolute;left:72.00px;top:239.28px" class="cls_006"><span class="cls_006">of the function </span><span class="cls_020">addOne()</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:265.20px" class="cls_020"><span class="cls_020">int addOne(int x)</span></div>
<div style="position:absolute;left:203.98px;top:265.20px" class="cls_020"><span class="cls_020">// Version 0</span></div>
<div style="position:absolute;left:72.00px;top:276.60px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:287.88px" class="cls_020"><span class="cls_020">return x+1;</span></div>
<div style="position:absolute;left:72.00px;top:299.28px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:325.44px" class="cls_006"><span class="cls_006">As you can tell, </span><span class="cls_020">addOne()</span><span class="cls_006"> doesn't do much, which is exactly the point of a baseline. We are trying to</span></div>
<div style="position:absolute;left:72.00px;top:338.16px" class="cls_006"><span class="cls_006">isolate the performance factors one at a time. Our </span><span class="cls_020">main()</span><span class="cls_006"> function invoked </span><span class="cls_020">addOne()</span><span class="cls_006"> a million times</span></div>
<div style="position:absolute;left:72.00px;top:350.52px" class="cls_006"><span class="cls_006">and measured execution time:</span></div>
<div style="position:absolute;left:72.00px;top:376.20px" class="cls_020"><span class="cls_020">int main()</span></div>
<div style="position:absolute;left:72.00px;top:387.60px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:398.88px" class="cls_020"><span class="cls_020">Trace::traceIsActive = false;//Turn tracing off</span></div>
<div style="position:absolute;left:96.00px;top:410.28px" class="cls_020"><span class="cls_020">//...</span></div>
<div style="position:absolute;left:96.00px;top:421.56px" class="cls_020"><span class="cls_020">GetSystemTime(&t1);</span></div>
<div style="position:absolute;left:233.97px;top:421.56px" class="cls_020"><span class="cls_020">// Start timing</span></div>
<div style="position:absolute;left:96.00px;top:444.24px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; j; i++) {</span></div>
<div style="position:absolute;left:113.99px;top:455.52px" class="cls_020"><span class="cls_020">y = addOne(i);</span></div>
<div style="position:absolute;left:96.00px;top:466.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:489.48px" class="cls_020"><span class="cls_020">GetSystemTime(&t2);</span></div>
<div style="position:absolute;left:233.97px;top:489.48px" class="cls_020"><span class="cls_020">// Stop timing</span></div>
<div style="position:absolute;left:96.00px;top:500.88px" class="cls_020"><span class="cls_020">// ...</span></div>
<div style="position:absolute;left:72.00px;top:512.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:538.44px" class="cls_006"><span class="cls_006">Next, we added a </span><span class="cls_020">Trace</span><span class="cls_006"> object to </span><span class="cls_020">addOne</span><span class="cls_006"> and measured again to evaluate the performance delta. This is</span></div>
<div style="position:absolute;left:72.00px;top:550.68px" class="cls_006"><span class="cls_006">Version 1 (see </span><span class="cls_036">Figure 1.1</span><span class="cls_006">):</span></div>
<div style="position:absolute;left:72.00px;top:576.36px" class="cls_020"><span class="cls_020">int addOne(int x)</span></div>
<div style="position:absolute;left:203.98px;top:576.36px" class="cls_020"><span class="cls_020">// Version 1. Introducing a Trace object</span></div>
<div style="position:absolute;left:72.00px;top:587.76px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:599.04px" class="cls_020"><span class="cls_020">string name = "addOne";</span></div>
<div style="position:absolute;left:96.00px;top:610.32px" class="cls_020"><span class="cls_020">Trace t(name);</span></div>
<div style="position:absolute;left:96.00px;top:633.00px" class="cls_020"><span class="cls_020">return x + 1;</span></div>
<div style="position:absolute;left:72.00px;top:644.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:161.64px;top:669.36px" class="cls_021"><span class="cls_021">Figure 1.1. The performance cost of the </span><span class="cls_024">Trace</span><span class="cls_021"> object.</span></div>
<div style="position:absolute;left:294.60px;top:791.64px" class="cls_003"><span class="cls_003">4</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:15336px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background019.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:317.16px" class="cls_006"><span class="cls_006">The cost of the for loop has skyrocketed from 55 ms to 3,500 ms. In other words, the speed of </span><span class="cls_020">addOne</span><span class="cls_006"> has</span></div>
<div style="position:absolute;left:72.00px;top:329.52px" class="cls_006"><span class="cls_006">plummeted by a factor of more than 60. This kind of overhead will wreak havoc on the performance of any</span></div>
<div style="position:absolute;left:72.00px;top:341.52px" class="cls_006"><span class="cls_006">software. The cost of our tracing implementation was clearly unacceptable. But eliminating the tracing</span></div>
<div style="position:absolute;left:72.00px;top:353.64px" class="cls_006"><span class="cls_006">mechanism altogether was not an option—we had to have some form of tracing functionality. We had to</span></div>
<div style="position:absolute;left:72.00px;top:365.64px" class="cls_006"><span class="cls_006">regroup and come up with a more efficient implementation.</span></div>
<div style="position:absolute;left:72.00px;top:391.92px" class="cls_023"><span class="cls_023">The Recovery Plan</span></div>
<div style="position:absolute;left:72.00px;top:420.72px" class="cls_006"><span class="cls_006">The performance recovery plan was to eliminate objects and computations whose values get dropped when</span></div>
<div style="position:absolute;left:72.00px;top:433.32px" class="cls_006"><span class="cls_006">tracing is off. We started with the </span><span class="cls_020">string</span><span class="cls_006"> argument created by </span><span class="cls_020">addOne</span><span class="cls_006"> and given to the </span><span class="cls_020">Trace</span></div>
<div style="position:absolute;left:72.00px;top:446.04px" class="cls_006"><span class="cls_006">constructor. We modified the function name argument from a </span><span class="cls_020">string</span><span class="cls_006"> object to a plain </span><span class="cls_020">char</span><span class="cls_006"> pointer:</span></div>
<div style="position:absolute;left:72.00px;top:472.08px" class="cls_020"><span class="cls_020">int addOne(int x)</span></div>
<div style="position:absolute;left:203.98px;top:472.08px" class="cls_020"><span class="cls_020">// Version 2. Forget the string object.</span></div>
<div style="position:absolute;left:203.98px;top:483.36px" class="cls_020"><span class="cls_020">// Use a char pointer instead.</span></div>
<div style="position:absolute;left:72.00px;top:494.76px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:506.04px" class="cls_020"><span class="cls_020">char</span></div>
<div style="position:absolute;left:131.99px;top:506.04px" class="cls_020"><span class="cls_020">*name = "addOne";</span></div>
<div style="position:absolute;left:96.00px;top:517.32px" class="cls_020"><span class="cls_020">Trace t(name);</span></div>
<div style="position:absolute;left:96.00px;top:540.00px" class="cls_020"><span class="cls_020">return x+1;</span></div>
<div style="position:absolute;left:72.00px;top:551.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:588.84px" class="cls_006"><span class="cls_006">Along with that modification, we had to modify the </span><span class="cls_020">Trace</span><span class="cls_006"> constructor itself to take a </span><span class="cls_020">char</span><span class="cls_006"> pointer</span></div>
<div style="position:absolute;left:72.00px;top:601.68px" class="cls_006"><span class="cls_006">argument instead of a </span><span class="cls_020">string</span><span class="cls_006"> reference:</span></div>
<div style="position:absolute;left:72.00px;top:627.60px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:638.88px" class="cls_020"><span class="cls_020">Trace::Trace(const char *name) : theFunctionName(name)// Version 2</span></div>
<div style="position:absolute;left:72.00px;top:650.28px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:661.56px" class="cls_020"><span class="cls_020">if (traceIsActive) {</span></div>
<div style="position:absolute;left:119.99px;top:672.96px" class="cls_020"><span class="cls_020">cout &lt;&lt; "Enter function" &lt;&lt; name &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:684.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:695.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:721.80px" class="cls_006"><span class="cls_006">Similarly, the </span><span class="cls_020">Trace::debug()</span><span class="cls_006"> method was modified as well to accept a </span><span class="cls_020">const *char</span><span class="cls_006"> as an input</span></div>
<div style="position:absolute;left:72.00px;top:734.52px" class="cls_006"><span class="cls_006">argument instead of a </span><span class="cls_020">string</span><span class="cls_006">. Now we don't have to create the </span><span class="cls_020">name</span><span class="cls_006"> </span><span class="cls_020">string</span><span class="cls_006"> prior to creating the</span></div>
<div style="position:absolute;left:294.60px;top:791.64px" class="cls_003"><span class="cls_003">5</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:16188px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background020.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_020"><span class="cls_020">Trace</span><span class="cls_006"> object—one less object to worry about. This translated into a performance boost, as was evident in</span></div>
<div style="position:absolute;left:72.00px;top:83.76px" class="cls_006"><span class="cls_006">our measurement. Execution time dropped from 3,500 ms to 2,500 ms (see </span><span class="cls_036">Figure 1.2</span><span class="cls_006">).</span></div>
<div style="position:absolute;left:171.84px;top:109.92px" class="cls_021"><span class="cls_021">Figure 1.2. Impact of eliminating one string object.</span></div>
<div style="position:absolute;left:72.00px;top:382.08px" class="cls_006"><span class="cls_006">The second step is to eliminate the unconditional creation of the </span><span class="cls_020">string</span><span class="cls_006"> member object contained within</span></div>
<div style="position:absolute;left:72.00px;top:394.92px" class="cls_006"><span class="cls_006">the </span><span class="cls_020">Trace</span><span class="cls_006"> object. From a performance perspective we have two equivalent solutions. One is to replace the</span></div>
<div style="position:absolute;left:72.00px;top:407.76px" class="cls_020"><span class="cls_020">string</span><span class="cls_006"> object with a plain </span><span class="cls_020">char</span><span class="cls_006"> pointer. A </span><span class="cls_020">char</span><span class="cls_006"> pointer gets "constructed" by a simple assignment—</span></div>
<div style="position:absolute;left:72.00px;top:420.00px" class="cls_006"><span class="cls_006">that's cheap. The other solution is to use composition instead of aggregation. Instead of embedding a</span></div>
<div style="position:absolute;left:72.00px;top:432.60px" class="cls_020"><span class="cls_020">string</span><span class="cls_006"> subobject in the </span><span class="cls_020">Trace</span><span class="cls_006"> object, we could replace it with a </span><span class="cls_020">string</span><span class="cls_006"> pointer. The advantage of a</span></div>
<div style="position:absolute;left:72.00px;top:445.44px" class="cls_020"><span class="cls_020">string</span><span class="cls_006"> pointer over a </span><span class="cls_020">string</span><span class="cls_006"> object is that we can delay creation of the </span><span class="cls_020">string</span><span class="cls_006"> after we have verified</span></div>
<div style="position:absolute;left:72.00px;top:457.68px" class="cls_006"><span class="cls_006">that tracing was on. We opted to take that route:</span></div>
<div style="position:absolute;left:72.00px;top:483.48px" class="cls_020"><span class="cls_020">class Trace {</span></div>
<div style="position:absolute;left:173.98px;top:483.48px" class="cls_020"><span class="cls_020">//Version 3. Use a string pointer</span></div>
<div style="position:absolute;left:72.00px;top:494.76px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:506.04px" class="cls_020"><span class="cls_020">Trace (const char *name) : theFunctionName(0)</span></div>
<div style="position:absolute;left:96.00px;top:517.44px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:528.72px" class="cls_020"><span class="cls_020">if (traceIsActive) {</span></div>
<div style="position:absolute;left:287.96px;top:528.72px" class="cls_020"><span class="cls_020">// Conditional creation</span></div>
<div style="position:absolute;left:113.99px;top:540.12px" class="cls_020"><span class="cls_020">cout &lt;&lt; "Enter function" &lt;&lt; name &lt; endl;</span></div>
<div style="position:absolute;left:113.99px;top:551.40px" class="cls_020"><span class="cls_020">theFunctionName = new string(name);</span></div>
<div style="position:absolute;left:113.99px;top:562.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:574.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:608.04px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:630.72px" class="cls_020"><span class="cls_020">string *theFunctionName;</span></div>
<div style="position:absolute;left:72.00px;top:642.00px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:668.28px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">Trace</span><span class="cls_006"> destructor must also be modified to delete the </span><span class="cls_020">string</span><span class="cls_006"> pointer:</span></div>
<div style="position:absolute;left:72.00px;top:694.20px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:705.48px" class="cls_020"><span class="cls_020">Trace::~Trace()</span></div>
<div style="position:absolute;left:72.00px;top:716.88px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:728.16px" class="cls_020"><span class="cls_020">if (traceIsActive) {</span></div>
<div style="position:absolute;left:119.99px;top:739.44px" class="cls_020"><span class="cls_020">cout &lt;&lt; "Exit function " &lt;&lt; *theFunctionName &lt;&lt; endl;</span></div>
<div style="position:absolute;left:119.99px;top:750.84px" class="cls_020"><span class="cls_020">delete theFunctionName;</span></div>
<div style="position:absolute;left:294.60px;top:791.64px" class="cls_003"><span class="cls_003">6</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:17040px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background021.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:107.64px" class="cls_006"><span class="cls_006">Another measurement has shown a significant performance improvement. Response time has dropped</span></div>
<div style="position:absolute;left:72.00px;top:119.64px" class="cls_006"><span class="cls_006">from 2,500 ms to 185 ms (see </span><span class="cls_036">Figure 1.3</span><span class="cls_006">).</span></div>
<div style="position:absolute;left:139.68px;top:145.80px" class="cls_021"><span class="cls_021">Figure 1.3. Impact of conditional creation of the string member.</span></div>
<div style="position:absolute;left:72.00px;top:436.08px" class="cls_006"><span class="cls_006">So we have arrived. We took the </span><span class="cls_020">Trace</span><span class="cls_006"> implementation from 3,500 ms down to 185 ms. You may still</span></div>
<div style="position:absolute;left:72.00px;top:448.80px" class="cls_006"><span class="cls_006">contend that 185 ms looks pretty bad compared to a 55-ms execution time when </span><span class="cls_020">addOne</span><span class="cls_006"> had no tracing</span></div>
<div style="position:absolute;left:72.00px;top:461.16px" class="cls_006"><span class="cls_006">logic at all. This is more than 3x degradation. So how can we claim victory? The point is that the original</span></div>
<div style="position:absolute;left:72.00px;top:473.76px" class="cls_020"><span class="cls_020">addOne</span><span class="cls_006"> function (without trace) did very little. It added one to its input argument and returned</span></div>
<div style="position:absolute;left:72.00px;top:486.48px" class="cls_006"><span class="cls_006">immediately. The addition of any code to </span><span class="cls_020">addOne</span><span class="cls_006"> would have a profound effect on its execution time. If</span></div>
<div style="position:absolute;left:72.00px;top:498.84px" class="cls_006"><span class="cls_006">you add four instructions to trace the behavior of only two instructions, you have tripled your execution</span></div>
<div style="position:absolute;left:72.00px;top:510.96px" class="cls_006"><span class="cls_006">time. Conversely, if you increase by four instructions an execution path already containing 200, you have</span></div>
<div style="position:absolute;left:72.00px;top:523.44px" class="cls_006"><span class="cls_006">only degraded execution time by 2%. If </span><span class="cls_020">addOne</span><span class="cls_006"> consisted of more complex computations, the addition of</span></div>
<div style="position:absolute;left:72.00px;top:536.28px" class="cls_020"><span class="cls_020">Trace</span><span class="cls_006"> would have been closer to being negligible.</span></div>
<div style="position:absolute;left:72.00px;top:562.56px" class="cls_006"><span class="cls_006">In some ways, this is similar to inlining. The influence of inlining on heavyweight functions is negligible.</span></div>
<div style="position:absolute;left:72.00px;top:574.68px" class="cls_006"><span class="cls_006">Inlining plays a major role only for simple functions that are dominated by the call and return overhead.</span></div>
<div style="position:absolute;left:72.00px;top:586.80px" class="cls_006"><span class="cls_006">The functions that make excellent candidates for inlining are precisely the ones that are bad candidates for</span></div>
<div style="position:absolute;left:72.00px;top:599.28px" class="cls_006"><span class="cls_006">tracing. It follows that </span><span class="cls_020">Trace</span><span class="cls_006"> objects should not be added to small, frequently executed functions.</span></div>
<div style="position:absolute;left:72.00px;top:653.40px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:684.96px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Object definitions trigger silent execution in the form of object constructors and destructors. We</span></div>
<div style="position:absolute;left:108.00px;top:696.96px" class="cls_006"><span class="cls_006">call it "silent execution" as opposed to "silent overhead" because object construction and</span></div>
<div style="position:absolute;left:108.00px;top:709.08px" class="cls_006"><span class="cls_006">destruction are not usually overhead. If the computations performed by the constructor and</span></div>
<div style="position:absolute;left:108.00px;top:721.20px" class="cls_006"><span class="cls_006">destructor are always necessary, then they would be considered efficient code (inlining would</span></div>
<div style="position:absolute;left:108.00px;top:733.20px" class="cls_006"><span class="cls_006">alleviate the cost of call and return overhead). As we have seen, constructors and destructors do</span></div>
<div style="position:absolute;left:108.00px;top:745.32px" class="cls_006"><span class="cls_006">not always have such "pure" characteristics, and they can create significant overhead. In some</span></div>
<div style="position:absolute;left:294.60px;top:791.64px" class="cls_003"><span class="cls_003">7</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:17892px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background022.jpg" width=595 height=842></div>
<div style="position:absolute;left:108.00px;top:70.92px" class="cls_006"><span class="cls_006">situations, computations performed by the constructor (and/or destructor) are left unused. We</span></div>
<div style="position:absolute;left:108.00px;top:83.04px" class="cls_006"><span class="cls_006">should also point out that this is more of a design issue than a C++ language issue. However, it is</span></div>
<div style="position:absolute;left:108.00px;top:95.04px" class="cls_006"><span class="cls_006">seen less often in C because it lacks constructor and destructor support.</span></div>
<div style="position:absolute;left:90.00px;top:107.40px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Just because we pass an object by reference does not guarantee good performance. Avoiding</span></div>
<div style="position:absolute;left:108.00px;top:119.52px" class="cls_006"><span class="cls_006">object copy helps, but it would be helpful if we didn't have to construct and destroy the object in</span></div>
<div style="position:absolute;left:108.00px;top:131.52px" class="cls_006"><span class="cls_006">the first place.</span></div>
<div style="position:absolute;left:90.00px;top:143.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Don't waste effort on computations whose results are not likely to be used. When tracing is off, the</span></div>
<div style="position:absolute;left:108.00px;top:156.36px" class="cls_006"><span class="cls_006">creation of the </span><span class="cls_020">string</span><span class="cls_006"> member is worthless and costly.</span></div>
<div style="position:absolute;left:90.00px;top:168.96px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Don't aim for the world record in design flexibility. All you need is a design that's sufficiently</span></div>
<div style="position:absolute;left:108.00px;top:181.56px" class="cls_006"><span class="cls_006">flexible for the problem domain. A </span><span class="cls_020">char</span><span class="cls_006"> pointer can sometimes do the simple jobs just as well,</span></div>
<div style="position:absolute;left:108.00px;top:194.40px" class="cls_006"><span class="cls_006">and more efficiently, than a </span><span class="cls_020">string</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:90.00px;top:206.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Inline. Eliminate the function call overhead that comes with small, frequently invoked function</span></div>
<div style="position:absolute;left:108.00px;top:219.48px" class="cls_006"><span class="cls_006">calls. Inlining the </span><span class="cls_020">Trace</span><span class="cls_006"> constructor and destructor makes it easier to digest the </span><span class="cls_020">Trace</span><span class="cls_006"> overhead.</span></div>
<div style="position:absolute;left:294.60px;top:791.64px" class="cls_003"><span class="cls_003">8</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:18744px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background023.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 2. Constructors and Destructors</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">In an ideal world, there would never be a chapter dedicated to the performance implications of constructors</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">and destructors. In that ideal world, constructors and destructors would have no overhead. They would</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">perform only mandatory initialization and cleanup, and the average compiler would inline them. C code</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">such as</span></div>
<div style="position:absolute;left:72.00px;top:179.88px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:191.16px" class="cls_020"><span class="cls_020">struct X x1;</span></div>
<div style="position:absolute;left:96.00px;top:202.44px" class="cls_020"><span class="cls_020">init(&x1);</span></div>
<div style="position:absolute;left:96.00px;top:225.12px" class="cls_020"><span class="cls_020">cleanup(&x1);</span></div>
<div style="position:absolute;left:72.00px;top:236.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:262.08px" class="cls_006"><span class="cls_006">would be accomplished in C++ by:</span></div>
<div style="position:absolute;left:72.00px;top:287.88px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:299.16px" class="cls_020"><span class="cls_020">X x1;</span></div>
<div style="position:absolute;left:72.00px;top:321.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:347.64px" class="cls_006"><span class="cls_006">and the cost would be identical. That's the theory. Down here in the trenches of software development, the</span></div>
<div style="position:absolute;left:72.00px;top:359.64px" class="cls_006"><span class="cls_006">reality is a little different. We often encounter inheritance and composition implementations that are too</span></div>
<div style="position:absolute;left:72.00px;top:371.64px" class="cls_006"><span class="cls_006">flexible and too generic for the problem domain. They may perform computations that are rarely or never</span></div>
<div style="position:absolute;left:72.00px;top:383.76px" class="cls_006"><span class="cls_006">required. In practice, it is not surprising to discover performance overhead associated with inheritance and</span></div>
<div style="position:absolute;left:72.00px;top:395.88px" class="cls_006"><span class="cls_006">composition. This is a limited manifestation of a bigger issue—the fundamental tension between code</span></div>
<div style="position:absolute;left:72.00px;top:407.88px" class="cls_006"><span class="cls_006">reuse and performance. Inheritance and composition involve code reuse. Oftentimes, reusable code will</span></div>
<div style="position:absolute;left:72.00px;top:420.00px" class="cls_006"><span class="cls_006">compute things you don't really need in a specific scenario. Any time you call functions that do more than</span></div>
<div style="position:absolute;left:72.00px;top:432.12px" class="cls_006"><span class="cls_006">you really need, you will take a performance hit.</span></div>
<div style="position:absolute;left:72.00px;top:485.88px" class="cls_016"><span class="cls_016">Inheritance</span></div>
<div style="position:absolute;left:72.00px;top:517.20px" class="cls_006"><span class="cls_006">Inheritance and composition are two ways in which classes are tied together in an object-oriented design.</span></div>
<div style="position:absolute;left:72.00px;top:529.20px" class="cls_006"><span class="cls_006">In this section we want to examine the connection between inheritance-based designs and the cost of</span></div>
<div style="position:absolute;left:72.00px;top:541.32px" class="cls_006"><span class="cls_006">constructors and destructors. We drive this discussion with a practical example: the implementation of</span></div>
<div style="position:absolute;left:72.00px;top:552.60px" class="cls_006"><span class="cls_006">thread synchronization constructs.</span><span class="cls_037"><sup>[1]</sup></span><span class="cls_006"> In multithreaded applications, you often need to provide thread</span></div>
<div style="position:absolute;left:72.00px;top:566.04px" class="cls_006"><span class="cls_006">synchronization to restrict concurrent access to shared resources. Thread synchronization constructs appear</span></div>
<div style="position:absolute;left:72.00px;top:578.16px" class="cls_006"><span class="cls_006">in varied forms. The three most common ones are </span><span class="cls_007">semaphore, mutex,</span><span class="cls_006"> and </span><span class="cls_007">critical section.</span></div>
<div style="position:absolute;left:90.00px;top:603.48px" class="cls_026"><span class="cls_026"><sup>[1]</sup></span><span class="cls_027"> </span><span class="cls_038">Chapter 15</span><span class="cls_027"> provides more information on the fundamental concepts and terminology of multithreaded</span></div>
<div style="position:absolute;left:90.00px;top:617.16px" class="cls_027"><span class="cls_027">programming.</span></div>
<div style="position:absolute;left:72.00px;top:641.16px" class="cls_006"><span class="cls_006">A </span><span class="cls_007">semaphore</span><span class="cls_006"> provides restricted concurrency. It allows multiple threads to access a shared resource up to a</span></div>
<div style="position:absolute;left:72.00px;top:653.28px" class="cls_006"><span class="cls_006">given maximum. When the maximum number of concurrent threads is set to 1, we end up with a special</span></div>
<div style="position:absolute;left:72.00px;top:665.40px" class="cls_006"><span class="cls_006">semaphore called a </span><span class="cls_007">mutex</span><span class="cls_006"> (MUTual EXclusion). A mutex protects shared resources by allowing one and</span></div>
<div style="position:absolute;left:72.00px;top:677.40px" class="cls_006"><span class="cls_006">only one thread to operate on the resource at any one time. A shared resource typically is manipulated in</span></div>
<div style="position:absolute;left:72.00px;top:689.52px" class="cls_006"><span class="cls_006">separate code fragments spread over the application's code.</span></div>
<div style="position:absolute;left:72.00px;top:715.56px" class="cls_006"><span class="cls_006">Take a shared queue, for example. The number of elements in the queue is manipulated by both</span></div>
<div style="position:absolute;left:72.00px;top:728.16px" class="cls_020"><span class="cls_020">enqueue()</span><span class="cls_006"> and </span><span class="cls_020">dequeue()</span><span class="cls_006"> routines. Modifying the number of elements should not be done</span></div>
<div style="position:absolute;left:72.00px;top:740.40px" class="cls_006"><span class="cls_006">simultaneously by multiple threads for obvious reasons.</span></div>
<div style="position:absolute;left:294.60px;top:791.64px" class="cls_003"><span class="cls_003">9</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:19596px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background024.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">Type& dequeue()</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">get_the_lock(queueLock);</span></div>
<div style="position:absolute;left:96.00px;top:115.92px" class="cls_020"><span class="cls_020">numberOfElements--;</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">release_the_lock(queueLock);</span></div>
<div style="position:absolute;left:72.00px;top:161.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:183.84px" class="cls_020"><span class="cls_020">void enqueue(const Type& value)</span></div>
<div style="position:absolute;left:72.00px;top:195.12px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:217.80px" class="cls_020"><span class="cls_020">get_the_lock(queueLock);</span></div>
<div style="position:absolute;left:96.00px;top:251.76px" class="cls_020"><span class="cls_020">numberOfElements++;</span></div>
<div style="position:absolute;left:96.00px;top:274.44px" class="cls_020"><span class="cls_020">release_the_lock(queueLock);</span></div>
<div style="position:absolute;left:72.00px;top:285.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:312.00px" class="cls_006"><span class="cls_006">If both </span><span class="cls_020">enqueue()</span><span class="cls_006"> and </span><span class="cls_020">dequeue()</span><span class="cls_006"> could modify </span><span class="cls_020">numberOfElements</span><span class="cls_006"> concurrently, we easily could</span></div>
<div style="position:absolute;left:72.00px;top:324.72px" class="cls_006"><span class="cls_006">end up with </span><span class="cls_020">numberOfElements</span><span class="cls_006"> containing a wrong value. Modifying this variable must be done</span></div>
<div style="position:absolute;left:72.00px;top:337.08px" class="cls_006"><span class="cls_006">atomically.</span></div>
<div style="position:absolute;left:72.00px;top:363.12px" class="cls_006"><span class="cls_006">The simplest application of a mutex lock appears in the form of a critical section. A </span><span class="cls_007">critical section</span><span class="cls_006"> is a</span></div>
<div style="position:absolute;left:72.00px;top:375.24px" class="cls_006"><span class="cls_006">single fragment of code that should be executed only by one thread at a time. To achieve mutual exclusion,</span></div>
<div style="position:absolute;left:72.00px;top:387.36px" class="cls_006"><span class="cls_006">the threads must contend for the lock prior to entering the critical section. The thread that succeeds in</span></div>
<div style="position:absolute;left:72.00px;top:398.52px" class="cls_006"><span class="cls_006">getting the lock enters the critical section. Upon exiting the critical section,</span><span class="cls_037"><sup>[2]</sup></span><span class="cls_006"> the thread releases the lock to</span></div>
<div style="position:absolute;left:72.00px;top:412.08px" class="cls_006"><span class="cls_006">allow other threads to enter.</span></div>
<div style="position:absolute;left:90.00px;top:437.40px" class="cls_026"><span class="cls_026"><sup>[2]</sup></span><span class="cls_027"> We must point out that the Win32 definition of critical section is slightly different than ours. In Win32, a</span></div>
<div style="position:absolute;left:90.00px;top:451.20px" class="cls_027"><span class="cls_027">critical section consists of one or more distinct code fragments of which one, and only one, can execute at</span></div>
<div style="position:absolute;left:90.00px;top:461.64px" class="cls_027"><span class="cls_027">any one time. The difference between a critical section and a mutex in Win32 is that a critical section is</span></div>
<div style="position:absolute;left:90.00px;top:471.96px" class="cls_027"><span class="cls_027">confined to a single process, whereas mutex locks can span process boundaries and synchronize threads</span></div>
<div style="position:absolute;left:90.00px;top:482.28px" class="cls_027"><span class="cls_027">running in separate processes. The inconsistency between our use of the terminology and that of Win32 will</span></div>
<div style="position:absolute;left:90.00px;top:492.48px" class="cls_027"><span class="cls_027">not affect our C++ discussion. We are just pointing it out to avoid confusion.</span></div>
<div style="position:absolute;left:72.00px;top:516.12px" class="cls_020"><span class="cls_020">get_the_lock(CSLock);</span></div>
<div style="position:absolute;left:72.00px;top:527.52px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:101.99px;top:527.52px" class="cls_020"><span class="cls_020">// Critical section begins</span></div>
<div style="position:absolute;left:96.00px;top:538.80px" class="cls_020"><span class="cls_020">... // Protected computation</span></div>
<div style="position:absolute;left:72.00px;top:550.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:101.99px;top:550.08px" class="cls_020"><span class="cls_020">// Critical section ends</span></div>
<div style="position:absolute;left:72.00px;top:561.48px" class="cls_020"><span class="cls_020">release_the_lock(CSLock);</span></div>
<div style="position:absolute;left:72.00px;top:587.64px" class="cls_006"><span class="cls_006">In the </span><span class="cls_020">dequeue()</span><span class="cls_006"> example it is pretty easy to inspect the code and verify that every lock operation is</span></div>
<div style="position:absolute;left:72.00px;top:600.00px" class="cls_006"><span class="cls_006">matched with a corresponding unlock. In practice we have seen routines that consisted of hundreds of lines</span></div>
<div style="position:absolute;left:72.00px;top:612.00px" class="cls_006"><span class="cls_006">of code containing multiple return statements. If a lock was obtained somewhere along the way, we had to</span></div>
<div style="position:absolute;left:72.00px;top:624.12px" class="cls_006"><span class="cls_006">release the lock prior to executing any one of the return statements. As you can imagine, this was a</span></div>
<div style="position:absolute;left:72.00px;top:636.12px" class="cls_006"><span class="cls_006">maintenance nightmare and a sure bug waiting to surface. Large-scale projects may have scores of people</span></div>
<div style="position:absolute;left:72.00px;top:648.24px" class="cls_006"><span class="cls_006">writing code and fixing bugs. If you add a return statement to a 100-line routine, you may overlook the fact</span></div>
<div style="position:absolute;left:72.00px;top:660.36px" class="cls_006"><span class="cls_006">that a lock was obtained earlier. That's problem number one. The second one is exceptions: If an exception</span></div>
<div style="position:absolute;left:72.00px;top:672.36px" class="cls_006"><span class="cls_006">is thrown while a lock is held, you'll have to catch the exception and manually release the lock. Not very</span></div>
<div style="position:absolute;left:72.00px;top:684.48px" class="cls_006"><span class="cls_006">elegant.</span></div>
<div style="position:absolute;left:72.00px;top:710.52px" class="cls_006"><span class="cls_006">C++ provides an elegant solution to those two difficulties. When an object reaches the end of the scope for</span></div>
<div style="position:absolute;left:72.00px;top:722.64px" class="cls_006"><span class="cls_006">which it was defined, its destructor is called automatically. You can utilize the automatic destruction to</span></div>
<div style="position:absolute;left:72.00px;top:734.64px" class="cls_006"><span class="cls_006">solve the lock maintenance problem. Encapsulate the lock in an object and let the constructor obtain the</span></div>
<div style="position:absolute;left:72.00px;top:746.76px" class="cls_006"><span class="cls_006">lock. The destructor will release the lock automatically. If such an object is defined in the function scope</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">10</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:20448px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background025.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">of a 100-line routine, you no longer have to worry about multiple return statements. The compiler inserts a</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">call to the lock destructor prior to each return statement and the lock is always released.</span></div>
<div style="position:absolute;left:72.00px;top:109.08px" class="cls_006"><span class="cls_006">Using the constructor-destructor pair to acquire and release a shared resource [</span><span class="cls_036">ES90</span><span class="cls_006">, </span><span class="cls_036">Lip96C</span><span class="cls_006">] leads to lock</span></div>
<div style="position:absolute;left:72.00px;top:121.20px" class="cls_006"><span class="cls_006">class implementations such as the following:</span></div>
<div style="position:absolute;left:72.00px;top:146.88px" class="cls_020"><span class="cls_020">class Lock {</span></div>
<div style="position:absolute;left:72.00px;top:158.16px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:169.56px" class="cls_020"><span class="cls_020">Lock(pthread_mutex_t& key)</span></div>
<div style="position:absolute;left:96.00px;top:180.84px" class="cls_020"><span class="cls_020">: theKey(key) { pthread_mutex_lock(&theKey);</span></div>
<div style="position:absolute;left:96.00px;top:192.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:214.80px" class="cls_020"><span class="cls_020">~Lock() { pthread_mutex_unlock(&theKey); }</span></div>
<div style="position:absolute;left:72.00px;top:226.20px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:237.48px" class="cls_020"><span class="cls_020">pthread_mutex_t &theKey;</span></div>
<div style="position:absolute;left:72.00px;top:248.76px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:274.56px" class="cls_006"><span class="cls_006">A programming environment typically provides multiple flavors of synchronization constructs. The flavors</span></div>
<div style="position:absolute;left:72.00px;top:286.56px" class="cls_006"><span class="cls_006">you may encounter will vary according to</span></div>
<div style="position:absolute;left:90.00px;top:312.84px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Concurrency level</span><span class="cls_006"> A semaphore allows multiple threads to share a resource up to a given</span></div>
<div style="position:absolute;left:108.00px;top:324.96px" class="cls_006"><span class="cls_006">maximum. A mutex allows only one thread to access a shared resource.</span></div>
<div style="position:absolute;left:90.00px;top:337.32px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Nesting</span><span class="cls_006"> Some constructs allow a thread to acquire a lock when the thread already holds the lock.</span></div>
<div style="position:absolute;left:108.00px;top:349.32px" class="cls_006"><span class="cls_006">Other constructs will deadlock on this lock-nesting.</span></div>
<div style="position:absolute;left:90.00px;top:361.68px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Notify</span><span class="cls_006"> When the resource becomes available, some synchronization constructs will notify all</span></div>
<div style="position:absolute;left:108.00px;top:373.80px" class="cls_006"><span class="cls_006">waiting threads. This is very inefficient as all but one thread wake up to find out that they were not</span></div>
<div style="position:absolute;left:108.00px;top:385.80px" class="cls_006"><span class="cls_006">fast enough and the resource has already been acquired. A more efficient notification scheme will</span></div>
<div style="position:absolute;left:108.00px;top:397.92px" class="cls_006"><span class="cls_006">wake up only a single waiting thread.</span></div>
<div style="position:absolute;left:90.00px;top:410.28px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Reader/Writer locks</span><span class="cls_006"> Allow many threads to read a protected value but allow only one to modify</span></div>
<div style="position:absolute;left:108.00px;top:422.28px" class="cls_006"><span class="cls_006">it.</span></div>
<div style="position:absolute;left:90.00px;top:434.64px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Kernel/User space</span><span class="cls_006"> Some synchronization mechanisms are available only in kernel space.</span></div>
<div style="position:absolute;left:90.00px;top:447.00px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Inter/Intra process</span><span class="cls_006"> Typically, synchronization is more efficient among threads of the same</span></div>
<div style="position:absolute;left:108.00px;top:459.00px" class="cls_006"><span class="cls_006">process than threads of distinct processes.</span></div>
<div style="position:absolute;left:72.00px;top:485.16px" class="cls_006"><span class="cls_006">Although these synchronization constructs differ significantly in semantics and performance, they all share</span></div>
<div style="position:absolute;left:72.00px;top:497.16px" class="cls_006"><span class="cls_006">the same lock/unlock protocol. It is very tempting, therefore, to translate this similarity into an inheritance-</span></div>
<div style="position:absolute;left:72.00px;top:509.28px" class="cls_006"><span class="cls_006">based hierarchy of lock classes that are rooted in a unifying base class. In one product we worked on,</span></div>
<div style="position:absolute;left:72.00px;top:521.28px" class="cls_006"><span class="cls_006">initially we found an implementation that looked roughly like this:</span></div>
<div style="position:absolute;left:72.00px;top:547.08px" class="cls_020"><span class="cls_020">class BaseLock {</span></div>
<div style="position:absolute;left:72.00px;top:558.36px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:569.76px" class="cls_020"><span class="cls_020">// (The LogSource object will be explained shortly)</span></div>
<div style="position:absolute;left:96.00px;top:581.04px" class="cls_020"><span class="cls_020">BaseLock(pthread_mutex_t &key, LogSource &lsrc) {};</span></div>
<div style="position:absolute;left:96.00px;top:592.32px" class="cls_020"><span class="cls_020">virtual ~BaseLock() {};</span></div>
<div style="position:absolute;left:72.00px;top:603.72px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:629.88px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">BaseLock</span><span class="cls_006"> class, as you can tell, doesn't do much. Its constructor and destructor are empty. The</span></div>
<div style="position:absolute;left:72.00px;top:642.72px" class="cls_020"><span class="cls_020">BaseLock</span><span class="cls_006"> class was intended as a root class for the various lock classes that were expected to be derived</span></div>
<div style="position:absolute;left:72.00px;top:655.44px" class="cls_006"><span class="cls_006">from it. These distinct flavors would naturally be implemented as distinct subclasses of </span><span class="cls_020">BaseLock</span><span class="cls_006">. One</span></div>
<div style="position:absolute;left:72.00px;top:668.28px" class="cls_006"><span class="cls_006">derivation was the </span><span class="cls_020">MutexLock</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:694.20px" class="cls_020"><span class="cls_020">class MutexLock : public BaseLock {</span></div>
<div style="position:absolute;left:72.00px;top:705.60px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:716.88px" class="cls_020"><span class="cls_020">MutexLock (pthread_mutex_t &key, LogSource &lsrc);</span></div>
<div style="position:absolute;left:96.00px;top:728.28px" class="cls_020"><span class="cls_020">~MutexLock();</span></div>
<div style="position:absolute;left:72.00px;top:739.56px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:750.84px" class="cls_020"><span class="cls_020">pthread_mutex_t &theKey;</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">11</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:21300px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background026.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">LogSource &src;</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:108.12px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">MutexLock</span><span class="cls_006"> constructor and destructor are implemented as follows:</span></div>
<div style="position:absolute;left:72.00px;top:134.04px" class="cls_020"><span class="cls_020">MutexLock::MutexLock(pthread_mutex_t& aKey, const LogSource& source)</span></div>
<div style="position:absolute;left:96.00px;top:145.32px" class="cls_020"><span class="cls_020">: BaseLock(aKey, source),</span></div>
<div style="position:absolute;left:107.99px;top:156.72px" class="cls_020"><span class="cls_020">theKey(aKey),</span></div>
<div style="position:absolute;left:107.99px;top:168.00px" class="cls_020"><span class="cls_020">src(source)</span></div>
<div style="position:absolute;left:72.00px;top:179.28px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:190.68px" class="cls_020"><span class="cls_020">pthread_mutex_lock(&theKey);</span></div>
<div style="position:absolute;left:72.00px;top:201.96px" class="cls_020"><span class="cls_020">#if defined(DEBUG)</span></div>
<div style="position:absolute;left:96.00px;top:213.36px" class="cls_020"><span class="cls_020">cout &lt;&lt; "MutexLock " &lt;&lt; &aKey &lt;&lt; " created at " &lt;&lt; src.file() &lt;&lt;</span></div>
<div style="position:absolute;left:96.00px;top:224.64px" class="cls_020"><span class="cls_020">"line" &lt;&lt;src.line() &lt;&lt; endl;</span></div>
<div style="position:absolute;left:72.00px;top:235.92px" class="cls_020"><span class="cls_020">#endif</span></div>
<div style="position:absolute;left:72.00px;top:247.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:270.00px" class="cls_020"><span class="cls_020">MutexLock::~MutexLock() // Destructor</span></div>
<div style="position:absolute;left:72.00px;top:281.28px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:292.56px" class="cls_020"><span class="cls_020">pthread_mutex_unlock(&theKey);</span></div>
<div style="position:absolute;left:72.00px;top:315.24px" class="cls_020"><span class="cls_020">#if defined(DEBUG)</span></div>
<div style="position:absolute;left:96.00px;top:326.64px" class="cls_020"><span class="cls_020">cout &lt;&lt; "MutexLock " &lt;&lt; &aKey &lt;&lt; " destroyed at " &lt;&lt; src.file()&lt;&lt;</span></div>
<div style="position:absolute;left:96.00px;top:337.92px" class="cls_020"><span class="cls_020">"line" &lt;&lt; src.line() &lt;&lt; endl;</span></div>
<div style="position:absolute;left:72.00px;top:349.20px" class="cls_020"><span class="cls_020">#endif</span></div>
<div style="position:absolute;left:72.00px;top:360.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:386.76px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">MutexLock</span><span class="cls_006"> implementation makes use of a </span><span class="cls_020">LogSource</span><span class="cls_006"> object that has not been discussed yet. The</span></div>
<div style="position:absolute;left:72.00px;top:399.60px" class="cls_020"><span class="cls_020">LogSource</span><span class="cls_006"> object is meant to capture the filename and source code line number where the object was</span></div>
<div style="position:absolute;left:72.00px;top:411.84px" class="cls_006"><span class="cls_006">constructed. When logging errors and trace information it is often necessary to specify the location of the</span></div>
<div style="position:absolute;left:72.00px;top:424.44px" class="cls_006"><span class="cls_006">information source. A C programmer would use a </span><span class="cls_020">(char *)</span><span class="cls_006"> for the filename and an </span><span class="cls_020">int</span><span class="cls_006"> for the line</span></div>
<div style="position:absolute;left:72.00px;top:437.28px" class="cls_006"><span class="cls_006">number. Our developers chose to encapsulate both in a </span><span class="cls_020">LogSource</span><span class="cls_006"> object. Again, we had a do-nothing</span></div>
<div style="position:absolute;left:72.00px;top:449.52px" class="cls_006"><span class="cls_006">base class followed by a more useful derived class:</span></div>
<div style="position:absolute;left:72.00px;top:475.32px" class="cls_020"><span class="cls_020">class BaseLogSource {</span></div>
<div style="position:absolute;left:72.00px;top:486.60px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:497.88px" class="cls_020"><span class="cls_020">BaseLogSource() {}</span></div>
<div style="position:absolute;left:96.00px;top:509.28px" class="cls_020"><span class="cls_020">virtual ~BaseLogSource() {}</span></div>
<div style="position:absolute;left:72.00px;top:520.56px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:543.24px" class="cls_020"><span class="cls_020">class LogSource : public BaseLogSource {</span></div>
<div style="position:absolute;left:72.00px;top:554.64px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:565.92px" class="cls_020"><span class="cls_020">LogSource(const char *name, int num) : filename(name),</span></div>
<div style="position:absolute;left:101.99px;top:577.20px" class="cls_020"><span class="cls_020">lineNum(num) {}</span></div>
<div style="position:absolute;left:96.00px;top:588.60px" class="cls_020"><span class="cls_020">~LogSource() {}</span></div>
<div style="position:absolute;left:96.00px;top:611.28px" class="cls_020"><span class="cls_020">char *file();</span></div>
<div style="position:absolute;left:96.00px;top:622.56px" class="cls_020"><span class="cls_020">int line();</span></div>
<div style="position:absolute;left:72.00px;top:633.84px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:645.24px" class="cls_020"><span class="cls_020">char *filename;</span></div>
<div style="position:absolute;left:96.00px;top:656.52px" class="cls_020"><span class="cls_020">int  lineNum;</span></div>
<div style="position:absolute;left:72.00px;top:667.92px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:694.08px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">LogSource</span><span class="cls_006"> object was created and passed as an argument to the </span><span class="cls_020">MutexLock</span><span class="cls_006"> object constructor. The</span></div>
<div style="position:absolute;left:72.00px;top:706.80px" class="cls_020"><span class="cls_020">LogSource</span><span class="cls_006"> object captured the source file and line number at which the lock was fetched. This</span></div>
<div style="position:absolute;left:72.00px;top:719.16px" class="cls_006"><span class="cls_006">information may come in handy when debugging deadlocks.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">12</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:22152px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background027.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">Imagine that </span><span class="cls_020">sharedCounter</span><span class="cls_006"> was an integer variable accessible to multiple threads and needing</span></div>
<div style="position:absolute;left:72.00px;top:83.76px" class="cls_006"><span class="cls_006">serialization. We provided mutual exclusion by inserting a lock object into the local scope:</span></div>
<div style="position:absolute;left:72.00px;top:109.44px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:120.72px" class="cls_020"><span class="cls_020">MutexLock myLock(theKey, LogSource(__FILE__, __LINE__));</span></div>
<div style="position:absolute;left:96.00px;top:132.12px" class="cls_020"><span class="cls_020">sharedCounter++;</span></div>
<div style="position:absolute;left:72.00px;top:143.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:169.68px" class="cls_006"><span class="cls_006">The creation of the </span><span class="cls_020">MutexLock</span><span class="cls_006"> and </span><span class="cls_020">LogSource</span><span class="cls_006"> objects triggered the invocations of their respective base</span></div>
<div style="position:absolute;left:72.00px;top:181.92px" class="cls_006"><span class="cls_006">classes as well. This short fragment invoked a number of constructors:</span></div>
<div style="position:absolute;left:90.00px;top:208.68px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  BaseLogSource</span></div>
<div style="position:absolute;left:90.00px;top:221.76px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  LogSource</span></div>
<div style="position:absolute;left:90.00px;top:234.84px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  BaseLock</span></div>
<div style="position:absolute;left:90.00px;top:247.92px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  MutexLock</span></div>
<div style="position:absolute;left:72.00px;top:274.68px" class="cls_006"><span class="cls_006">After the </span><span class="cls_020">sharedCounter</span><span class="cls_006"> variable was incremented, we encountered the end of the scope that triggers</span></div>
<div style="position:absolute;left:72.00px;top:287.04px" class="cls_006"><span class="cls_006">the four corresponding destructors:</span></div>
<div style="position:absolute;left:90.00px;top:313.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  MutexLock</span></div>
<div style="position:absolute;left:90.00px;top:326.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  BaseLock</span></div>
<div style="position:absolute;left:90.00px;top:339.96px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  LogSource</span></div>
<div style="position:absolute;left:90.00px;top:353.04px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  BaseLogSource</span></div>
<div style="position:absolute;left:72.00px;top:379.32px" class="cls_006"><span class="cls_006">All told, the protection of the shared resource had cost us eight constructors and destructors. The tension</span></div>
<div style="position:absolute;left:72.00px;top:391.44px" class="cls_006"><span class="cls_006">between reuse and performance is a topic that keeps popping up. It would be interesting to find out what</span></div>
<div style="position:absolute;left:72.00px;top:403.44px" class="cls_006"><span class="cls_006">the cost would be if we abandoned all these objects and developed a hand-crafted version that would</span></div>
<div style="position:absolute;left:72.00px;top:415.56px" class="cls_006"><span class="cls_006">narrow down by doing exactly what we need and nothing else. Namely, it will just lock around the</span></div>
<div style="position:absolute;left:72.00px;top:428.16px" class="cls_020"><span class="cls_020">sharedCounter</span><span class="cls_006"> update:</span></div>
<div style="position:absolute;left:72.00px;top:454.08px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:465.36px" class="cls_020"><span class="cls_020">pthread_mutex_lock(&theKey);</span></div>
<div style="position:absolute;left:96.00px;top:476.76px" class="cls_020"><span class="cls_020">sharedCounter++;</span></div>
<div style="position:absolute;left:96.00px;top:488.04px" class="cls_020"><span class="cls_020">pthread_mutex_unlock(&theKey);</span></div>
<div style="position:absolute;left:72.00px;top:499.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:525.12px" class="cls_006"><span class="cls_006">By inspection alone, you can tell that the latter version is more efficient than the former one. Our object-</span></div>
<div style="position:absolute;left:72.00px;top:537.12px" class="cls_006"><span class="cls_006">based design had cost us additional instructions. Those instructions were entirely dedicated to construction</span></div>
<div style="position:absolute;left:72.00px;top:549.24px" class="cls_006"><span class="cls_006">and destruction of objects. Should we worry about those instructions? That depends on the context; if we</span></div>
<div style="position:absolute;left:72.00px;top:561.24px" class="cls_006"><span class="cls_006">are in a performance critical flow, we might. In particular, additional instructions become significant if the</span></div>
<div style="position:absolute;left:72.00px;top:573.36px" class="cls_006"><span class="cls_006">total cost of the computation is small and the fragment that executes those instructions is called often</span></div>
<div style="position:absolute;left:72.00px;top:585.48px" class="cls_006"><span class="cls_006">enough. It is the ratio of instructions wasted divided by the total instruction count of the overall</span></div>
<div style="position:absolute;left:72.00px;top:597.48px" class="cls_006"><span class="cls_006">computation that we care about. The code sample we just described was taken out of a gateway</span></div>
<div style="position:absolute;left:72.00px;top:609.60px" class="cls_006"><span class="cls_006">implementation that routed data packets from one communication adapter to another. It was a critical path</span></div>
<div style="position:absolute;left:72.00px;top:622.08px" class="cls_006"><span class="cls_006">that consisted of roughly 5,000 instructions. The </span><span class="cls_020">MutexLock</span><span class="cls_006"> object was used a few times on that path.</span></div>
<div style="position:absolute;left:72.00px;top:634.44px" class="cls_006"><span class="cls_006">That amounted to enough instruction-overhead to make up 10% of the overall cost, which was significant.</span></div>
<div style="position:absolute;left:72.00px;top:660.48px" class="cls_006"><span class="cls_006">If we are going to use C++ and OO in a performance-critical application, we cannot afford such luxury.</span></div>
<div style="position:absolute;left:72.00px;top:672.60px" class="cls_006"><span class="cls_006">Before we present a C++ based fix, we would quickly like to point out an obvious design overkill. If the</span></div>
<div style="position:absolute;left:72.00px;top:684.72px" class="cls_006"><span class="cls_006">critical section is as simple as a one-statement integer increment, why do we need all this object machinery?</span></div>
<div style="position:absolute;left:72.00px;top:696.72px" class="cls_006"><span class="cls_006">The advantages to using lock objects are</span></div>
<div style="position:absolute;left:90.00px;top:723.12px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Maintenance of complex routines containing multiple return points.</span></div>
<div style="position:absolute;left:90.00px;top:735.36px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Recovery from exceptions.</span></div>
<div style="position:absolute;left:90.00px;top:747.72px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Polymorphism in locking.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">13</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:23004px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background028.jpg" width=595 height=842></div>
<div style="position:absolute;left:90.00px;top:71.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Polymorphism in logging.</span></div>
<div style="position:absolute;left:72.00px;top:97.20px" class="cls_006"><span class="cls_006">All those advantages were not extremely important in our case. The critical section had a clearly defined</span></div>
<div style="position:absolute;left:72.00px;top:109.32px" class="cls_006"><span class="cls_006">single exit point and the integer increment operation was not going to throw an exception. The</span></div>
<div style="position:absolute;left:72.00px;top:121.44px" class="cls_006"><span class="cls_006">polymorphism in locking and logging was also something we could easily live without. Interestingly, as</span></div>
<div style="position:absolute;left:72.00px;top:133.44px" class="cls_006"><span class="cls_006">this code segment reveals, developers are actually doing this in practice, which indicates that the cost of</span></div>
<div style="position:absolute;left:72.00px;top:145.56px" class="cls_006"><span class="cls_006">object construction and destruction is seriously overlooked.</span></div>
<div style="position:absolute;left:72.00px;top:171.60px" class="cls_006"><span class="cls_006">So what about a complex routine where the use of the lock object actually makes sense? We would still</span></div>
<div style="position:absolute;left:72.00px;top:184.20px" class="cls_006"><span class="cls_006">like to reduce its cost. First let's consider the </span><span class="cls_020">LogSource</span><span class="cls_006"> object. That piece of information had cost us</span></div>
<div style="position:absolute;left:72.00px;top:196.44px" class="cls_006"><span class="cls_006">four function calls: base and derived class constructors and destructors. This is a luxury we cannot afford</span></div>
<div style="position:absolute;left:72.00px;top:208.56px" class="cls_006"><span class="cls_006">in this context. Often, when C++ performance is discussed, inlining is offered as a cure. Although inlining</span></div>
<div style="position:absolute;left:72.00px;top:220.68px" class="cls_006"><span class="cls_006">could help here, it does not eliminate the problem. In the best-case scenario, inlining will eliminate the</span></div>
<div style="position:absolute;left:72.00px;top:233.16px" class="cls_006"><span class="cls_006">function call overhead for all four constructors and destructors. Even then, the </span><span class="cls_020">LogSource</span><span class="cls_006"> object still</span></div>
<div style="position:absolute;left:72.00px;top:246.00px" class="cls_006"><span class="cls_006">imposes some performance overhead. First, it is an extra argument to the </span><span class="cls_020">MutexLock</span><span class="cls_006"> constructor. Second,</span></div>
<div style="position:absolute;left:72.00px;top:258.84px" class="cls_006"><span class="cls_006">there is the assignment of the </span><span class="cls_020">LogSource</span><span class="cls_006"> pointer member of </span><span class="cls_020">MutexLock</span><span class="cls_006">. Furthermore, when the</span></div>
<div style="position:absolute;left:72.00px;top:271.56px" class="cls_020"><span class="cls_020">LogSource</span><span class="cls_006"> object is created, some additional instructions are required to set up its virtual table pointer.</span></div>
<div style="position:absolute;left:72.00px;top:297.96px" class="cls_006"><span class="cls_006">In a critical performance path, a common sense trade-off is called for. You trade away marginal</span></div>
<div style="position:absolute;left:72.00px;top:310.44px" class="cls_006"><span class="cls_006">functionality for valuable performance. The </span><span class="cls_020">LogSource</span><span class="cls_006"> object has to go. In a constructor, the assignment</span></div>
<div style="position:absolute;left:72.00px;top:322.80px" class="cls_006"><span class="cls_006">of a member data field costs a small number of instructions even in the case of a built-in type. The cost per</span></div>
<div style="position:absolute;left:72.00px;top:334.92px" class="cls_006"><span class="cls_006">member data field may not be much but it adds up. It grows with the number of data members that are</span></div>
<div style="position:absolute;left:72.00px;top:346.92px" class="cls_006"><span class="cls_006">initialized by the constructor.</span></div>
<div style="position:absolute;left:72.00px;top:373.56px" class="cls_006"><span class="cls_006">The fact that the code using the </span><span class="cls_020">LogSource</span><span class="cls_006"> object was enclosed in an </span><span class="cls_020">#ifdef</span><span class="cls_006"> </span><span class="cls_020">DEBUG</span><span class="cls_006"> bracket provides</span></div>
<div style="position:absolute;left:72.00px;top:386.28px" class="cls_006"><span class="cls_006">further evidence that using this object was not essential. The </span><span class="cls_020">DEBUG</span><span class="cls_006"> compile flag was used only during</span></div>
<div style="position:absolute;left:72.00px;top:399.12px" class="cls_006"><span class="cls_006">development test; the code that was shipped to customers was compiled with </span><span class="cls_020">DEBUG</span><span class="cls_006"> turned off. When</span></div>
<div style="position:absolute;left:72.00px;top:411.96px" class="cls_006"><span class="cls_006">executing in a production environment, we paid the price imposed by the </span><span class="cls_020">LogSource</span><span class="cls_006"> object, but never</span></div>
<div style="position:absolute;left:72.00px;top:424.80px" class="cls_006"><span class="cls_006">actually used it. This was pure overhead. The </span><span class="cls_020">LogSource</span><span class="cls_006"> should have been completely eliminated by</span></div>
<div style="position:absolute;left:72.00px;top:437.52px" class="cls_006"><span class="cls_006">careful </span><span class="cls_020">#ifdef</span><span class="cls_006"> of all remnants of it. That would include elimination of the pointer member of</span></div>
<div style="position:absolute;left:72.00px;top:450.36px" class="cls_020"><span class="cls_020">MutexLock</span><span class="cls_006"> as well as the constructor argument. The partial </span><span class="cls_020">#ifdef</span><span class="cls_006"> of the </span><span class="cls_020">LogSource</span><span class="cls_006"> object was an</span></div>
<div style="position:absolute;left:72.00px;top:462.72px" class="cls_006"><span class="cls_006">example of sloppy development. This is not terribly unusual; it is just that your chances of getting away</span></div>
<div style="position:absolute;left:72.00px;top:474.72px" class="cls_006"><span class="cls_006">with sloppy programming in C++ are slim.</span></div>
<div style="position:absolute;left:72.00px;top:501.36px" class="cls_006"><span class="cls_006">The next step is to eliminate the </span><span class="cls_020">BaseLock</span><span class="cls_006"> root of the lock class hierarchy. In the case of </span><span class="cls_020">BaseLock</span><span class="cls_006">, it</span></div>
<div style="position:absolute;left:72.00px;top:513.60px" class="cls_006"><span class="cls_006">doesn't contribute any data members and, with the exception of the constructor signature, does not provide</span></div>
<div style="position:absolute;left:72.00px;top:526.20px" class="cls_006"><span class="cls_006">any meaningful interface. The contribution of </span><span class="cls_020">BaseLock</span><span class="cls_006"> to the overall class design is debatable. Even if</span></div>
<div style="position:absolute;left:72.00px;top:539.04px" class="cls_006"><span class="cls_006">inlining takes care of the call overhead, the virtual destructor of </span><span class="cls_020">BaseLock</span><span class="cls_006"> imposes the cost of setting the</span></div>
<div style="position:absolute;left:72.00px;top:551.76px" class="cls_006"><span class="cls_006">virtual table pointer in the </span><span class="cls_020">MutexLock</span><span class="cls_006"> object. Saving a single assignment may not be much, but every</span></div>
<div style="position:absolute;left:72.00px;top:564.60px" class="cls_006"><span class="cls_006">little bit helps. Inlining the remaining </span><span class="cls_020">MutexLock</span><span class="cls_006"> constructor and destructor will eliminate the remaining</span></div>
<div style="position:absolute;left:72.00px;top:576.96px" class="cls_006"><span class="cls_006">two function calls.</span></div>
<div style="position:absolute;left:72.00px;top:603.48px" class="cls_006"><span class="cls_006">The combination of eliminating the </span><span class="cls_020">LogSource</span><span class="cls_006"> class, the </span><span class="cls_020">BaseLock</span><span class="cls_006"> class, and inlining </span><span class="cls_020">MutexLock</span></div>
<div style="position:absolute;left:72.00px;top:615.84px" class="cls_006"><span class="cls_006">constructor and destructor will significantly cut down the instruction count. It will generate code that is</span></div>
<div style="position:absolute;left:72.00px;top:628.32px" class="cls_006"><span class="cls_006">almost as efficient as hand-coded C. The compiler-generated code with the inlined </span><span class="cls_020">MutexLock</span><span class="cls_006"> will be</span></div>
<div style="position:absolute;left:72.00px;top:640.68px" class="cls_006"><span class="cls_006">equivalent to something like the following pseudocode:</span></div>
<div style="position:absolute;left:72.00px;top:666.36px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:677.76px" class="cls_020"><span class="cls_020">MutexLock::theKey = key;</span></div>
<div style="position:absolute;left:96.00px;top:700.44px" class="cls_020"><span class="cls_020">pthread_mutex_lock(&MutexLock::theKey);</span></div>
<div style="position:absolute;left:96.00px;top:711.72px" class="cls_020"><span class="cls_020">sharedCounter++;</span></div>
<div style="position:absolute;left:96.00px;top:723.00px" class="cls_020"><span class="cls_020">pthread_mutex_unlock(&MutexLock::theKey);</span></div>
<div style="position:absolute;left:72.00px;top:734.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">14</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:23856px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background029.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">The above C++ code fragment is almost identical to hand-coded C, and we assumed it would be just as</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">efficient. If that is the case, then the object lock provides the added power of C++ without loss of</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">efficiency. To validate our assumption, we tested three implementations of mutex locks:</span></div>
<div style="position:absolute;left:90.00px;top:121.92px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Direct calls to </span><span class="cls_020">pthread_mutex_lock()</span><span class="cls_006"> and </span><span class="cls_020">pthread_mutex_unlock()</span></div>
<div style="position:absolute;left:90.00px;top:134.40px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A standalone mutex object that does not inherit from a base class</span></div>
<div style="position:absolute;left:90.00px;top:146.76px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A mutex object derived from a base class</span></div>
<div style="position:absolute;left:72.00px;top:173.28px" class="cls_006"><span class="cls_006">In the first test we simply surrounded the shared resource with a pair of </span><span class="cls_020">pthread_mutex_lock()</span><span class="cls_006"> and</span></div>
<div style="position:absolute;left:72.00px;top:186.12px" class="cls_020"><span class="cls_020">pthread_mutex_unlock()</span><span class="cls_006"> calls:</span></div>
<div style="position:absolute;left:72.00px;top:212.04px" class="cls_020"><span class="cls_020">int main()// Version 1</span></div>
<div style="position:absolute;left:72.00px;top:223.44px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:246.12px" class="cls_020"><span class="cls_020">// Start timing here</span></div>
<div style="position:absolute;left:96.00px;top:257.40px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; 1000000; i++) {</span></div>
<div style="position:absolute;left:119.99px;top:268.80px" class="cls_020"><span class="cls_020">pthread_mutex_lock(&mutex);</span></div>
<div style="position:absolute;left:119.99px;top:280.08px" class="cls_020"><span class="cls_020">sharedCounter++;</span></div>
<div style="position:absolute;left:119.99px;top:291.36px" class="cls_020"><span class="cls_020">pthread_mutex_unlock(&mutex);</span></div>
<div style="position:absolute;left:96.00px;top:302.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:314.04px" class="cls_020"><span class="cls_020">// Stop timing here</span></div>
<div style="position:absolute;left:72.00px;top:336.72px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:362.88px" class="cls_006"><span class="cls_006">In Version 2 we used a lock object, </span><span class="cls_020">SimpleMutex</span><span class="cls_006">, using the constructor to lock and the destructor to</span></div>
<div style="position:absolute;left:72.00px;top:375.24px" class="cls_006"><span class="cls_006">unlock:</span></div>
<div style="position:absolute;left:72.00px;top:400.92px" class="cls_020"><span class="cls_020">int main()</span></div>
<div style="position:absolute;left:155.98px;top:400.92px" class="cls_020"><span class="cls_020">// Version 2</span></div>
<div style="position:absolute;left:72.00px;top:412.20px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:434.88px" class="cls_020"><span class="cls_020">// Start timing here</span></div>
<div style="position:absolute;left:96.00px;top:446.28px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; 1000000; i++) {</span></div>
<div style="position:absolute;left:119.99px;top:457.56px" class="cls_020"><span class="cls_020">SimpleMutex m(mutex);</span></div>
<div style="position:absolute;left:119.99px;top:468.84px" class="cls_020"><span class="cls_020">sharedCounter++;</span></div>
<div style="position:absolute;left:96.00px;top:480.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:491.52px" class="cls_020"><span class="cls_020">// Stop timing here</span></div>
<div style="position:absolute;left:72.00px;top:514.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:540.36px" class="cls_020"><span class="cls_020">SimpleMutex</span><span class="cls_006"> was implemented as follows:</span></div>
<div style="position:absolute;left:72.00px;top:566.28px" class="cls_020"><span class="cls_020">class SimpleMutex</span></div>
<div style="position:absolute;left:191.98px;top:566.28px" class="cls_020"><span class="cls_020">// Version two. Standalone lock class.</span></div>
<div style="position:absolute;left:72.00px;top:577.68px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:588.96px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:600.36px" class="cls_020"><span class="cls_020">SimpleMutex(pthread_mutex_t& lock) : myLock(lock) {acquire();}</span></div>
<div style="position:absolute;left:96.00px;top:622.92px" class="cls_020"><span class="cls_020">~SimpleMutex() {release();}</span></div>
<div style="position:absolute;left:72.00px;top:634.32px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:645.60px" class="cls_020"><span class="cls_020">int acquire() {return pthread_mutex_lock(&myLock);}</span></div>
<div style="position:absolute;left:96.00px;top:657.00px" class="cls_020"><span class="cls_020">int release() {return pthread_mutex_unlock(&myLock);}</span></div>
<div style="position:absolute;left:96.00px;top:679.56px" class="cls_020"><span class="cls_020">pthread_mutex_t& myLock;</span></div>
<div style="position:absolute;left:72.00px;top:690.96px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:716.52px" class="cls_006"><span class="cls_006">Inheritance was added in Version 3:</span></div>
<div style="position:absolute;left:72.00px;top:742.32px" class="cls_020"><span class="cls_020">class BaseMutex</span></div>
<div style="position:absolute;left:185.98px;top:742.32px" class="cls_020"><span class="cls_020">// Version 3. Base class.</span></div>
<div style="position:absolute;left:72.00px;top:753.72px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">15</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:24708px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background030.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">BaseMutex(pthread_mutex_t& lock) {};</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">virtual ~BaseMutex() {};</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:127.20px" class="cls_020"><span class="cls_020">class DerivedMutex: public BaseMutex</span></div>
<div style="position:absolute;left:311.96px;top:127.20px" class="cls_020"><span class="cls_020">// Version 3.</span></div>
<div style="position:absolute;left:72.00px;top:138.48px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:149.88px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:161.16px" class="cls_020"><span class="cls_020">DerivedMutex(pthread_mutex_t& lock)</span></div>
<div style="position:absolute;left:96.00px;top:172.56px" class="cls_020"><span class="cls_020">: BaseMutex(lock), myLock(lock) {acquire();}</span></div>
<div style="position:absolute;left:96.00px;top:183.84px" class="cls_020"><span class="cls_020">~DerivedMutex() {release();}</span></div>
<div style="position:absolute;left:72.00px;top:195.12px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:206.52px" class="cls_020"><span class="cls_020">int acquire() {return pthread_mutex_lock(&myLock);}</span></div>
<div style="position:absolute;left:96.00px;top:217.80px" class="cls_020"><span class="cls_020">int release() {return pthread_mutex_unlock(&myLock);}</span></div>
<div style="position:absolute;left:96.00px;top:240.48px" class="cls_020"><span class="cls_020">pthread_mutex_t& myLock;</span></div>
<div style="position:absolute;left:72.00px;top:251.76px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:278.04px" class="cls_006"><span class="cls_006">In the test loop we replaced </span><span class="cls_020">SimpleMutex</span><span class="cls_006"> with the </span><span class="cls_020">DerivedMutex</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:303.96px" class="cls_020"><span class="cls_020">int main()</span></div>
<div style="position:absolute;left:143.99px;top:303.96px" class="cls_020"><span class="cls_020">// Version 3</span></div>
<div style="position:absolute;left:72.00px;top:315.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:337.92px" class="cls_020"><span class="cls_020">// Start timing here</span></div>
<div style="position:absolute;left:96.00px;top:349.20px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; 1000000; i++) {</span></div>
<div style="position:absolute;left:119.99px;top:360.60px" class="cls_020"><span class="cls_020">DerivedMutex m(mutex);</span></div>
<div style="position:absolute;left:119.99px;top:371.88px" class="cls_020"><span class="cls_020">sharedCounter++;</span></div>
<div style="position:absolute;left:96.00px;top:383.28px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:394.56px" class="cls_020"><span class="cls_020">// Stop timing here</span></div>
<div style="position:absolute;left:72.00px;top:417.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:442.92px" class="cls_006"><span class="cls_006">The timing results of running a million iterations of the test loop validated our assumption. Versions 1 and</span></div>
<div style="position:absolute;left:72.00px;top:455.04px" class="cls_006"><span class="cls_006">2 executed in 1.01 seconds. Version 3, however, took 1.62 seconds. In Version 1 we invoked the mutex</span></div>
<div style="position:absolute;left:72.00px;top:467.04px" class="cls_006"><span class="cls_006">calls directly—you cannot get more efficient than that. The moral of the story is that using a standalone</span></div>
<div style="position:absolute;left:72.00px;top:479.16px" class="cls_006"><span class="cls_006">object did not exact any performance penalty at all. The constructor and destructor were inlined by the</span></div>
<div style="position:absolute;left:72.00px;top:491.16px" class="cls_006"><span class="cls_006">compiler and this implementation achieved maximum efficiency. We paid a significant price, however, for</span></div>
<div style="position:absolute;left:72.00px;top:503.28px" class="cls_006"><span class="cls_006">inheritance. The inheritance-based lock object (Version 3) degraded performance by roughly 60% (</span><span class="cls_036">Figure</span></div>
<div style="position:absolute;left:72.00px;top:515.40px" class="cls_036"><span class="cls_036">2.1</span><span class="cls_006">).</span></div>
<div style="position:absolute;left:171.24px;top:541.56px" class="cls_021"><span class="cls_021">Figure 2.1. The cost of inheritance in this example.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">16</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:25560px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background031.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:298.68px" class="cls_006"><span class="cls_006">More often than not, the creation and destruction of objects will exact a performance penalty. In an</span></div>
<div style="position:absolute;left:72.00px;top:310.80px" class="cls_006"><span class="cls_006">inheritance hierarchy, the creation of an object will trigger the creation of its ancestors. The same goes for</span></div>
<div style="position:absolute;left:72.00px;top:322.80px" class="cls_006"><span class="cls_006">object destruction. It follows that the cost associated with an object is directly related to the length and</span></div>
<div style="position:absolute;left:72.00px;top:334.92px" class="cls_006"><span class="cls_006">complexity of its derivation chain. The number of objects created (and later destroyed) is proportional to</span></div>
<div style="position:absolute;left:72.00px;top:346.92px" class="cls_006"><span class="cls_006">the complexity of the derivation.</span></div>
<div style="position:absolute;left:72.00px;top:373.08px" class="cls_006"><span class="cls_006">This is not to say that inheritance is fundamentally a performance obstacle. We must make a distinction</span></div>
<div style="position:absolute;left:72.00px;top:385.08px" class="cls_006"><span class="cls_006">between the overall computational cost, required cost, and computational penalty. The overall</span></div>
<div style="position:absolute;left:72.00px;top:397.20px" class="cls_006"><span class="cls_006">computational cost is the set of all instructions executed in a computation. The required cost is that subset</span></div>
<div style="position:absolute;left:72.00px;top:409.32px" class="cls_006"><span class="cls_006">of instructions whose results are necessary. This part of the computation is mandatory; computational</span></div>
<div style="position:absolute;left:72.00px;top:421.32px" class="cls_006"><span class="cls_006">penalty is the rest. This is the part of the computation that could have been eliminated by an alternative</span></div>
<div style="position:absolute;left:72.00px;top:433.92px" class="cls_006"><span class="cls_006">design or implementation. To make the point more concrete, let's look at the </span><span class="cls_020">SimpleMutex</span><span class="cls_006"> class as an</span></div>
<div style="position:absolute;left:72.00px;top:446.16px" class="cls_006"><span class="cls_006">example:</span></div>
<div style="position:absolute;left:72.00px;top:471.96px" class="cls_020"><span class="cls_020">class SimpleMutex</span></div>
<div style="position:absolute;left:72.00px;top:483.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:494.64px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:505.92px" class="cls_020"><span class="cls_020">SimpleMutex(pthread_mutex_t& lock) : myLock(lock) {acquire();}</span></div>
<div style="position:absolute;left:96.00px;top:528.60px" class="cls_020"><span class="cls_020">~SimpleMutex() {release();}</span></div>
<div style="position:absolute;left:72.00px;top:539.88px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:551.28px" class="cls_020"><span class="cls_020">int acquire() {return pthread_mutex_lock(&myLock);}</span></div>
<div style="position:absolute;left:96.00px;top:562.56px" class="cls_020"><span class="cls_020">int release() {return pthread_mutex_unlock(&myLock);}</span></div>
<div style="position:absolute;left:96.00px;top:585.24px" class="cls_020"><span class="cls_020">pthread_mutex_t& myLock;</span></div>
<div style="position:absolute;left:72.00px;top:596.52px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:622.80px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">SimpleMutex</span><span class="cls_006"> constructor harbors the following overall computational cost:</span></div>
<div style="position:absolute;left:90.00px;top:649.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Initialize the </span><span class="cls_020">myLock</span><span class="cls_006"> member</span></div>
<div style="position:absolute;left:90.00px;top:662.76px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Call the </span><span class="cls_020">acquire()</span><span class="cls_006"> method</span></div>
<div style="position:absolute;left:90.00px;top:675.84px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Invoke </span><span class="cls_020">pthread_mutex_lock()</span><span class="cls_006"> with the </span><span class="cls_020">acquire()</span><span class="cls_006"> method</span></div>
<div style="position:absolute;left:72.00px;top:702.24px" class="cls_006"><span class="cls_006">The third item is the required cost. Regardless of the design options, one way or another, you would have</span></div>
<div style="position:absolute;left:72.00px;top:714.72px" class="cls_006"><span class="cls_006">to call </span><span class="cls_020">pthread_mutex_lock()</span><span class="cls_006"> in order to lock the resource. The first item, setting the </span><span class="cls_020">myLock</span></div>
<div style="position:absolute;left:72.00px;top:727.08px" class="cls_006"><span class="cls_006">member, is computational penalty. It is our object-based design that forced us to do that. Failing to inline</span></div>
<div style="position:absolute;left:72.00px;top:739.68px" class="cls_006"><span class="cls_006">the </span><span class="cls_020">acquire()</span><span class="cls_006"> call would result in additional penalty. In practice, more than likely compilers will</span></div>
<div style="position:absolute;left:72.00px;top:751.92px" class="cls_006"><span class="cls_006">eliminate that penalty by inlining.</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:26412px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background032.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">So we cannot make a blanket statement that complex inheritance designs are necessarily bad, nor do they</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">always carry a performance penalty. All we can say is that overall cost grows with the size of the</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">derivation tree. If all those computations are valuable then it is all required cost. In practice, inheritance</span></div>
<div style="position:absolute;left:72.00px;top:106.32px" class="cls_006"><span class="cls_006">hierarchies are not likely to be perfect.</span><span class="cls_037"><sup>[3]</sup></span><span class="cls_006"> In that case, they are likely to impose a computational penalty.</span></div>
<div style="position:absolute;left:90.00px;top:133.08px" class="cls_026"><span class="cls_026"><sup>[3]</sup></span><span class="cls_027"> In this context, software perfection means you compute what you need, all of what you need, and nothing</span></div>
<div style="position:absolute;left:90.00px;top:146.76px" class="cls_027"><span class="cls_027">but what you need.</span></div>
<div style="position:absolute;left:72.00px;top:198.48px" class="cls_016"><span class="cls_016">Composition</span></div>
<div style="position:absolute;left:72.00px;top:229.80px" class="cls_006"><span class="cls_006">Like inheritance, object composition raises similar performance concerns with regard to object creation</span></div>
<div style="position:absolute;left:72.00px;top:241.92px" class="cls_006"><span class="cls_006">and destruction. When an object is created (destroyed), all its contained member objects must be created</span></div>
<div style="position:absolute;left:72.00px;top:254.52px" class="cls_006"><span class="cls_006">(destroyed) as well. For instance, the </span><span class="cls_020">Trace</span><span class="cls_006"> object discussed in the previous chapter contains a member</span></div>
<div style="position:absolute;left:72.00px;top:267.24px" class="cls_006"><span class="cls_006">object of class </span><span class="cls_020">string</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:293.28px" class="cls_020"><span class="cls_020">class Trace</span></div>
<div style="position:absolute;left:72.00px;top:304.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:327.24px" class="cls_020"><span class="cls_020">string theFunctionName;</span></div>
<div style="position:absolute;left:72.00px;top:338.52px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:364.80px" class="cls_006"><span class="cls_006">When you construct an object of type </span><span class="cls_020">Trace</span><span class="cls_006">, the constructor invokes the </span><span class="cls_020">string</span><span class="cls_006"> constructor to initialize</span></div>
<div style="position:absolute;left:72.00px;top:377.52px" class="cls_006"><span class="cls_006">the </span><span class="cls_020">string</span><span class="cls_006"> data member. This behavior is recursive: If class </span><span class="cls_020">A</span><span class="cls_006"> contains a member of class </span><span class="cls_020">B</span><span class="cls_006"> and </span><span class="cls_020">B</span></div>
<div style="position:absolute;left:72.00px;top:390.36px" class="cls_006"><span class="cls_006">contains a </span><span class="cls_020">C</span><span class="cls_006">, the constructor for </span><span class="cls_020">A</span><span class="cls_006"> will invoke the construction of a </span><span class="cls_020">B</span><span class="cls_006"> object which, in turn, will trigger that</span></div>
<div style="position:absolute;left:72.00px;top:403.08px" class="cls_006"><span class="cls_006">of a </span><span class="cls_020">C</span><span class="cls_006"> object. Since at each level in the composition (containment) hierarchy there may be multiple</span></div>
<div style="position:absolute;left:72.00px;top:415.44px" class="cls_006"><span class="cls_006">attributes, the composition hierarchy generates a tree, not a simple list. The overall cost of composition is</span></div>
<div style="position:absolute;left:72.00px;top:427.56px" class="cls_006"><span class="cls_006">therefore related to the size of this composition tree, which can become quite large. Again, we must</span></div>
<div style="position:absolute;left:72.00px;top:439.56px" class="cls_006"><span class="cls_006">emphasize that "cost" does not necessarily mean "overhead." If the program needs the full-blown</span></div>
<div style="position:absolute;left:72.00px;top:451.68px" class="cls_006"><span class="cls_006">functionality of the contained object, then there is no overhead. It is just what you have to do. On the other</span></div>
<div style="position:absolute;left:72.00px;top:464.28px" class="cls_006"><span class="cls_006">hand, the </span><span class="cls_020">Trace </span><span class="cls_006">example (as shown in the previous chapter) is one example where "cost" and "overhead"</span></div>
<div style="position:absolute;left:72.00px;top:477.00px" class="cls_006"><span class="cls_006">actually coincided. We did not need the power of a </span><span class="cls_020">string</span><span class="cls_006"> object to represent the name of the function</span></div>
<div style="position:absolute;left:72.00px;top:489.36px" class="cls_006"><span class="cls_006">that is being traced. We never did anything too sophisticated with that object. We easily could have</span></div>
<div style="position:absolute;left:72.00px;top:501.96px" class="cls_006"><span class="cls_006">replaced it with a </span><span class="cls_020">char</span><span class="cls_006"> pointer. A </span><span class="cls_020">char</span><span class="cls_006"> pointer is much cheaper to construct than a </span><span class="cls_020">string</span><span class="cls_006"> object. Sadly,</span></div>
<div style="position:absolute;left:72.00px;top:514.20px" class="cls_006"><span class="cls_006">there are segments of the C++ programming community that seem to equate failure to use the more</span></div>
<div style="position:absolute;left:72.00px;top:526.32px" class="cls_006"><span class="cls_006">complex data types of C++ with a lack of programming sophistication, which results in overkill rather than</span></div>
<div style="position:absolute;left:72.00px;top:538.44px" class="cls_006"><span class="cls_006">adherence to a prime mantra: "Use a solution that is as simple as possible and no simpler."</span></div>
<div style="position:absolute;left:72.00px;top:564.48px" class="cls_006"><span class="cls_006">You can imagine that in complex hierarchies with large derivation and composition trees, the cost of</span></div>
<div style="position:absolute;left:72.00px;top:576.60px" class="cls_006"><span class="cls_006">constructing and destroying an object can skyrocket. This is something to keep in mind during the design</span></div>
<div style="position:absolute;left:72.00px;top:588.60px" class="cls_006"><span class="cls_006">phase if there is a good chance that this hierarchy may come to life during a performance-sensitive flow.</span></div>
<div style="position:absolute;left:72.00px;top:614.64px" class="cls_006"><span class="cls_006">The creation and destruction of contained objects is another issue worth consideration. There is no way for</span></div>
<div style="position:absolute;left:72.00px;top:626.76px" class="cls_006"><span class="cls_006">you to prevent the creation (destruction) of subobjects when the containing object is created (destroyed).</span></div>
<div style="position:absolute;left:72.00px;top:639.36px" class="cls_006"><span class="cls_006">This is automatically imposed by the compiler. Take our earlier </span><span class="cls_020">Trace</span><span class="cls_006"> example:</span></div>
<div style="position:absolute;left:72.00px;top:665.28px" class="cls_020"><span class="cls_020">class Trace {</span></div>
<div style="position:absolute;left:72.00px;top:676.56px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:687.96px" class="cls_020"><span class="cls_020">Trace (const char *name);</span></div>
<div style="position:absolute;left:72.00px;top:710.64px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:721.92px" class="cls_020"><span class="cls_020">string theFunctionName;</span></div>
<div style="position:absolute;left:72.00px;top:733.20px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">18</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:27264px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background033.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">The creation of a </span><span class="cls_020">Trace</span><span class="cls_006"> object will create the </span><span class="cls_020">string</span><span class="cls_006"> subobject. The </span><span class="cls_020">Trace</span><span class="cls_006"> destructor will similarly</span></div>
<div style="position:absolute;left:72.00px;top:83.76px" class="cls_006"><span class="cls_006">destroy it. It is automatic and you cannot prevent it with this implementation. To gain better control over</span></div>
<div style="position:absolute;left:72.00px;top:95.76px" class="cls_006"><span class="cls_006">the creation and destruction of a subobject, we can replace it with a pointer:</span></div>
<div style="position:absolute;left:72.00px;top:121.56px" class="cls_020"><span class="cls_020">class Trace {</span></div>
<div style="position:absolute;left:72.00px;top:132.84px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:144.12px" class="cls_020"><span class="cls_020">Trace (const char *name);</span></div>
<div style="position:absolute;left:96.00px;top:155.52px" class="cls_020"><span class="cls_020">// ...</span></div>
<div style="position:absolute;left:72.00px;top:166.80px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:178.20px" class="cls_020"><span class="cls_020">string *theFunctionName;</span></div>
<div style="position:absolute;left:72.00px;top:189.48px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:215.64px" class="cls_006"><span class="cls_006">Now we are in command of creation and destruction of the </span><span class="cls_020">string</span><span class="cls_006"> object. We still have the option of</span></div>
<div style="position:absolute;left:72.00px;top:228.48px" class="cls_006"><span class="cls_006">performing a full-blown initialization. This form will construct a new </span><span class="cls_020">string</span><span class="cls_006"> object and set a pointer to it:</span></div>
<div style="position:absolute;left:72.00px;top:254.40px" class="cls_020"><span class="cls_020">Trace::Trace(char *name) : theFunctionName(new string(name))</span></div>
<div style="position:absolute;left:72.00px;top:265.80px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:288.36px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:314.16px" class="cls_006"><span class="cls_006">We also have the option of a partial initialization. We assign an invalid default value to these pointers</span></div>
<div style="position:absolute;left:72.00px;top:326.16px" class="cls_006"><span class="cls_006">indicating that these objects must be constructed prior to being used. Our anticipated usage pattern was</span></div>
<div style="position:absolute;left:72.00px;top:338.76px" class="cls_006"><span class="cls_006">such that tracing was normally off and the </span><span class="cls_020">Trace</span><span class="cls_006"> objects created were rarely used. Minimizing the</span></div>
<div style="position:absolute;left:72.00px;top:351.00px" class="cls_006"><span class="cls_006">overhead of creation and destruction was therefore critical:</span></div>
<div style="position:absolute;left:72.00px;top:376.80px" class="cls_020"><span class="cls_020">Trace::Trace (const char *name) : theFunctionName(0)</span></div>
<div style="position:absolute;left:72.00px;top:388.08px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:399.36px" class="cls_020"><span class="cls_020">if (traceIsActive) {</span></div>
<div style="position:absolute;left:119.99px;top:410.76px" class="cls_020"><span class="cls_020">theFunctionName = new string(name);</span></div>
<div style="position:absolute;left:96.00px;top:433.44px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:444.72px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:470.40px" class="cls_006"><span class="cls_006">The first and second form were very inefficient because of the usage pattern. In the typical scenario tracing</span></div>
<div style="position:absolute;left:72.00px;top:483.00px" class="cls_006"><span class="cls_006">would be off and the effort to construct a </span><span class="cls_020">string</span><span class="cls_006"> object is worthless. The third form was best as assigning</span></div>
<div style="position:absolute;left:72.00px;top:495.24px" class="cls_006"><span class="cls_006">zero to a pointer is cheaper than constructing a brand-new object. Note that it is the usage pattern that</span></div>
<div style="position:absolute;left:72.00px;top:507.36px" class="cls_006"><span class="cls_006">dictates which form is most efficient. If our usage pattern was such that tracing is always on, the first form</span></div>
<div style="position:absolute;left:72.00px;top:519.96px" class="cls_006"><span class="cls_006">(containing subobjects, not pointers) would be best. It would be more efficient to embed the </span><span class="cls_020">string</span></div>
<div style="position:absolute;left:72.00px;top:532.68px" class="cls_006"><span class="cls_006">object in the </span><span class="cls_020">Trace</span><span class="cls_006"> object since it would consume stack memory as opposed to heap memory. Heap</span></div>
<div style="position:absolute;left:72.00px;top:545.04px" class="cls_006"><span class="cls_006">memory is far more expensive to allocate and free. Stack-based memory is allocated at compile time and is</span></div>
<div style="position:absolute;left:72.00px;top:557.16px" class="cls_006"><span class="cls_006">freed during the stack cleanup part of a function call return.</span></div>
<div style="position:absolute;left:72.00px;top:610.92px" class="cls_016"><span class="cls_016">Lazy Construction</span></div>
<div style="position:absolute;left:72.00px;top:642.24px" class="cls_006"><span class="cls_006">Performance optimization often has to strike a delicate balance between competing forces. This is perhaps</span></div>
<div style="position:absolute;left:72.00px;top:654.36px" class="cls_006"><span class="cls_006">why it is referred to as optimization as opposed to performance maximization. Performance optimization</span></div>
<div style="position:absolute;left:72.00px;top:666.36px" class="cls_006"><span class="cls_006">often requires the sacrifice of some other software goal. Important goals such as flexibility, maintainability,</span></div>
<div style="position:absolute;left:72.00px;top:678.48px" class="cls_006"><span class="cls_006">cost, and reuse must often give way to the demand for performance. It is unusual when a performance fix,</span></div>
<div style="position:absolute;left:72.00px;top:690.60px" class="cls_006"><span class="cls_006">in an otherwise high-quality piece of code, does not compromise any other software development goals.</span></div>
<div style="position:absolute;left:72.00px;top:702.60px" class="cls_006"><span class="cls_006">Sometimes we are fortunate when the elimination of simple coding mistakes results in higher performance</span></div>
<div style="position:absolute;left:72.00px;top:714.72px" class="cls_006"><span class="cls_006">without any sacrifice. The first optimization we are about to show is one such example. It eliminates the</span></div>
<div style="position:absolute;left:72.00px;top:726.72px" class="cls_006"><span class="cls_006">creation (and eventual destruction) of objects from code paths where they are never used.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">19</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:28116px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background034.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">If you are going to instantiate an object in a performance-critical path, you ought to consider the cost</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">factors. The cheapest object, however, is the one that's never instantiated.</span></div>
<div style="position:absolute;left:72.00px;top:109.08px" class="cls_006"><span class="cls_006">In C, Pascal, and other popular languages, data types must be defined at the beginning of a code block. We</span></div>
<div style="position:absolute;left:72.00px;top:121.20px" class="cls_006"><span class="cls_006">get into the habit of defining all the variables needed in a routine right up front at the beginning of that</span></div>
<div style="position:absolute;left:72.00px;top:133.20px" class="cls_006"><span class="cls_006">routine:</span></div>
<div style="position:absolute;left:72.00px;top:158.88px" class="cls_020"><span class="cls_020">void myFunction()</span></div>
<div style="position:absolute;left:72.00px;top:170.28px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:181.56px" class="cls_020"><span class="cls_020">int i;</span></div>
<div style="position:absolute;left:96.00px;top:192.96px" class="cls_020"><span class="cls_020">int j;</span></div>
<div style="position:absolute;left:96.00px;top:215.52px" class="cls_020"><span class="cls_020">compute(i,j)</span></div>
<div style="position:absolute;left:96.00px;top:238.20px" class="cls_020"><span class="cls_020">return;</span></div>
<div style="position:absolute;left:72.00px;top:249.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:275.28px" class="cls_006"><span class="cls_006">In C++, that habit of automatically defining all objects up front could be wasteful—you may construct</span></div>
<div style="position:absolute;left:72.00px;top:287.76px" class="cls_006"><span class="cls_006">objects that you end up not using. This happens in practice. In our C++ code we had a class </span><span class="cls_020">DataPacket</span></div>
<div style="position:absolute;left:72.00px;top:300.12px" class="cls_006"><span class="cls_006">that allocated and deallocated memory on the fly:</span></div>
<div style="position:absolute;left:72.00px;top:325.80px" class="cls_020"><span class="cls_020">class DataPacket</span></div>
<div style="position:absolute;left:72.00px;top:337.20px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:348.48px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:359.88px" class="cls_020"><span class="cls_020">DataPacket(char *data, int sz) : size(sz) {</span></div>
<div style="position:absolute;left:119.99px;top:371.16px" class="cls_020"><span class="cls_020">buffer = new char[sz];</span></div>
<div style="position:absolute;left:96.00px;top:393.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:416.52px" class="cls_020"><span class="cls_020">~DataPacket() {</span></div>
<div style="position:absolute;left:119.99px;top:427.80px" class="cls_020"><span class="cls_020">delete [] buffer;</span></div>
<div style="position:absolute;left:96.00px;top:450.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:461.76px" class="cls_020"><span class="cls_020">... // other public member functions</span></div>
<div style="position:absolute;left:72.00px;top:473.16px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:484.44px" class="cls_020"><span class="cls_020">char *buffer;</span></div>
<div style="position:absolute;left:96.00px;top:495.72px" class="cls_020"><span class="cls_020">... // other private members</span></div>
<div style="position:absolute;left:72.00px;top:507.12px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:533.28px" class="cls_006"><span class="cls_006">Partly due to memory allocation and deallocation, </span><span class="cls_020">DataPacket</span><span class="cls_006"> was expensive to construct and destroy.</span></div>
<div style="position:absolute;left:72.00px;top:545.64px" class="cls_006"><span class="cls_006">Its cost was upwards of 400 instructions, which was significant in our context. It was used in a</span></div>
<div style="position:absolute;left:72.00px;top:557.64px" class="cls_006"><span class="cls_006">performance-critical path that routed data from one adapter to another:</span></div>
<div style="position:absolute;left:72.00px;top:583.32px" class="cls_020"><span class="cls_020">void routeData(char *data, int size)</span></div>
<div style="position:absolute;left:72.00px;top:594.72px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:606.00px" class="cls_020"><span class="cls_020">DataPacket packet(data, size);</span></div>
<div style="position:absolute;left:96.00px;top:617.40px" class="cls_020"><span class="cls_020">bool  direction = get_direction();</span></div>
<div style="position:absolute;left:203.98px;top:628.68px" class="cls_020"><span class="cls_020">// Some computation</span></div>
<div style="position:absolute;left:96.00px;top:639.96px" class="cls_020"><span class="cls_020">if (UPSTREAM == direction) {// data going upstream</span></div>
<div style="position:absolute;left:119.99px;top:651.36px" class="cls_020"><span class="cls_020">computeSomething(packet);</span></div>
<div style="position:absolute;left:96.00px;top:662.64px" class="cls_020"><span class="cls_020">} else {</span></div>
<div style="position:absolute;left:215.97px;top:662.64px" class="cls_020"><span class="cls_020">// data going downstream</span></div>
<div style="position:absolute;left:209.97px;top:674.04px" class="cls_020"><span class="cls_020">// packet is not used in this scope.</span></div>
<div style="position:absolute;left:96.00px;top:685.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:696.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:722.88px" class="cls_006"><span class="cls_006">Object </span><span class="cls_020">packet</span><span class="cls_006"> was used if and only if data was going upstream, which was 50% of the time. When data</span></div>
<div style="position:absolute;left:72.00px;top:735.60px" class="cls_006"><span class="cls_006">headed downstream, </span><span class="cls_020">packet</span><span class="cls_006"> was not used at all. Object </span><span class="cls_020">packet</span><span class="cls_006">, however, was constructed</span></div>
<div style="position:absolute;left:72.00px;top:747.96px" class="cls_006"><span class="cls_006">unconditionally at the beginning of the scope. Half the time, this was a perfect waste of computing cycles.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">20</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:28968px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background035.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">The solution here, as you can imagine, was very easy. Object </span><span class="cls_020">packet</span><span class="cls_006"> should be created if and only if it is</span></div>
<div style="position:absolute;left:72.00px;top:84.24px" class="cls_006"><span class="cls_006">actually needed. The definition of </span><span class="cls_020">packet</span><span class="cls_006"> ought to be moved inside the scope that uses it, when data is</span></div>
<div style="position:absolute;left:72.00px;top:96.48px" class="cls_006"><span class="cls_006">going upstream:</span></div>
<div style="position:absolute;left:72.00px;top:122.28px" class="cls_020"><span class="cls_020">void routeData(char *data, int size)</span></div>
<div style="position:absolute;left:72.00px;top:133.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:257.97px;top:144.96px" class="cls_020"><span class="cls_020">// Delete definition of packet</span></div>
<div style="position:absolute;left:96.00px;top:156.24px" class="cls_020"><span class="cls_020">bool direction = get_direction();</span></div>
<div style="position:absolute;left:96.00px;top:178.92px" class="cls_020"><span class="cls_020">if (UPSTREAM == direction) {// data going upstream</span></div>
<div style="position:absolute;left:119.99px;top:190.20px" class="cls_020"><span class="cls_020">DataPacket packet(data, size); // Add definition of packet</span></div>
<div style="position:absolute;left:299.96px;top:201.60px" class="cls_020"><span class="cls_020">// here...</span></div>
<div style="position:absolute;left:119.99px;top:212.88px" class="cls_020"><span class="cls_020">computeSomething(packet);</span></div>
<div style="position:absolute;left:96.00px;top:224.16px" class="cls_020"><span class="cls_020">} else {</span></div>
<div style="position:absolute;left:257.97px;top:224.16px" class="cls_020"><span class="cls_020">// data going downstream</span></div>
<div style="position:absolute;left:263.97px;top:235.56px" class="cls_020"><span class="cls_020">// packet is not used in this scope.</span></div>
<div style="position:absolute;left:96.00px;top:246.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:258.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:283.92px" class="cls_006"><span class="cls_006">Although the practice of delaying variable creation until its first usage has been preached by the C++</span></div>
<div style="position:absolute;left:72.00px;top:295.92px" class="cls_006"><span class="cls_006">language experts since the language inception, this coding mistake was detected in real product code. The</span></div>
<div style="position:absolute;left:72.00px;top:308.04px" class="cls_006"><span class="cls_006">compatibility between C++ and C has been touted as one of C++'s advantages, but this is an area where</span></div>
<div style="position:absolute;left:72.00px;top:320.04px" class="cls_006"><span class="cls_006">that compatibility creates stylistic discontinuity. Adherence to the now obsolete C declaration syntax in</span></div>
<div style="position:absolute;left:72.00px;top:332.16px" class="cls_006"><span class="cls_006">C++ can have significant performance costs. Unfortunately, it is a fact that such trivial mistakes often do</span></div>
<div style="position:absolute;left:72.00px;top:344.28px" class="cls_006"><span class="cls_006">happen in practice. Part of C++'s being a better C is its ability to delay variable creation.</span></div>
<div style="position:absolute;left:72.00px;top:370.32px" class="cls_006"><span class="cls_006">It is worth noting that the definition of variables at the beginning of any scope are allowed in C as well. It</span></div>
<div style="position:absolute;left:72.00px;top:382.44px" class="cls_006"><span class="cls_006">is just that C programmers tend to define all of the variables right at the beginning of the function scope,</span></div>
<div style="position:absolute;left:72.00px;top:394.44px" class="cls_006"><span class="cls_006">since there is no run-time cost in a C variable definition. This is not the case with C++ where care must be</span></div>
<div style="position:absolute;left:72.00px;top:406.56px" class="cls_006"><span class="cls_006">taken with regard to the placement of object definitions.</span></div>
<div style="position:absolute;left:72.00px;top:460.32px" class="cls_016"><span class="cls_016">Redundant Construction</span></div>
<div style="position:absolute;left:72.00px;top:491.64px" class="cls_006"><span class="cls_006">Along the lines of simple but costly coding mistakes, here's another example of pure overhead. It is the</span></div>
<div style="position:absolute;left:72.00px;top:503.76px" class="cls_006"><span class="cls_006">double construction of a contained object [</span><span class="cls_036">Mey97</span><span class="cls_006"> item 12], [</span><span class="cls_036">Lip91</span><span class="cls_006">].</span></div>
<div style="position:absolute;left:72.00px;top:530.28px" class="cls_006"><span class="cls_006">Class </span><span class="cls_020">Person</span><span class="cls_006"> contains an object of class </span><span class="cls_020">string:</span></div>
<div style="position:absolute;left:72.00px;top:556.20px" class="cls_020"><span class="cls_020">class Person {</span></div>
<div style="position:absolute;left:72.00px;top:567.60px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:578.88px" class="cls_020"><span class="cls_020">Person (const char *s) { name = s; }// Version 0</span></div>
<div style="position:absolute;left:72.00px;top:612.84px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:624.24px" class="cls_020"><span class="cls_020">string name;</span></div>
<div style="position:absolute;left:72.00px;top:635.52px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:661.80px" class="cls_006"><span class="cls_006">Consider the following implementation of the </span><span class="cls_020">Person</span><span class="cls_006"> default constructor:</span></div>
<div style="position:absolute;left:72.00px;top:687.72px" class="cls_020"><span class="cls_020">Person (const char *s) { name = s; }</span></div>
<div style="position:absolute;left:72.00px;top:713.88px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">Person</span><span class="cls_006"> object must be initialized before the body of the </span><span class="cls_020">Person</span><span class="cls_006"> constructor is executed. The</span></div>
<div style="position:absolute;left:72.00px;top:726.60px" class="cls_006"><span class="cls_006">contained </span><span class="cls_020">string</span><span class="cls_006"> object does not appear in the </span><span class="cls_020">Person::Person(char*)</span><span class="cls_006"> initialization list (in this</span></div>
<div style="position:absolute;left:72.00px;top:739.44px" class="cls_006"><span class="cls_006">case there was none). Hence, the compiler must insert a call to invoke the </span><span class="cls_020">string</span><span class="cls_006"> default constructor, to</span></div>
<div style="position:absolute;left:72.00px;top:752.28px" class="cls_006"><span class="cls_006">initialize the </span><span class="cls_020">string</span><span class="cls_006"> member object properly. The body of the </span><span class="cls_020">Person</span><span class="cls_006"> constructor is then executed. The</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">21</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:29820px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background036.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">statement </span><span class="cls_020">name = s</span><span class="cls_006">; assigns the </span><span class="cls_020">char</span><span class="cls_006"> pointer </span><span class="cls_020">s</span><span class="cls_006"> to the left-hand side object of type </span><span class="cls_020">string</span><span class="cls_006">. The</span></div>
<div style="position:absolute;left:72.00px;top:84.24px" class="cls_020"><span class="cls_020">string::operator=(const</span><span class="cls_006"> </span><span class="cls_020">char*)</span><span class="cls_006"> is invoked to execute that assignment. The computation</span></div>
<div style="position:absolute;left:72.00px;top:96.96px" class="cls_006"><span class="cls_006">performed by the assignment operator essentially overwrites the result of the default </span><span class="cls_020">string</span><span class="cls_006"> constructor</span></div>
<div style="position:absolute;left:72.00px;top:109.80px" class="cls_006"><span class="cls_006">invoked earlier during initialization. The computational effort contained in the default </span><span class="cls_020">string</span><span class="cls_006"> constructor</span></div>
<div style="position:absolute;left:72.00px;top:122.16px" class="cls_006"><span class="cls_006">is thrown away in its entirety.</span></div>
<div style="position:absolute;left:72.00px;top:148.20px" class="cls_006"><span class="cls_006">Many optimizations require some kind of a trade-off. You often trade speed for clarity, simplicity,</span></div>
<div style="position:absolute;left:72.00px;top:160.32px" class="cls_006"><span class="cls_006">reusability, or some other metric. But in this example, optimization requires no sacrifice at all. You can</span></div>
<div style="position:absolute;left:72.00px;top:172.80px" class="cls_006"><span class="cls_006">rewrite the </span><span class="cls_020">Person</span><span class="cls_006"> constructor implementation, claiming back the lost speed and trading away nothing.</span></div>
<div style="position:absolute;left:72.00px;top:185.64px" class="cls_006"><span class="cls_006">You achieve that by specifying an explicit initialization of the </span><span class="cls_020">string</span><span class="cls_006"> member </span><span class="cls_020">name.</span></div>
<div style="position:absolute;left:72.00px;top:211.56px" class="cls_020"><span class="cls_020">Person::Person(const char *s) : name(s) {} // Version 1.</span></div>
<div style="position:absolute;left:72.00px;top:237.84px" class="cls_006"><span class="cls_006">This constructor will generate the exact same </span><span class="cls_020">Person</span><span class="cls_006"> object with the exception of improved performance.</span></div>
<div style="position:absolute;left:72.00px;top:250.56px" class="cls_006"><span class="cls_006">All we get here is a single call to </span><span class="cls_020">string::string(const char *)</span><span class="cls_006"> to initialize </span><span class="cls_020">name</span><span class="cls_006"> with </span><span class="cls_020">s</span><span class="cls_006">. We</span></div>
<div style="position:absolute;left:72.00px;top:262.92px" class="cls_006"><span class="cls_006">tested the performance difference by timing the following loop:</span></div>
<div style="position:absolute;left:72.00px;top:288.60px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; MILLION; i++) {</span></div>
<div style="position:absolute;left:96.00px;top:300.00px" class="cls_020"><span class="cls_020">Person p("Pele");</span></div>
<div style="position:absolute;left:72.00px;top:311.28px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:336.96px" class="cls_006"><span class="cls_006">The chart in </span><span class="cls_036">Figure 2.2</span><span class="cls_006"> compares the execution time of Version 0 (silent initialization plus explicit</span></div>
<div style="position:absolute;left:72.00px;top:349.08px" class="cls_006"><span class="cls_006">assignment) to that of Version 1 (explicit initialization only).</span></div>
<div style="position:absolute;left:88.92px;top:375.24px" class="cls_021"><span class="cls_021">Figure 2.2. Overhead of a silent initialization is negligible in this particular scenario.</span></div>
<div style="position:absolute;left:72.00px;top:628.92px" class="cls_006"><span class="cls_006">Fortunately, the default string constructor is very cheap, making this inefficiency almost negligible. You</span></div>
<div style="position:absolute;left:72.00px;top:641.04px" class="cls_006"><span class="cls_006">are not always going to be that lucky, so don't count on it.</span></div>
<div style="position:absolute;left:72.00px;top:667.08px" class="cls_006"><span class="cls_006">Suppose you decided, for some reason, to bypass the standard string implementation and roll your own</span></div>
<div style="position:absolute;left:72.00px;top:679.68px" class="cls_006"><span class="cls_006">instead. We'll call it </span><span class="cls_020">SuperString:</span></div>
<div style="position:absolute;left:72.00px;top:705.60px" class="cls_020"><span class="cls_020">class SuperString</span></div>
<div style="position:absolute;left:72.00px;top:717.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:728.28px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:739.56px" class="cls_020"><span class="cls_020">SuperString(const char *s = 0);</span></div>
<div style="position:absolute;left:96.00px;top:750.96px" class="cls_020"><span class="cls_020">SuperString(const SuperString &s);</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">22</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:30672px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background037.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">SuperString& operator=(const SuperString& s);</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">~SuperString() {delete [] str;}</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:127.20px" class="cls_020"><span class="cls_020">char *str;</span></div>
<div style="position:absolute;left:72.00px;top:138.48px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:161.16px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:172.56px" class="cls_020"><span class="cls_020">SuperString::SuperString(const char *s)</span></div>
<div style="position:absolute;left:96.00px;top:183.84px" class="cls_020"><span class="cls_020">: str(0)</span></div>
<div style="position:absolute;left:72.00px;top:195.12px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:206.52px" class="cls_020"><span class="cls_020">if (s != 0) {</span></div>
<div style="position:absolute;left:119.99px;top:217.80px" class="cls_020"><span class="cls_020">str = new char[strlen(s)+1];</span></div>
<div style="position:absolute;left:119.99px;top:229.20px" class="cls_020"><span class="cls_020">strcpy(str,s);</span></div>
<div style="position:absolute;left:96.00px;top:240.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:251.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:263.16px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:274.44px" class="cls_020"><span class="cls_020">SuperString::SuperString(const SuperString &s)</span></div>
<div style="position:absolute;left:96.00px;top:285.84px" class="cls_020"><span class="cls_020">: str(0)</span></div>
<div style="position:absolute;left:72.00px;top:297.12px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:308.40px" class="cls_020"><span class="cls_020">if (s.str) {</span></div>
<div style="position:absolute;left:119.99px;top:319.80px" class="cls_020"><span class="cls_020">str = new char[strlen(s.str)+1];</span></div>
<div style="position:absolute;left:119.99px;top:331.08px" class="cls_020"><span class="cls_020">strcpy(str,s.str);</span></div>
<div style="position:absolute;left:96.00px;top:342.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:353.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:376.44px" class="cls_020"><span class="cls_020">SuperString& SuperString::operator=(const SuperString& s)</span></div>
<div style="position:absolute;left:72.00px;top:387.72px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:399.12px" class="cls_020"><span class="cls_020">if (str != s.str) {</span></div>
<div style="position:absolute;left:119.99px;top:410.40px" class="cls_020"><span class="cls_020">delete [] str;</span></div>
<div style="position:absolute;left:119.99px;top:421.68px" class="cls_020"><span class="cls_020">if (s.str) {</span></div>
<div style="position:absolute;left:143.99px;top:433.08px" class="cls_020"><span class="cls_020">str = new char[strlen(s.str)+1];</span></div>
<div style="position:absolute;left:143.99px;top:444.36px" class="cls_020"><span class="cls_020">strcpy(str,s.str);</span></div>
<div style="position:absolute;left:119.99px;top:455.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:119.99px;top:467.04px" class="cls_020"><span class="cls_020">else str = 0;</span></div>
<div style="position:absolute;left:96.00px;top:478.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:501.00px" class="cls_020"><span class="cls_020">return *this;</span></div>
<div style="position:absolute;left:72.00px;top:512.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:538.56px" class="cls_006"><span class="cls_006">Furthermore, you have decided to replace the </span><span class="cls_020">string</span><span class="cls_006"> member with a </span><span class="cls_020">SuperString</span><span class="cls_006"> in your </span><span class="cls_020">Person</span></div>
<div style="position:absolute;left:72.00px;top:550.80px" class="cls_006"><span class="cls_006">implementation:</span></div>
<div style="position:absolute;left:72.00px;top:576.60px" class="cls_020"><span class="cls_020">class Person {</span></div>
<div style="position:absolute;left:72.00px;top:587.88px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:599.28px" class="cls_020"><span class="cls_020">Person (const char *s) { name = s; }// Version 2</span></div>
<div style="position:absolute;left:72.00px;top:633.24px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:644.52px" class="cls_020"><span class="cls_020">SuperString name;</span></div>
<div style="position:absolute;left:72.00px;top:655.92px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:682.08px" class="cls_006"><span class="cls_006">Because you did not provide a </span><span class="cls_020">SuperString</span><span class="cls_006"> assignment operator that accepts a </span><span class="cls_020">char</span><span class="cls_006"> pointer argument,</span></div>
<div style="position:absolute;left:72.00px;top:694.80px" class="cls_006"><span class="cls_006">the assignment operator demands a </span><span class="cls_020">SuperString</span><span class="cls_006"> object reference as an argument. Consequently, the</span></div>
<div style="position:absolute;left:72.00px;top:707.16px" class="cls_006"><span class="cls_006">statement</span></div>
<div style="position:absolute;left:72.00px;top:732.84px" class="cls_020"><span class="cls_020">name = s;</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">23</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:31524px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background038.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">in the </span><span class="cls_020">Person</span><span class="cls_006"> constructor will trigger the creation of a temporary </span><span class="cls_020">SuperString</span><span class="cls_006"> object. The compiler</span></div>
<div style="position:absolute;left:72.00px;top:84.24px" class="cls_006"><span class="cls_006">will convert the </span><span class="cls_020">char</span><span class="cls_006"> pointer </span><span class="cls_020">s</span><span class="cls_006"> to a </span><span class="cls_020">SuperString</span><span class="cls_006"> by invoking the appropriate </span><span class="cls_020">SuperString</span></div>
<div style="position:absolute;left:72.00px;top:96.96px" class="cls_006"><span class="cls_006">constructor. Using pseudocode, we have the following transformation of the </span><span class="cls_020">Person::Person(char*)</span></div>
<div style="position:absolute;left:72.00px;top:109.32px" class="cls_006"><span class="cls_006">implementation</span></div>
<div style="position:absolute;left:72.00px;top:135.00px" class="cls_020"><span class="cls_020">Person::Person(const char *s)</span></div>
<div style="position:absolute;left:72.00px;top:146.40px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:157.68px" class="cls_020"><span class="cls_020">name.SuperString::SuperString();</span></div>
<div style="position:absolute;left:389.94px;top:157.68px" class="cls_020"><span class="cls_020">// Constructor:</span></div>
<div style="position:absolute;left:72.00px;top:169.08px" class="cls_020"><span class="cls_020">Initialize</span></div>
<div style="position:absolute;left:389.94px;top:180.36px" class="cls_020"><span class="cls_020">// member "name".</span></div>
<div style="position:absolute;left:96.00px;top:203.04px" class="cls_020"><span class="cls_020">SuperString _temp;</span></div>
<div style="position:absolute;left:389.94px;top:203.04px" class="cls_020"><span class="cls_020">// Temporary object.</span></div>
<div style="position:absolute;left:96.00px;top:225.72px" class="cls_020"><span class="cls_020">_temp.SuperString::SuperString(s);</span></div>
<div style="position:absolute;left:389.94px;top:225.72px" class="cls_020"><span class="cls_020">// Construct a</span></div>
<div style="position:absolute;left:72.00px;top:237.00px" class="cls_020"><span class="cls_020">SuperString</span></div>
<div style="position:absolute;left:389.94px;top:248.28px" class="cls_020"><span class="cls_020">// object from "s".</span></div>
<div style="position:absolute;left:96.00px;top:270.96px" class="cls_020"><span class="cls_020">name.SuperString::operator=(_temp);</span></div>
<div style="position:absolute;left:389.94px;top:270.96px" class="cls_020"><span class="cls_020">// Assign _temp to</span></div>
<div style="position:absolute;left:72.00px;top:282.36px" class="cls_020"><span class="cls_020">"name".</span></div>
<div style="position:absolute;left:96.00px;top:304.92px" class="cls_020"><span class="cls_020">_temp.SuperString::~SuperString();</span></div>
<div style="position:absolute;left:389.94px;top:304.92px" class="cls_020"><span class="cls_020">// Destructor for</span></div>
<div style="position:absolute;left:72.00px;top:316.32px" class="cls_020"><span class="cls_020">temporary</span></div>
<div style="position:absolute;left:389.94px;top:327.60px" class="cls_020"><span class="cls_020">// object.</span></div>
<div style="position:absolute;left:72.00px;top:350.28px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:376.44px" class="cls_006"><span class="cls_006">The content of the temporary </span><span class="cls_020">SuperString</span><span class="cls_006"> object </span><span class="cls_020">(temp)</span><span class="cls_006"> is assigned to member </span><span class="cls_020">name</span><span class="cls_006"> via invocation</span></div>
<div style="position:absolute;left:72.00px;top:389.28px" class="cls_006"><span class="cls_006">of the </span><span class="cls_020">SuperString</span><span class="cls_006"> assignment operator. It is then followed by invocation of the </span><span class="cls_020">SuperString</span></div>
<div style="position:absolute;left:72.00px;top:401.64px" class="cls_006"><span class="cls_006">destructor to tear down the temporary object.</span></div>
<div style="position:absolute;left:72.00px;top:428.16px" class="cls_006"><span class="cls_006">Overall we get two </span><span class="cls_020">SuperString</span><span class="cls_006"> constructors, one call to the assignment operator and another to the</span></div>
<div style="position:absolute;left:72.00px;top:440.52px" class="cls_006"><span class="cls_006">destructor. The performance damage in this implementation is much more severe (see </span><span class="cls_036">Figure 2.3</span><span class="cls_006">). Version</span></div>
<div style="position:absolute;left:72.00px;top:453.00px" class="cls_006"><span class="cls_006">3 fixes it by explicit initialization of the </span><span class="cls_020">SuperString</span><span class="cls_006"> member:</span></div>
<div style="position:absolute;left:72.00px;top:479.04px" class="cls_020"><span class="cls_020">Person::Person(const char *s) : name(s) {}</span></div>
<div style="position:absolute;left:341.95px;top:479.04px" class="cls_020"><span class="cls_020">// Version 3. Explicit</span></div>
<div style="position:absolute;left:341.95px;top:490.32px" class="cls_020"><span class="cls_020">// initialization</span></div>
<div style="position:absolute;left:156.12px;top:516.00px" class="cls_021"><span class="cls_021">Figure 2.3. More significant impact of silent initialization.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">24</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:32376px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background039.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">Version 2 is the one using both silent initialization plus an explicit assignment in the constructor body.</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">Version 3 is the one doing an explicit initialization and no assignment. In the case of our home-grown</span></div>
<div style="position:absolute;left:72.00px;top:95.52px" class="cls_020"><span class="cls_020">SuperString</span><span class="cls_006">, Version 3 is more than twice as fast. The performance damage would have been less</span></div>
<div style="position:absolute;left:72.00px;top:108.36px" class="cls_006"><span class="cls_006">severe had an assignment operator been provided that takes a </span><span class="cls_020">char</span><span class="cls_006"> pointer as an argument. That would</span></div>
<div style="position:absolute;left:72.00px;top:121.20px" class="cls_006"><span class="cls_006">have eliminated the need for a temporary </span><span class="cls_020">SuperString</span><span class="cls_006"> object. It is interesting to note that Version 3 is a</span></div>
<div style="position:absolute;left:72.00px;top:133.92px" class="cls_006"><span class="cls_006">little faster than the corresponding version using the compiler </span><span class="cls_020">string</span><span class="cls_006"> implementation (Version 1). Our</span></div>
<div style="position:absolute;left:72.00px;top:146.76px" class="cls_006"><span class="cls_006">home-grown </span><span class="cls_020">SuperString</span><span class="cls_006"> does not provide anything near the rich functionality of the </span><span class="cls_020">string</span><span class="cls_006"> class. It</span></div>
<div style="position:absolute;left:72.00px;top:159.12px" class="cls_006"><span class="cls_006">is often the case that code runs faster if it does not have to provide much flexibility.</span></div>
<div style="position:absolute;left:72.00px;top:212.88px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:244.44px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Constructors and destructors may be as efficient as hand-crafted C code. In practice, however,</span></div>
<div style="position:absolute;left:108.00px;top:256.56px" class="cls_006"><span class="cls_006">they often contain overhead in the form of superfluous computations.</span></div>
<div style="position:absolute;left:90.00px;top:268.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The construction (destruction) of an object triggers recursive construction (destruction) of parent</span></div>
<div style="position:absolute;left:108.00px;top:280.92px" class="cls_006"><span class="cls_006">and member objects. Watch out for the combinatorial explosion of objects in complex hierarchies.</span></div>
<div style="position:absolute;left:108.00px;top:293.04px" class="cls_006"><span class="cls_006">They make construction and destruction more expensive.</span></div>
<div style="position:absolute;left:90.00px;top:305.28px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Make sure that your code actually uses all the objects that it creates and the computations that they</span></div>
<div style="position:absolute;left:108.00px;top:317.40px" class="cls_006"><span class="cls_006">perform. We would encourage people to peer inside the classes that they use. This advice is not</span></div>
<div style="position:absolute;left:108.00px;top:329.52px" class="cls_006"><span class="cls_006">going to be popular with OOP advocates. OOP, after all, preaches the use of classes as</span></div>
<div style="position:absolute;left:108.00px;top:341.52px" class="cls_006"><span class="cls_006">encapsulated black-box entities and discourages you from looking inside. How do we balance</span></div>
<div style="position:absolute;left:108.00px;top:353.64px" class="cls_006"><span class="cls_006">between those competing pieces of advice? There is no simple answer because it is context</span></div>
<div style="position:absolute;left:108.00px;top:365.76px" class="cls_006"><span class="cls_006">sensitive. Although the black-box approach works perfectly well for 80% of your code, it may</span></div>
<div style="position:absolute;left:108.00px;top:377.76px" class="cls_006"><span class="cls_006">wreak havoc on the 20% that is performance critical. It is also application dependent. Some</span></div>
<div style="position:absolute;left:108.00px;top:389.88px" class="cls_006"><span class="cls_006">application will put a premium on maintainability and flexibility, and others may put performance</span></div>
<div style="position:absolute;left:108.00px;top:401.88px" class="cls_006"><span class="cls_006">considerations at the top of the list. As a programmer you are going to have to decide the question</span></div>
<div style="position:absolute;left:108.00px;top:414.00px" class="cls_006"><span class="cls_006">of what exactly you are trying to maximize.</span></div>
<div style="position:absolute;left:90.00px;top:426.36px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The object life cycle is not free of cost. At the very least, construction and destruction of an object</span></div>
<div style="position:absolute;left:108.00px;top:438.36px" class="cls_006"><span class="cls_006">may consume CPU cycles. Don't create an object unless you are going to use it. Typically, you</span></div>
<div style="position:absolute;left:108.00px;top:450.48px" class="cls_006"><span class="cls_006">want to defer object construction to the scope in which it is manipulated.</span></div>
<div style="position:absolute;left:90.00px;top:462.84px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Compilers must initialize contained member objects prior to entering the constructor body. You</span></div>
<div style="position:absolute;left:108.00px;top:474.84px" class="cls_006"><span class="cls_006">ought to use the initialization phase to complete the member object creation. This will save the</span></div>
<div style="position:absolute;left:108.00px;top:486.96px" class="cls_006"><span class="cls_006">overhead of calling the assignment operator later in the constructor body. In some cases, it will</span></div>
<div style="position:absolute;left:108.00px;top:499.08px" class="cls_006"><span class="cls_006">also avoid the generation of temporary objects.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">25</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:33228px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background040.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 3. Virtual Functions</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">The evolution of programming languages tended to make the programming task easier by shifting some</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">burden from the programmer to the compiler, interpreter, assembler, or linker. Programs are becoming</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">easier to develop, maintain, and extend. The problem with this progress is that it is often a zero-sum game</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">where gains in one area mean losses in another. In particular, advances in programming often translate into</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">loss of raw speed. Dynamic binding of function calls is one among many contributions C++ has made to C</span></div>
<div style="position:absolute;left:72.00px;top:178.32px" class="cls_006"><span class="cls_006">programming. It shifts the burden of type resolution from the programmer to the compiler, which is good.</span></div>
<div style="position:absolute;left:72.00px;top:190.32px" class="cls_006"><span class="cls_006">On the other hand, it can have a negative impact on cost, which is what we intend to examine.</span></div>
<div style="position:absolute;left:72.00px;top:244.08px" class="cls_016"><span class="cls_016">Virtual Function Mechanics</span></div>
<div style="position:absolute;left:72.00px;top:275.40px" class="cls_006"><span class="cls_006">If you really wanted to avoid virtual functions, you could emulate dynamic binding by providing your own</span></div>
<div style="position:absolute;left:72.00px;top:287.52px" class="cls_006"><span class="cls_006">type resolution code. Suppose you are maintaining a class hierarchy of zoo animals [</span><span class="cls_036">Lip91</span><span class="cls_006">], where</span></div>
<div style="position:absolute;left:72.00px;top:300.12px" class="cls_020"><span class="cls_020">ZooAnimal</span><span class="cls_006"> is your base class:</span></div>
<div style="position:absolute;left:72.00px;top:326.04px" class="cls_020"><span class="cls_020">class ZooAnimal {</span></div>
<div style="position:absolute;left:72.00px;top:337.44px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:360.00px" class="cls_020"><span class="cls_020">virtual void draw();</span></div>
<div style="position:absolute;left:96.00px;top:371.40px" class="cls_020"><span class="cls_020">int resolveType() {return myType;}</span></div>
<div style="position:absolute;left:72.00px;top:382.68px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:394.08px" class="cls_020"><span class="cls_020">int myType;</span></div>
<div style="position:absolute;left:72.00px;top:416.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:442.92px" class="cls_006"><span class="cls_006">The rest of the animals in the zoo are derived from </span><span class="cls_020">ZooAnimal</span><span class="cls_006">. The </span><span class="cls_020">resolveType()</span><span class="cls_006"> method will</span></div>
<div style="position:absolute;left:72.00px;top:455.64px" class="cls_006"><span class="cls_006">enable you to distinguish a </span><span class="cls_020">Bear</span><span class="cls_006"> from a </span><span class="cls_020">Monkey</span><span class="cls_006"> at run-time.</span></div>
<div style="position:absolute;left:72.00px;top:481.56px" class="cls_020"><span class="cls_020">class Bear : public ZooAnimal {</span></div>
<div style="position:absolute;left:72.00px;top:492.96px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:504.24px" class="cls_020"><span class="cls_020">Bear (const char *name) : myName(name), myType(BEAR) {}</span></div>
<div style="position:absolute;left:96.00px;top:515.64px" class="cls_020"><span class="cls_020">void draw();</span></div>
<div style="position:absolute;left:72.00px;top:538.20px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:563.88px" class="cls_006"><span class="cls_006">Each animal sets its appropriate type in its constructor.</span></div>
<div style="position:absolute;left:72.00px;top:590.04px" class="cls_006"><span class="cls_006">If you wanted to draw all animals in the zoo, you would end up with something along the lines of [</span><span class="cls_036">Lip91</span><span class="cls_006">]:</span></div>
<div style="position:absolute;left:72.00px;top:615.72px" class="cls_020"><span class="cls_020">void drawAllAnimals (ZooAnimal *pz) // pointer to first animal in the</span></div>
<div style="position:absolute;left:287.96px;top:627.12px" class="cls_020"><span class="cls_020">// list</span></div>
<div style="position:absolute;left:72.00px;top:638.40px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:649.68px" class="cls_020"><span class="cls_020">for (ZooAnimal *p=pz; p ;p = p->next) {</span></div>
<div style="position:absolute;left:119.99px;top:661.08px" class="cls_020"><span class="cls_020">switch (p->resolveType()) {</span></div>
<div style="position:absolute;left:131.99px;top:672.36px" class="cls_020"><span class="cls_020">case BEAR:</span></div>
<div style="position:absolute;left:143.99px;top:683.76px" class="cls_020"><span class="cls_020">( (Bear *) p)->draw();</span></div>
<div style="position:absolute;left:143.99px;top:695.04px" class="cls_020"><span class="cls_020">break;</span></div>
<div style="position:absolute;left:131.99px;top:706.32px" class="cls_020"><span class="cls_020">case MONKEY:</span></div>
<div style="position:absolute;left:143.99px;top:717.72px" class="cls_020"><span class="cls_020">((Monkey *) p)->draw();</span></div>
<div style="position:absolute;left:143.99px;top:729.00px" class="cls_020"><span class="cls_020">break;</span></div>
<div style="position:absolute;left:131.99px;top:740.40px" class="cls_020"><span class="cls_020">... // Handle all other animals currently in the zoo.</span></div>
<div style="position:absolute;left:119.99px;top:751.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">26</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:34080px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background041.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:107.64px" class="cls_006"><span class="cls_006">This code is a maintenance headache. Any time an animal leaves the zoo, you'll have to remove it from the</span></div>
<div style="position:absolute;left:72.00px;top:119.64px" class="cls_006"><span class="cls_006">switch statement, and any time a new animal arrives, you'll have to add it. Dynamic binding of a virtual</span></div>
<div style="position:absolute;left:72.00px;top:132.24px" class="cls_006"><span class="cls_006">function allows you to divorce your code from that dependency. Because </span><span class="cls_020">ZooAnimal::draw()</span><span class="cls_006"> is a</span></div>
<div style="position:absolute;left:72.00px;top:144.48px" class="cls_006"><span class="cls_006">virtual function, you can take advantage of dynamic binding at run-time:</span></div>
<div style="position:absolute;left:72.00px;top:170.28px" class="cls_020"><span class="cls_020">void drawAllAnimals (ZooAnimal *pz) // pointer to first animal in the</span></div>
<div style="position:absolute;left:287.96px;top:181.56px" class="cls_020"><span class="cls_020">// list</span></div>
<div style="position:absolute;left:72.00px;top:192.96px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:204.24px" class="cls_020"><span class="cls_020">for (ZooAnimal *p=pz; p ;p = p->next) {</span></div>
<div style="position:absolute;left:119.99px;top:215.52px" class="cls_020"><span class="cls_020">p->draw();</span></div>
<div style="position:absolute;left:96.00px;top:226.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:253.08px" class="cls_006"><span class="cls_006">This code can still distinguish a </span><span class="cls_020">Bear</span><span class="cls_006"> from </span><span class="cls_020">Monkey</span><span class="cls_006">. How does it do that? To facilitate late binding we</span></div>
<div style="position:absolute;left:72.00px;top:265.80px" class="cls_006"><span class="cls_006">must have a way of resolving a virtual function call at run-time, as opposed to compile-time. If class </span><span class="cls_020">X</span></div>
<div style="position:absolute;left:72.00px;top:278.64px" class="cls_006"><span class="cls_006">defines a virtual function or is derived from such class, a virtual function table is generated for class </span><span class="cls_020">X</span></div>
<div style="position:absolute;left:72.00px;top:291.48px" class="cls_020"><span class="cls_020">(vtbl)</span><span class="cls_006"> by the compiler. The virtual function table holds the pointers to all the virtual functions defined</span></div>
<div style="position:absolute;left:72.00px;top:303.84px" class="cls_006"><span class="cls_006">for this particular class. There's one table per class and each object of that class contains a hidden pointer</span></div>
<div style="position:absolute;left:72.00px;top:316.32px" class="cls_006"><span class="cls_006">to it—hidden because only the compiler knows the offset of the </span><span class="cls_020">vptr</span><span class="cls_006"> inside the object [</span><span class="cls_036">Lip96I</span><span class="cls_006">]. The</span></div>
<div style="position:absolute;left:72.00px;top:329.16px" class="cls_006"><span class="cls_006">compiler inserts code into the object constructor to initialize the </span><span class="cls_020">vptr</span><span class="cls_006"> properly.</span></div>
<div style="position:absolute;left:72.00px;top:355.44px" class="cls_006"><span class="cls_006">Virtual functions seem to inflict a performance cost in several ways:</span></div>
<div style="position:absolute;left:90.00px;top:382.32px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The </span><span class="cls_020">vptr</span><span class="cls_006"> must be initialized in the constructor.</span></div>
<div style="position:absolute;left:90.00px;top:394.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A virtual function is invoked via pointer indirection. We must fetch the pointer to the function</span></div>
<div style="position:absolute;left:108.00px;top:406.92px" class="cls_006"><span class="cls_006">table and then access the correct function offset.</span></div>
<div style="position:absolute;left:90.00px;top:419.28px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Inlining is a compile-time decision. The compiler cannot inline virtual functions whose resolution</span></div>
<div style="position:absolute;left:108.00px;top:431.28px" class="cls_006"><span class="cls_006">takes place at run-time.</span></div>
<div style="position:absolute;left:72.00px;top:457.44px" class="cls_006"><span class="cls_006">In fairness to C++, the first two items should not be considered a performance penalty. One way or another,</span></div>
<div style="position:absolute;left:72.00px;top:469.44px" class="cls_006"><span class="cls_006">you would have to pay that price even if you bent over backwards to avoid dynamic binding. The cost of</span></div>
<div style="position:absolute;left:72.00px;top:482.04px" class="cls_006"><span class="cls_006">setting the </span><span class="cls_020">vptr</span><span class="cls_006"> in the constructor is equivalent to initializing the type member in our </span><span class="cls_020">Bear</span></div>
<div style="position:absolute;left:72.00px;top:494.40px" class="cls_006"><span class="cls_006">implementation:</span></div>
<div style="position:absolute;left:72.00px;top:520.08px" class="cls_020"><span class="cls_020">class Bear : public ZooAnimal {</span></div>
<div style="position:absolute;left:96.00px;top:542.76px" class="cls_020"><span class="cls_020">Bear (const char *name) : myName(name), myType(BEAR) {}</span></div>
<div style="position:absolute;left:72.00px;top:565.44px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:591.12px" class="cls_006"><span class="cls_006">The cost of the second item, indirect function invocation, is equivalent to the switch statement logic</span></div>
<div style="position:absolute;left:72.00px;top:603.60px" class="cls_006"><span class="cls_006">necessary to distinguish </span><span class="cls_020">Bear::draw()</span><span class="cls_006"> from </span><span class="cls_020">Monkey::draw()</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:629.64px" class="cls_020"><span class="cls_020">switch (p->resolveType()) {</span></div>
<div style="position:absolute;left:78.00px;top:640.92px" class="cls_020"><span class="cls_020">case BEAR:</span></div>
<div style="position:absolute;left:90.00px;top:652.20px" class="cls_020"><span class="cls_020">( (Bear *) p)->draw();</span></div>
<div style="position:absolute;left:90.00px;top:663.60px" class="cls_020"><span class="cls_020">break;</span></div>
<div style="position:absolute;left:78.00px;top:674.88px" class="cls_020"><span class="cls_020">case MONKEY:</span></div>
<div style="position:absolute;left:90.00px;top:686.28px" class="cls_020"><span class="cls_020">((Monkey *) p)->draw();</span></div>
<div style="position:absolute;left:90.00px;top:697.56px" class="cls_020"><span class="cls_020">break;</span></div>
<div style="position:absolute;left:78.00px;top:708.84px" class="cls_020"><span class="cls_020">... // Handle all other animals currently in the zoo.</span></div>
<div style="position:absolute;left:72.00px;top:720.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:34932px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background042.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">The true cost of virtual functions then boils down to the third item only. As Meyers noted in Item 24 of</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">[</span><span class="cls_036">Mey96</span><span class="cls_006">], the inability to inline a virtual function is its biggest performance penalty.</span></div>
<div style="position:absolute;left:72.00px;top:109.08px" class="cls_006"><span class="cls_006">In some cases it is possible to resolve a virtual function invocation at compile-time [</span><span class="cls_036">Lip96I</span><span class="cls_006">], but this is the</span></div>
<div style="position:absolute;left:72.00px;top:121.20px" class="cls_006"><span class="cls_006">exception (this is discussed in more detail in </span><span class="cls_036">Chapters 8</span><span class="cls_006">-</span><span class="cls_036">10</span><span class="cls_006">). In the majority of virtual function invocations,</span></div>
<div style="position:absolute;left:72.00px;top:133.20px" class="cls_006"><span class="cls_006">resolution can happen only at run-time because the type of object whose function is being invoked cannot</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_006"><span class="cls_006">be determined at compile-time. That inability to resolve at compile-time interacts negatively with inlining.</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">Inlining is a compile-time decision that requires knowledge of the specific function. If you cannot</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">determine what function to invoke at compile-time (as is the case with a typical virtual function), you</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">cannot inline.</span></div>
<div style="position:absolute;left:72.00px;top:207.60px" class="cls_006"><span class="cls_006">Evaluating the performance penalty of a virtual function is equivalent to evaluating the penalty resulting</span></div>
<div style="position:absolute;left:72.00px;top:219.60px" class="cls_006"><span class="cls_006">from failure to inline that same function. This penalty does not have a fixed cost. It is dependent on the</span></div>
<div style="position:absolute;left:72.00px;top:231.72px" class="cls_006"><span class="cls_006">complexity of the function and the frequency with which it is invoked. On one end of the spectrum are the</span></div>
<div style="position:absolute;left:72.00px;top:243.84px" class="cls_006"><span class="cls_006">short functions that are invoked often. Those benefit the most from inlining, and failing to do so will result</span></div>
<div style="position:absolute;left:72.00px;top:255.84px" class="cls_006"><span class="cls_006">in a heavy penalty. At the other end of the spectrum are complex functions that are seldom invoked.</span></div>
<div style="position:absolute;left:72.00px;top:267.96px" class="cls_006"><span class="cls_006">Inlining and its performance implications are discussed in more detail in </span><span class="cls_036">Chapters 8</span><span class="cls_006">-</span><span class="cls_036">10</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:294.00px" class="cls_006"><span class="cls_006">When you throw in multiple inheritance and/or virtual inheritance, object creation involves an additional</span></div>
<div style="position:absolute;left:72.00px;top:306.60px" class="cls_006"><span class="cls_006">cost. This additional cost comes from having to set multiple </span><span class="cls_020">vptrs</span><span class="cls_006"> and added indirection of virtual</span></div>
<div style="position:absolute;left:72.00px;top:318.96px" class="cls_006"><span class="cls_006">function invocation. The object layout under multiple and virtual inheritance is an interesting issue, but the</span></div>
<div style="position:absolute;left:72.00px;top:330.96px" class="cls_006"><span class="cls_006">performance implications are minor and unlikely to have significant performance impact in typical code.</span></div>
<div style="position:absolute;left:72.00px;top:343.08px" class="cls_006"><span class="cls_006">These issues will not be pursued further here. An informative discussion of these issues appears in "Inside</span></div>
<div style="position:absolute;left:72.00px;top:355.08px" class="cls_006"><span class="cls_006">the Object Model" [</span><span class="cls_036">Lip96I</span><span class="cls_006">].</span></div>
<div style="position:absolute;left:72.00px;top:381.24px" class="cls_006"><span class="cls_006">If a specific virtual function creates a performance problem for you, what are your options? To eliminate a</span></div>
<div style="position:absolute;left:72.00px;top:393.24px" class="cls_006"><span class="cls_006">virtual call you must allow the compiler to resolve the function binding at compile-time. You bypass</span></div>
<div style="position:absolute;left:72.00px;top:405.36px" class="cls_006"><span class="cls_006">dynamic binding by either hard-coding your class choice or passing it as a template parameter. We will</span></div>
<div style="position:absolute;left:72.00px;top:417.48px" class="cls_006"><span class="cls_006">discuss these options next with a concrete example.</span></div>
<div style="position:absolute;left:72.00px;top:471.24px" class="cls_016"><span class="cls_016">Templates and Inheritance</span></div>
<div style="position:absolute;left:72.00px;top:502.56px" class="cls_006"><span class="cls_006">Virtual function calls that can be resolved only at run-time will inhibit inlining. At times, that may pose a</span></div>
<div style="position:absolute;left:72.00px;top:514.68px" class="cls_006"><span class="cls_006">performance problem that we must solve. Dynamic binding of a function call is a consequence of</span></div>
<div style="position:absolute;left:72.00px;top:526.68px" class="cls_006"><span class="cls_006">inheritance. One way to eliminate dynamic binding is to replace inheritance with a template-based design.</span></div>
<div style="position:absolute;left:72.00px;top:538.80px" class="cls_006"><span class="cls_006">Templates are more performance-friendly in the sense that they push the resolution step from run-time to</span></div>
<div style="position:absolute;left:72.00px;top:550.80px" class="cls_006"><span class="cls_006">compile-time. Compile-time, as far as we are concerned, is free.</span></div>
<div style="position:absolute;left:72.00px;top:576.96px" class="cls_006"><span class="cls_006">The design space for inheritance and templates has some overlap. We will discuss one such example.</span></div>
<div style="position:absolute;left:72.00px;top:603.00px" class="cls_006"><span class="cls_006">Suppose you wanted to develop a thread-safe string class that may be manipulated safely by concurrent</span></div>
<div style="position:absolute;left:72.00px;top:615.12px" class="cls_006"><span class="cls_006">threads in a Win32 environment [</span><span class="cls_036">BW97</span><span class="cls_006">]. In that environment you have a choice of multiple</span></div>
<div style="position:absolute;left:72.00px;top:627.12px" class="cls_006"><span class="cls_006">synchronization schemes such as critical section, mutex, and semaphores, just to name a few. You would</span></div>
<div style="position:absolute;left:72.00px;top:639.24px" class="cls_006"><span class="cls_006">like your thread-safe string to offer the flexibility to use any of those schemes, and at different times you</span></div>
<div style="position:absolute;left:72.00px;top:651.24px" class="cls_006"><span class="cls_006">may have a reason to prefer one scheme over another [</span><span class="cls_036">BW97</span><span class="cls_006">]. Inheritance would be a reasonable choice to</span></div>
<div style="position:absolute;left:72.00px;top:663.36px" class="cls_006"><span class="cls_006">capture the commonality among synchronization mechanisms.</span></div>
<div style="position:absolute;left:72.00px;top:689.88px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">Locker</span><span class="cls_006"> abstract base class will declare the common interface:</span></div>
<div style="position:absolute;left:72.00px;top:715.92px" class="cls_020"><span class="cls_020">class Locker {</span></div>
<div style="position:absolute;left:72.00px;top:727.20px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:738.48px" class="cls_020"><span class="cls_020">Locker() {}</span></div>
<div style="position:absolute;left:96.00px;top:749.88px" class="cls_020"><span class="cls_020">virtual ~Locker() {}</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">28</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:35784px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background043.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">virtual void lock() = 0;</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">virtual void unlock() = 0;</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:119.40px" class="cls_020"><span class="cls_020">CriticalSectionLock</span><span class="cls_006"> and </span><span class="cls_020">MutexLock</span><span class="cls_006"> will be derived from the </span><span class="cls_020">Locker</span><span class="cls_006"> base class:</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_020"><span class="cls_020">class CriticalSectionLock : public Locker {... };</span></div>
<div style="position:absolute;left:72.00px;top:156.72px" class="cls_020"><span class="cls_020">class MutexLock : public Locker {... };</span></div>
<div style="position:absolute;left:72.00px;top:182.40px" class="cls_006"><span class="cls_006">Because you prefer not to re-invent the wheel, you made the choice to derive the thread-safe string from</span></div>
<div style="position:absolute;left:72.00px;top:194.88px" class="cls_006"><span class="cls_006">the existing standard </span><span class="cls_020">string</span><span class="cls_006">. The remaining design choices are:</span></div>
<div style="position:absolute;left:90.00px;top:222.00px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Hard coding. You could derive three distinct classes from </span><span class="cls_020">string</span><span class="cls_006">: </span><span class="cls_020">CriticalSectionString,</span></div>
<div style="position:absolute;left:108.00px;top:234.84px" class="cls_020"><span class="cls_020">MutexString,</span><span class="cls_006"> and </span><span class="cls_020">SemaphoreString</span><span class="cls_006">, each class implementing its implied synchronization</span></div>
<div style="position:absolute;left:108.00px;top:247.08px" class="cls_006"><span class="cls_006">mechanism.</span></div>
<div style="position:absolute;left:90.00px;top:259.92px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Inheritance. You could derive a single </span><span class="cls_020">ThreadSafeString</span><span class="cls_006"> class that contains a pointer to a</span></div>
<div style="position:absolute;left:108.00px;top:272.76px" class="cls_020"><span class="cls_020">Locker</span><span class="cls_006"> object. Use polymorphism to select the particular synchronization mechanism at run-time.</span></div>
<div style="position:absolute;left:90.00px;top:285.72px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Templates. Create a template-based string class parameterized by the </span><span class="cls_020">Locker</span><span class="cls_006"> type.</span></div>
<div style="position:absolute;left:72.00px;top:312.12px" class="cls_006"><span class="cls_006">We will explore each design option in more detail.</span></div>
<div style="position:absolute;left:72.00px;top:338.28px" class="cls_023"><span class="cls_023">Hard Coding</span></div>
<div style="position:absolute;left:72.00px;top:367.56px" class="cls_006"><span class="cls_006">The standard </span><span class="cls_020">string</span><span class="cls_006"> class will serve as a base class. Each class derived from it makes a commitment to a</span></div>
<div style="position:absolute;left:72.00px;top:380.40px" class="cls_006"><span class="cls_006">specific synchronization mechanism. Take the </span><span class="cls_020">CriticalSectionString,</span><span class="cls_006"> for example:</span></div>
<div style="position:absolute;left:72.00px;top:406.32px" class="cls_020"><span class="cls_020">class CriticalSectionString : public string {</span></div>
<div style="position:absolute;left:72.00px;top:417.72px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:440.40px" class="cls_020"><span class="cls_020">int length();</span></div>
<div style="position:absolute;left:72.00px;top:451.68px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:462.96px" class="cls_020"><span class="cls_020">CriticalSectionLock cs;</span></div>
<div style="position:absolute;left:72.00px;top:474.36px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:497.04px" class="cls_020"><span class="cls_020">int CriticalSectionString::length()</span></div>
<div style="position:absolute;left:72.00px;top:508.32px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:519.60px" class="cls_020"><span class="cls_020">cs.lock()</span></div>
<div style="position:absolute;left:96.00px;top:531.00px" class="cls_020"><span class="cls_020">int len = string::length();</span></div>
<div style="position:absolute;left:96.00px;top:542.28px" class="cls_020"><span class="cls_020">cs.unlock();</span></div>
<div style="position:absolute;left:96.00px;top:564.96px" class="cls_020"><span class="cls_020">return len;</span></div>
<div style="position:absolute;left:72.00px;top:576.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:602.04px" class="cls_006"><span class="cls_006">You are getting the actual string length from the string parent class, but you are wrapping it in a critical</span></div>
<div style="position:absolute;left:72.00px;top:614.52px" class="cls_006"><span class="cls_006">section to protect the integrity of the computation. </span><span class="cls_020">MutexString</span><span class="cls_006"> and </span><span class="cls_020">SemaphoreString</span><span class="cls_006"> are</span></div>
<div style="position:absolute;left:72.00px;top:626.88px" class="cls_006"><span class="cls_006">implemented similarly using mutex and semaphore, respectively.</span></div>
<div style="position:absolute;left:72.00px;top:653.40px" class="cls_006"><span class="cls_006">This design choice has a performance advantage. Even though the </span><span class="cls_020">lock()</span><span class="cls_006"> and </span><span class="cls_020">unlock()</span><span class="cls_006"> methods are</span></div>
<div style="position:absolute;left:72.00px;top:665.76px" class="cls_006"><span class="cls_006">virtual functions, they can be resolved statically by a reasonable compiler. Each of the three thread-safe</span></div>
<div style="position:absolute;left:72.00px;top:677.76px" class="cls_006"><span class="cls_006">string classes has committed at compile-time to a particular synchronization class. The compiler, therefore,</span></div>
<div style="position:absolute;left:72.00px;top:690.36px" class="cls_006"><span class="cls_006">can bypass the dynamic binding and choose the correct </span><span class="cls_020">lock()</span><span class="cls_006"> or </span><span class="cls_020">unlock()</span><span class="cls_006"> method to use. More</span></div>
<div style="position:absolute;left:72.00px;top:702.72px" class="cls_006"><span class="cls_006">importantly, it allows the compiler to inline those calls. The downside to this design choice is that you</span></div>
<div style="position:absolute;left:72.00px;top:714.72px" class="cls_006"><span class="cls_006">need to write a separate string class for each synchronization flavor, which results in poor code reuse.</span></div>
<div style="position:absolute;left:72.00px;top:741.00px" class="cls_023"><span class="cls_023">Inheritance</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">29</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:36636px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background044.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">Implementing a separate string class for each synchronization mechanism is a pain. Alternatively, you can</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">factor out the synchronization choice into a constructor argument:</span></div>
<div style="position:absolute;left:72.00px;top:108.72px" class="cls_020"><span class="cls_020">class ThreadSafeString : public string {</span></div>
<div style="position:absolute;left:72.00px;top:120.00px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:131.40px" class="cls_020"><span class="cls_020">ThreadSafeString (const char *s, Locker *lockPtr)</span></div>
<div style="position:absolute;left:96.00px;top:142.68px" class="cls_020"><span class="cls_020">: string(s), pLock(lockPtr) {}</span></div>
<div style="position:absolute;left:96.00px;top:165.36px" class="cls_020"><span class="cls_020">int length();</span></div>
<div style="position:absolute;left:72.00px;top:176.64px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:188.04px" class="cls_020"><span class="cls_020">Locker *pLock;</span></div>
<div style="position:absolute;left:72.00px;top:199.32px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:225.60px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">length()</span><span class="cls_006"> method is now implemented as follows:</span></div>
<div style="position:absolute;left:72.00px;top:251.52px" class="cls_020"><span class="cls_020">int ThreadSafeString::length()</span></div>
<div style="position:absolute;left:72.00px;top:262.80px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:274.08px" class="cls_020"><span class="cls_020">pLock->lock()</span></div>
<div style="position:absolute;left:96.00px;top:285.48px" class="cls_020"><span class="cls_020">int len = string::length();</span></div>
<div style="position:absolute;left:96.00px;top:296.76px" class="cls_020"><span class="cls_020">pLock->unlock();</span></div>
<div style="position:absolute;left:96.00px;top:319.44px" class="cls_020"><span class="cls_020">return len;</span></div>
<div style="position:absolute;left:72.00px;top:330.72px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:357.00px" class="cls_006"><span class="cls_006">This class can use all available synchronization schemes depending on the </span><span class="cls_020">Locker</span><span class="cls_006"> pointer given to its</span></div>
<div style="position:absolute;left:72.00px;top:369.24px" class="cls_006"><span class="cls_006">constructor. You can use a critical section, as in:</span></div>
<div style="position:absolute;left:72.00px;top:394.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:406.32px" class="cls_020"><span class="cls_020">CriticalSectionLock cs;</span></div>
<div style="position:absolute;left:96.00px;top:417.60px" class="cls_020"><span class="cls_020">ThreadSafeString csString("Hello", &cs);</span></div>
<div style="position:absolute;left:72.00px;top:440.28px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:465.84px" class="cls_006"><span class="cls_006">or you may elect to go with a mutex lock, as in:</span></div>
<div style="position:absolute;left:72.00px;top:491.64px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:503.04px" class="cls_020"><span class="cls_020">MutexLock mtx;</span></div>
<div style="position:absolute;left:96.00px;top:514.32px" class="cls_020"><span class="cls_020">ThreadSafeString csString("Hello", &mtx);</span></div>
<div style="position:absolute;left:72.00px;top:537.00px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:562.68px" class="cls_006"><span class="cls_006">This implementation is more compact than the previous one. It does suffer a performance penalty: The</span></div>
<div style="position:absolute;left:72.00px;top:575.28px" class="cls_020"><span class="cls_020">lock()</span><span class="cls_006"> and </span><span class="cls_020">unlock()</span><span class="cls_006"> virtual calls can only be resolved at execution time and consequently cannot be</span></div>
<div style="position:absolute;left:72.00px;top:587.52px" class="cls_006"><span class="cls_006">inlined.</span></div>
<div style="position:absolute;left:72.00px;top:613.80px" class="cls_023"><span class="cls_023">Templates</span></div>
<div style="position:absolute;left:72.00px;top:642.60px" class="cls_006"><span class="cls_006">The template-based design combines the best of both worlds—reuse and efficiency. The</span></div>
<div style="position:absolute;left:72.00px;top:655.20px" class="cls_020"><span class="cls_020">ThreadSafeString</span><span class="cls_006"> is implemented as a template parameterized by the </span><span class="cls_020">Locker</span><span class="cls_006"> template argument:</span></div>
<div style="position:absolute;left:72.00px;top:681.12px" class="cls_020"><span class="cls_020">template &lt;class LOCKER></span></div>
<div style="position:absolute;left:72.00px;top:692.40px" class="cls_020"><span class="cls_020">class ThreadSafeString : public string {</span></div>
<div style="position:absolute;left:72.00px;top:703.80px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:715.08px" class="cls_020"><span class="cls_020">ThreadSafeString(const char *s) : string(s) {}</span></div>
<div style="position:absolute;left:96.00px;top:737.76px" class="cls_020"><span class="cls_020">int length();</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">30</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:37488px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background045.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">LOCKER lock;</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:118.80px" class="cls_006"><span class="cls_006">The length method implementation is similar to the previous ones:</span></div>
<div style="position:absolute;left:72.00px;top:144.60px" class="cls_020"><span class="cls_020">template &lt;class LOCKER></span></div>
<div style="position:absolute;left:72.00px;top:156.00px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:167.28px" class="cls_020"><span class="cls_020">int ThreadSafeString&lt;LOCKER>::length()</span></div>
<div style="position:absolute;left:72.00px;top:178.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:189.96px" class="cls_020"><span class="cls_020">lock.lock();</span></div>
<div style="position:absolute;left:96.00px;top:201.24px" class="cls_020"><span class="cls_020">int len = string::length();</span></div>
<div style="position:absolute;left:96.00px;top:212.64px" class="cls_020"><span class="cls_020">lock.unlock();</span></div>
<div style="position:absolute;left:96.00px;top:235.20px" class="cls_020"><span class="cls_020">return len;</span></div>
<div style="position:absolute;left:72.00px;top:246.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:272.76px" class="cls_006"><span class="cls_006">If you want critical section protection, you will instantiate the template with a </span><span class="cls_020">CriticalSectionLock</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:298.68px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:310.08px" class="cls_020"><span class="cls_020">ThreadSafeString &lt;CriticalSectionLock> csString = "hello";</span></div>
<div style="position:absolute;left:72.00px;top:332.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:358.32px" class="cls_006"><span class="cls_006">or you may go with a mutex:</span></div>
<div style="position:absolute;left:72.00px;top:384.12px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:395.40px" class="cls_020"><span class="cls_020">ThreadSafeString &lt;MutexLock> mtxString = "hello";</span></div>
<div style="position:absolute;left:72.00px;top:418.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:444.24px" class="cls_006"><span class="cls_006">This design also provides a relief from the virtual function calls to </span><span class="cls_020">lock()</span><span class="cls_006"> and </span><span class="cls_020">unlock()</span><span class="cls_006">. The</span></div>
<div style="position:absolute;left:72.00px;top:457.08px" class="cls_006"><span class="cls_006">declaration of a </span><span class="cls_020">ThreadSafeString</span><span class="cls_006"> selects a particular type of synchronization upon template</span></div>
<div style="position:absolute;left:72.00px;top:469.32px" class="cls_006"><span class="cls_006">instantiation time. Just like hard coding, this enables the compiler to resolve the virtual calls and inline</span></div>
<div style="position:absolute;left:72.00px;top:481.44px" class="cls_006"><span class="cls_006">them.</span></div>
<div style="position:absolute;left:72.00px;top:507.48px" class="cls_006"><span class="cls_006">As you can see, templates can make a positive performance contribution by pushing computations out of</span></div>
<div style="position:absolute;left:72.00px;top:519.60px" class="cls_006"><span class="cls_006">the execution-time and into compile-time, enabling inlining in the process. If you think of templates as</span></div>
<div style="position:absolute;left:72.00px;top:531.72px" class="cls_006"><span class="cls_006">glorified macros, you will definitely change your mind after reading Todd Veldhuizen's article on</span></div>
<div style="position:absolute;left:72.00px;top:543.72px" class="cls_006"><span class="cls_006">expression templates in "C++ Gems" [</span><span class="cls_036">Lip96C</span><span class="cls_006">].</span></div>
<div style="position:absolute;left:72.00px;top:597.48px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:629.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The cost of a virtual function stems from the inability to inline calls that are dynamically bound at</span></div>
<div style="position:absolute;left:108.00px;top:641.16px" class="cls_006"><span class="cls_006">run-time. The only potential efficiency issue is the speed gained from inlining if there is any.</span></div>
<div style="position:absolute;left:108.00px;top:653.28px" class="cls_006"><span class="cls_006">Inlining efficiency is not an issue in the case of functions whose cost is not dominated by call and</span></div>
<div style="position:absolute;left:108.00px;top:665.28px" class="cls_006"><span class="cls_006">return overhead.</span></div>
<div style="position:absolute;left:90.00px;top:677.64px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Templates are more performance-friendly than inheritance hierarchies. They push type resolution</span></div>
<div style="position:absolute;left:108.00px;top:689.76px" class="cls_006"><span class="cls_006">to compile-time, which we consider to be free.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">31</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:38340px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background046.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 4. The Return Value Optimization</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">Anytime you can skip the creation and destruction of an object, you are looking at a performance gain. In</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">this chapter we will discuss an optimization often performed by compilers to speed up your source code by</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">transforming it and eliminating object creation. This optimization is referred to as the </span><span class="cls_036">Return Value</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_036"><span class="cls_036">Optimization</span><span class="cls_006"> (RVO). Prior to delving into the RVO we need to understand how return-by-value works. We</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">will walk through it with a simple example.</span></div>
<div style="position:absolute;left:72.00px;top:219.96px" class="cls_016"><span class="cls_016">The Mechanics of Return-by-Value</span></div>
<div style="position:absolute;left:72.00px;top:251.76px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">Complex</span><span class="cls_006"> class implements a representation for complex numbers:</span></div>
<div style="position:absolute;left:72.00px;top:277.80px" class="cls_020"><span class="cls_020">class Complex</span></div>
<div style="position:absolute;left:72.00px;top:289.08px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:300.36px" class="cls_020"><span class="cls_020">// Complex addition operator</span></div>
<div style="position:absolute;left:96.00px;top:311.76px" class="cls_020"><span class="cls_020">friend Complex operator+(const Complex&, const Complex&);</span></div>
<div style="position:absolute;left:72.00px;top:323.04px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:334.44px" class="cls_020"><span class="cls_020">// Default constructor.</span></div>
<div style="position:absolute;left:96.00px;top:345.72px" class="cls_020"><span class="cls_020">// Value defaults to 0 unless otherwise specified.</span></div>
<div style="position:absolute;left:96.00px;top:357.00px" class="cls_020"><span class="cls_020">Complex (double r = 0.0, double i = 0.0) : real (r),  imag (i) {}</span></div>
<div style="position:absolute;left:96.00px;top:379.68px" class="cls_020"><span class="cls_020">// Copy constructor</span></div>
<div style="position:absolute;left:96.00px;top:391.08px" class="cls_020"><span class="cls_020">Complex (const Complex& c) : real (c.real), imag (c.imag) {}</span></div>
<div style="position:absolute;left:96.00px;top:413.64px" class="cls_020"><span class="cls_020">// Assignment operator</span></div>
<div style="position:absolute;left:96.00px;top:425.04px" class="cls_020"><span class="cls_020">Complex& operator= (const Complex& c);</span></div>
<div style="position:absolute;left:96.00px;top:447.72px" class="cls_020"><span class="cls_020">~Complex() {}</span></div>
<div style="position:absolute;left:72.00px;top:459.00px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:470.28px" class="cls_020"><span class="cls_020">double real;</span></div>
<div style="position:absolute;left:96.00px;top:481.68px" class="cls_020"><span class="cls_020">double imag;</span></div>
<div style="position:absolute;left:72.00px;top:492.96px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:519.24px" class="cls_006"><span class="cls_006">The</span><span class="cls_020"> addition operator</span><span class="cls_006"> returns a </span><span class="cls_020">Complex</span><span class="cls_006"> object by value, as in:</span></div>
<div style="position:absolute;left:72.00px;top:545.16px" class="cls_020"><span class="cls_020">Complex operator+ (const Complex& a,  const Complex& b)</span></div>
<div style="position:absolute;left:72.00px;top:556.44px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:567.84px" class="cls_020"><span class="cls_020">Complex retVal;</span></div>
<div style="position:absolute;left:96.00px;top:590.40px" class="cls_020"><span class="cls_020">retVal.real = a.real + b.real;</span></div>
<div style="position:absolute;left:96.00px;top:601.80px" class="cls_020"><span class="cls_020">retVal.imag = a.imag + b.imag;</span></div>
<div style="position:absolute;left:96.00px;top:624.48px" class="cls_020"><span class="cls_020">return retVal;</span></div>
<div style="position:absolute;left:72.00px;top:635.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:661.92px" class="cls_006"><span class="cls_006">Suppose </span><span class="cls_020">c1</span><span class="cls_006">, </span><span class="cls_020">c2</span><span class="cls_006">, and </span><span class="cls_020">c3</span><span class="cls_006"> are </span><span class="cls_020">Complex</span><span class="cls_006"> and we execute</span></div>
<div style="position:absolute;left:72.00px;top:687.84px" class="cls_020"><span class="cls_020">c3 = c1 + c2;</span></div>
<div style="position:absolute;left:72.00px;top:714.12px" class="cls_006"><span class="cls_006">How do we get the value of </span><span class="cls_020">c1 + c2</span><span class="cls_006"> into </span><span class="cls_020">c3</span><span class="cls_006">? One popular technique [</span><span class="cls_036">Lip96I</span><span class="cls_006">] used by compilers is to</span></div>
<div style="position:absolute;left:72.00px;top:726.84px" class="cls_006"><span class="cls_006">create a temporary </span><span class="cls_020">__result</span><span class="cls_006"> object and pass it into </span><span class="cls_020">Complex::operator+()</span><span class="cls_006"> as a third argument. It is</span></div>
<div style="position:absolute;left:72.00px;top:739.20px" class="cls_006"><span class="cls_006">passed by reference. So the compiler rewrites</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">32</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:39192px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background047.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">Complex& Complex::operator+ (const complex& c1, const Complex& c2)</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:130.20px" class="cls_006"><span class="cls_006">into a slightly different function:</span></div>
<div style="position:absolute;left:72.00px;top:156.00px" class="cls_020"><span class="cls_020">void Complex_Add</span></div>
<div style="position:absolute;left:179.98px;top:156.00px" class="cls_020"><span class="cls_020">(const Complex& __result,</span></div>
<div style="position:absolute;left:185.98px;top:167.28px" class="cls_020"><span class="cls_020">const Complex& c1,</span></div>
<div style="position:absolute;left:185.98px;top:178.56px" class="cls_020"><span class="cls_020">const Complex& c2)</span></div>
<div style="position:absolute;left:72.00px;top:189.96px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:212.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:238.20px" class="cls_006"><span class="cls_006">Now the original source statement</span></div>
<div style="position:absolute;left:72.00px;top:264.00px" class="cls_020"><span class="cls_020">c3 = c1 + c2;</span></div>
<div style="position:absolute;left:72.00px;top:289.56px" class="cls_006"><span class="cls_006">is transformed into (pseudocode):</span></div>
<div style="position:absolute;left:72.00px;top:315.36px" class="cls_020"><span class="cls_020">struct Complex __tempResult;</span></div>
<div style="position:absolute;left:311.96px;top:315.36px" class="cls_020"><span class="cls_020">// Storage. No constructor here.</span></div>
<div style="position:absolute;left:72.00px;top:326.76px" class="cls_020"><span class="cls_020">Complex_Add(__tempResult,c1,c2);</span></div>
<div style="position:absolute;left:311.96px;top:326.76px" class="cls_020"><span class="cls_020">// All arguments passed by</span></div>
<div style="position:absolute;left:72.00px;top:338.04px" class="cls_020"><span class="cls_020">reference.</span></div>
<div style="position:absolute;left:72.00px;top:349.32px" class="cls_020"><span class="cls_020">c3 = __tempResult;</span></div>
<div style="position:absolute;left:311.96px;top:349.32px" class="cls_020"><span class="cls_020">// Feed result back into</span></div>
<div style="position:absolute;left:311.96px;top:360.72px" class="cls_020"><span class="cls_020">// left-hand-side.</span></div>
<div style="position:absolute;left:72.00px;top:386.40px" class="cls_006"><span class="cls_006">This return-by-value implementation opens up an optimization opportunity by eliminating the local object</span></div>
<div style="position:absolute;left:72.00px;top:399.00px" class="cls_020"><span class="cls_020">RetVal</span><span class="cls_006"> (inside </span><span class="cls_020">operator+()</span><span class="cls_006">) and computing the return value directly into the </span><span class="cls_020">__tempResult</span></div>
<div style="position:absolute;left:72.00px;top:411.24px" class="cls_006"><span class="cls_006">temporary object. This is the Return Value Optimization.</span></div>
<div style="position:absolute;left:72.00px;top:465.12px" class="cls_016"><span class="cls_016">The Return Value Optimization</span></div>
<div style="position:absolute;left:72.00px;top:496.92px" class="cls_006"><span class="cls_006">Without any optimization, the compiler-generated (pseudo) code for </span><span class="cls_020">Complex_Add()</span><span class="cls_006"> is</span></div>
<div style="position:absolute;left:72.00px;top:522.84px" class="cls_020"><span class="cls_020">void Complex_Add(const Complex& __tempResult,</span></div>
<div style="position:absolute;left:155.98px;top:534.12px" class="cls_020"><span class="cls_020">const Complex& c1,</span></div>
<div style="position:absolute;left:155.98px;top:545.52px" class="cls_020"><span class="cls_020">const Complex& c2)</span></div>
<div style="position:absolute;left:72.00px;top:556.80px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:568.20px" class="cls_020"><span class="cls_020">struct Complex retVal;</span></div>
<div style="position:absolute;left:96.00px;top:579.48px" class="cls_020"><span class="cls_020">retVal.Complex::Complex();</span></div>
<div style="position:absolute;left:371.95px;top:579.48px" class="cls_020"><span class="cls_020">// Construct retVal</span></div>
<div style="position:absolute;left:96.00px;top:602.16px" class="cls_020"><span class="cls_020">retVal.real = a.real + b.real;</span></div>
<div style="position:absolute;left:96.00px;top:613.44px" class="cls_020"><span class="cls_020">retVal.imag = a.imag + b.imag;</span></div>
<div style="position:absolute;left:96.00px;top:636.12px" class="cls_020"><span class="cls_020">__tempResult.Complex::Complex(retVal);// Copy-construct</span></div>
<div style="position:absolute;left:371.95px;top:647.40px" class="cls_020"><span class="cls_020">// __tempResult</span></div>
<div style="position:absolute;left:96.00px;top:658.80px" class="cls_020"><span class="cls_020">retVal.Complex::~Complex();</span></div>
<div style="position:absolute;left:371.95px;top:658.80px" class="cls_020"><span class="cls_020">// Destroy retVal</span></div>
<div style="position:absolute;left:96.00px;top:670.08px" class="cls_020"><span class="cls_020">return;</span></div>
<div style="position:absolute;left:72.00px;top:681.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:707.64px" class="cls_006"><span class="cls_006">The compiler can optimize </span><span class="cls_020">Complex_Add()</span><span class="cls_006"> by eliminating the local object </span><span class="cls_020">retVal</span><span class="cls_006"> and replacing it</span></div>
<div style="position:absolute;left:72.00px;top:720.36px" class="cls_006"><span class="cls_006">with </span><span class="cls_020">__tempResult</span><span class="cls_006">. This is the Return Value Optimization:</span></div>
<div style="position:absolute;left:72.00px;top:746.40px" class="cls_020"><span class="cls_020">void Complex_Add (const Complex& __tempResult,</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">33</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:40044px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background048.jpg" width=595 height=842></div>
<div style="position:absolute;left:161.98px;top:70.56px" class="cls_020"><span class="cls_020">const Complex& c1,</span></div>
<div style="position:absolute;left:161.98px;top:81.84px" class="cls_020"><span class="cls_020">const Complex& c2)</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">__tempResult.Complex::Complex();</span></div>
<div style="position:absolute;left:383.94px;top:104.52px" class="cls_020"><span class="cls_020">// Construct</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_020"><span class="cls_020">__tempResult</span></div>
<div style="position:absolute;left:96.00px;top:127.20px" class="cls_020"><span class="cls_020">__tempResult.real = a.real + b.real;</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">__tempResult.imag = a.imag + b.imag;</span></div>
<div style="position:absolute;left:96.00px;top:149.88px" class="cls_020"><span class="cls_020">return;</span></div>
<div style="position:absolute;left:72.00px;top:161.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:187.44px" class="cls_006"><span class="cls_006">The RVO eliminated the local </span><span class="cls_020">retVal</span><span class="cls_006"> object and therefore saved us a constructor as well as a destructor</span></div>
<div style="position:absolute;left:72.00px;top:199.68px" class="cls_006"><span class="cls_006">computation.</span></div>
<div style="position:absolute;left:72.00px;top:225.72px" class="cls_006"><span class="cls_006">To get a numerical feel for all this efficiency discussion, we measured the impact of RVO on execution</span></div>
<div style="position:absolute;left:72.00px;top:238.32px" class="cls_006"><span class="cls_006">speed. We coded two versions of </span><span class="cls_020">operator+()</span><span class="cls_006">, one of which was optimized and the other not. The</span></div>
<div style="position:absolute;left:72.00px;top:250.68px" class="cls_006"><span class="cls_006">measured code consisted of a million loop iterations:</span></div>
<div style="position:absolute;left:72.00px;top:276.36px" class="cls_020"><span class="cls_020">int main ()</span></div>
<div style="position:absolute;left:72.00px;top:287.64px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:299.04px" class="cls_020"><span class="cls_020">Complex a(1,0);</span></div>
<div style="position:absolute;left:96.00px;top:310.32px" class="cls_020"><span class="cls_020">Complex b(2,0);</span></div>
<div style="position:absolute;left:96.00px;top:321.60px" class="cls_020"><span class="cls_020">Complex c;</span></div>
<div style="position:absolute;left:96.00px;top:344.28px" class="cls_020"><span class="cls_020">// Begin timing here</span></div>
<div style="position:absolute;left:96.00px;top:355.68px" class="cls_020"><span class="cls_020">for (int</span></div>
<div style="position:absolute;left:161.98px;top:355.68px" class="cls_020"><span class="cls_020">i = 1000000; i > 0; i--) {</span></div>
<div style="position:absolute;left:119.99px;top:366.96px" class="cls_020"><span class="cls_020">c = a + b;</span></div>
<div style="position:absolute;left:96.00px;top:378.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:389.64px" class="cls_020"><span class="cls_020">// Stop timing here</span></div>
<div style="position:absolute;left:72.00px;top:400.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:426.72px" class="cls_006"><span class="cls_006">The second version, without RVO, executed in 1.89 seconds. The first version, with RVO applied was</span></div>
<div style="position:absolute;left:72.00px;top:438.72px" class="cls_006"><span class="cls_006">much faster—1.30 seconds (</span><span class="cls_036">Figure 4.1</span><span class="cls_006">).</span></div>
<div style="position:absolute;left:214.68px;top:464.88px" class="cls_021"><span class="cls_021">Figure 4.1. The speed-up of RVO.</span></div>
<div style="position:absolute;left:72.00px;top:729.84px" class="cls_006"><span class="cls_006">Compiler optimizations, naturally, must preserve the correctness of the original computation. In the case of</span></div>
<div style="position:absolute;left:72.00px;top:741.96px" class="cls_006"><span class="cls_006">the RVO, this is not always easy. Since the RVO is not mandatory, the compiler will not perform it on</span></div>
<div style="position:absolute;left:72.00px;top:754.44px" class="cls_006"><span class="cls_006">complicated functions. For example, if the function has multiple </span><span class="cls_020">return</span><span class="cls_006"> statements returning objects of</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">34</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:40896px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background049.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">different names, RVO will not be applied. You must return the same named object to have a chance at the</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">RVO.</span></div>
<div style="position:absolute;left:72.00px;top:109.56px" class="cls_006"><span class="cls_006">One compiler we tested refused to apply the RVO to this particular version of </span><span class="cls_020">operator+:</span></div>
<div style="position:absolute;left:72.00px;top:135.48px" class="cls_020"><span class="cls_020">Complex operator+ (const Complex& a,  const Complex& b)</span></div>
<div style="position:absolute;left:72.00px;top:146.88px" class="cls_020"><span class="cls_020">// operator+ version 1.</span></div>
<div style="position:absolute;left:72.00px;top:158.16px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:169.44px" class="cls_020"><span class="cls_020">Complex retVal;</span></div>
<div style="position:absolute;left:96.00px;top:180.84px" class="cls_020"><span class="cls_020">retVal.real = a.real + b.real;</span></div>
<div style="position:absolute;left:96.00px;top:192.12px" class="cls_020"><span class="cls_020">retVal.imag = a.imag + b.imag;</span></div>
<div style="position:absolute;left:96.00px;top:203.52px" class="cls_020"><span class="cls_020">return retVal;</span></div>
<div style="position:absolute;left:72.00px;top:214.80px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:240.36px" class="cls_006"><span class="cls_006">It did, however, apply the RVO to this version:</span></div>
<div style="position:absolute;left:72.00px;top:266.16px" class="cls_020"><span class="cls_020">Complex operator+ (const Complex& a, const Complex& b)</span></div>
<div style="position:absolute;left:72.00px;top:277.56px" class="cls_020"><span class="cls_020">// operator+ version 2.</span></div>
<div style="position:absolute;left:72.00px;top:288.84px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:300.24px" class="cls_020"><span class="cls_020">double r = a.real + b.real;</span></div>
<div style="position:absolute;left:96.00px;top:311.52px" class="cls_020"><span class="cls_020">double i = a.imag + b.imag;</span></div>
<div style="position:absolute;left:96.00px;top:334.20px" class="cls_020"><span class="cls_020">return Complex (r,i);</span></div>
<div style="position:absolute;left:72.00px;top:345.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:371.76px" class="cls_006"><span class="cls_006">We speculated that the difference may lie in the fact that Version 1 used a named variable </span><span class="cls_020">(retVal)</span><span class="cls_006"> as a</span></div>
<div style="position:absolute;left:72.00px;top:384.00px" class="cls_006"><span class="cls_006">return value whereas Version 2 used an unnamed variable. Version 2 used a constructor call in the return</span></div>
<div style="position:absolute;left:72.00px;top:396.12px" class="cls_006"><span class="cls_006">statement but never named it. It may be the case that this particular compiler implementation chose to</span></div>
<div style="position:absolute;left:72.00px;top:408.12px" class="cls_006"><span class="cls_006">avoid optimizing away named variables.</span></div>
<div style="position:absolute;left:72.00px;top:434.76px" class="cls_006"><span class="cls_006">Our speculation was boosted by some additional evidence. We tested two more versions of </span><span class="cls_020">operator+</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:460.68px" class="cls_020"><span class="cls_020">Complex operator+ (const Complex& a, const Complex& b) // operator+</span></div>
<div style="position:absolute;left:401.94px;top:471.96px" class="cls_020"><span class="cls_020">// version 3.</span></div>
<div style="position:absolute;left:72.00px;top:483.36px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:494.64px" class="cls_020"><span class="cls_020">Complex retVal (a.real + b.real, a.imag + b.imag);</span></div>
<div style="position:absolute;left:96.00px;top:517.32px" class="cls_020"><span class="cls_020">return retVal;</span></div>
<div style="position:absolute;left:72.00px;top:528.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:554.28px" class="cls_006"><span class="cls_006">and</span></div>
<div style="position:absolute;left:72.00px;top:580.08px" class="cls_020"><span class="cls_020">Complex operator+ (const Complex& a, const Complex& b)</span></div>
<div style="position:absolute;left:407.94px;top:580.08px" class="cls_020"><span class="cls_020">// operator+</span></div>
<div style="position:absolute;left:407.94px;top:591.36px" class="cls_020"><span class="cls_020">// version 4.</span></div>
<div style="position:absolute;left:72.00px;top:602.64px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:614.04px" class="cls_020"><span class="cls_020">return Complex (a.real + b.real, a.imag + b.imag);</span></div>
<div style="position:absolute;left:72.00px;top:625.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:651.00px" class="cls_006"><span class="cls_006">As speculated, the RVO was applied to Version 4 but not to Version 3.</span></div>
<div style="position:absolute;left:72.00px;top:677.16px" class="cls_006"><span class="cls_006">In addition, you must also define a copy constructor to "turn on" the Return Value Optimization. If the</span></div>
<div style="position:absolute;left:72.00px;top:689.16px" class="cls_006"><span class="cls_006">class involved does not have a copy constructor defined, the RVO is quietly turned off.</span></div>
<div style="position:absolute;left:72.00px;top:743.04px" class="cls_016"><span class="cls_016">Computational Constructors</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">35</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:41748px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background050.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">When the compiler fails to apply the RVO, you can give it a gentle nudge in the form of the computational</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">constructor (originally attributed to J. Shopiro [</span><span class="cls_036">Car92</span><span class="cls_006">, </span><span class="cls_036">Lip96I</span><span class="cls_006">].) Our compiler did not apply the RVO to</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">Version 1:</span></div>
<div style="position:absolute;left:72.00px;top:120.84px" class="cls_020"><span class="cls_020">Complex operator+ (const Complex& a,  const Complex& b)</span></div>
<div style="position:absolute;left:84.00px;top:132.12px" class="cls_020"><span class="cls_020">// operator+ version 1.</span></div>
<div style="position:absolute;left:72.00px;top:143.40px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:154.80px" class="cls_020"><span class="cls_020">Complex retVal;</span></div>
<div style="position:absolute;left:96.00px;top:177.48px" class="cls_020"><span class="cls_020">retVal.real = a.real + b.real;</span></div>
<div style="position:absolute;left:96.00px;top:188.76px" class="cls_020"><span class="cls_020">retVal.imag = a.imag + b.imag;</span></div>
<div style="position:absolute;left:96.00px;top:211.44px" class="cls_020"><span class="cls_020">return retVal;</span></div>
<div style="position:absolute;left:72.00px;top:222.72px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:249.00px" class="cls_006"><span class="cls_006">This implementation created a default </span><span class="cls_020">Complex</span><span class="cls_006"> object and deferred setting its member fields. Later it</span></div>
<div style="position:absolute;left:72.00px;top:261.72px" class="cls_006"><span class="cls_006">filled in the member data with information supplied by the input objects. The production of the </span><span class="cls_020">Complex</span></div>
<div style="position:absolute;left:72.00px;top:274.56px" class="cls_020"><span class="cls_020">retVal</span><span class="cls_006"> object is spread over multiple distinct steps. The computational constructor collapses these steps</span></div>
<div style="position:absolute;left:72.00px;top:286.80px" class="cls_006"><span class="cls_006">into a single call and eliminates the named local variable:</span></div>
<div style="position:absolute;left:72.00px;top:312.60px" class="cls_020"><span class="cls_020">Complex operator+ (const Complex& a, const Complex& b)</span></div>
<div style="position:absolute;left:407.94px;top:312.60px" class="cls_020"><span class="cls_020">// operator+</span></div>
<div style="position:absolute;left:407.94px;top:323.88px" class="cls_020"><span class="cls_020">// version 5.</span></div>
<div style="position:absolute;left:72.00px;top:335.16px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:346.56px" class="cls_020"><span class="cls_020">return Complex (a, b);</span></div>
<div style="position:absolute;left:72.00px;top:357.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:384.12px" class="cls_006"><span class="cls_006">The computational constructor used in Version 5 constructs a new </span><span class="cls_020">Complex</span><span class="cls_006"> object by adding its two input</span></div>
<div style="position:absolute;left:72.00px;top:396.36px" class="cls_006"><span class="cls_006">arguments:</span></div>
<div style="position:absolute;left:72.00px;top:422.04px" class="cls_020"><span class="cls_020">Complex::Complex (const Complex& x, const Complex& y)</span></div>
<div style="position:absolute;left:96.00px;top:433.44px" class="cls_020"><span class="cls_020">: real (x.real+y.real),  imag (x.imag + y.imag)</span></div>
<div style="position:absolute;left:72.00px;top:444.72px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:456.00px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:481.80px" class="cls_006"><span class="cls_006">Now a compiler is more likely to apply the RVO to Version 5 than to Version 1 of the addition operator. If</span></div>
<div style="position:absolute;left:72.00px;top:493.80px" class="cls_006"><span class="cls_006">you wanted to apply the same idea to the other arithmetic operators, you would have to add a third</span></div>
<div style="position:absolute;left:72.00px;top:505.92px" class="cls_006"><span class="cls_006">argument to distinguish the signatures of the computational constructors for addition, subtraction,</span></div>
<div style="position:absolute;left:72.00px;top:517.92px" class="cls_006"><span class="cls_006">multiplication, and division. This is the criticism against the computational constructor: It bends over</span></div>
<div style="position:absolute;left:72.00px;top:530.04px" class="cls_006"><span class="cls_006">backwards for the sake of efficiency and introduces "unnatural" constructors. Our take on this debate is</span></div>
<div style="position:absolute;left:72.00px;top:542.16px" class="cls_006"><span class="cls_006">that there are times and places where performance issues overwhelm all other issues. This issue is context-</span></div>
<div style="position:absolute;left:72.00px;top:554.16px" class="cls_006"><span class="cls_006">sensitive and does not have one right answer.</span></div>
<div style="position:absolute;left:72.00px;top:608.04px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:639.60px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   If you must return an object by value, the Return Value Optimization will help performance by</span></div>
<div style="position:absolute;left:108.00px;top:651.60px" class="cls_006"><span class="cls_006">eliminating the need for creation and destruction of a local object.</span></div>
<div style="position:absolute;left:90.00px;top:663.96px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The application of the RVO is up to the discretion of the compiler implementation. You need to</span></div>
<div style="position:absolute;left:108.00px;top:676.08px" class="cls_006"><span class="cls_006">consult your compiler documentation or experiment to find if and when RVO is applied.</span></div>
<div style="position:absolute;left:90.00px;top:688.32px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   You will have a better shot at RVO by deploying the computational constructor.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">36</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:42600px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background051.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 5. Temporaries</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">In the large collection of performance issues, not all issues are of equal weight. The significance of a</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">performance item is directly proportional to its cost and the frequency with which it appears in a typical</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">program. It is conceivable that you could write highly efficient C++ code without having a clue about the</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">intricacies of virtual inheritance and the (small) influence it has on execution speed. The generation of</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">temporary objects, on the other hand, definitely does not belong in the category of potentially low-impact</span></div>
<div style="position:absolute;left:72.00px;top:178.32px" class="cls_006"><span class="cls_006">concepts. The likelihood of writing efficient code is very small unless you understand the origins of</span></div>
<div style="position:absolute;left:72.00px;top:190.32px" class="cls_006"><span class="cls_006">temporary objects, their cost, and how to eliminate them when you can.</span></div>
<div style="position:absolute;left:72.00px;top:216.36px" class="cls_006"><span class="cls_006">Temporary objects may come as a surprise to new C++ developers, as the objects are silently generated by</span></div>
<div style="position:absolute;left:72.00px;top:228.48px" class="cls_006"><span class="cls_006">the compiler. They do not appear in the source code. It takes a trained eye to detect code fragments that</span></div>
<div style="position:absolute;left:72.00px;top:240.60px" class="cls_006"><span class="cls_006">will cause the compiler to insert temporary objects "under the covers."</span></div>
<div style="position:absolute;left:72.00px;top:266.64px" class="cls_006"><span class="cls_006">Next, we enumerate a few examples where temporary objects are likely to pop up in compiler-generated</span></div>
<div style="position:absolute;left:72.00px;top:278.76px" class="cls_006"><span class="cls_006">code.</span></div>
<div style="position:absolute;left:72.00px;top:332.52px" class="cls_016"><span class="cls_016">Object Definition</span></div>
<div style="position:absolute;left:72.00px;top:364.32px" class="cls_006"><span class="cls_006">Say that class </span><span class="cls_020">Rational</span><span class="cls_006"> is declared as follows:</span></div>
<div style="position:absolute;left:72.00px;top:390.24px" class="cls_020"><span class="cls_020">class Rational</span></div>
<div style="position:absolute;left:72.00px;top:401.64px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:412.92px" class="cls_020"><span class="cls_020">friend Rational operator+(const Rational&, const Rational&);</span></div>
<div style="position:absolute;left:72.00px;top:424.20px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:435.60px" class="cls_020"><span class="cls_020">Rational (int a = 0, int b = 1 ) : m(a), n(b) {}</span></div>
<div style="position:absolute;left:72.00px;top:446.88px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:458.28px" class="cls_020"><span class="cls_020">int m;</span></div>
<div style="position:absolute;left:143.99px;top:458.28px" class="cls_020"><span class="cls_020">// Numerator</span></div>
<div style="position:absolute;left:96.00px;top:469.56px" class="cls_020"><span class="cls_020">int n;</span></div>
<div style="position:absolute;left:143.99px;top:469.56px" class="cls_020"><span class="cls_020">// Denominator</span></div>
<div style="position:absolute;left:72.00px;top:480.84px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:507.12px" class="cls_006"><span class="cls_006">We can instantiate objects of type </span><span class="cls_020">Rational</span><span class="cls_006"> in several equivalent ways:</span></div>
<div style="position:absolute;left:72.00px;top:533.04px" class="cls_020"><span class="cls_020">Rational r1(100);</span></div>
<div style="position:absolute;left:257.97px;top:533.04px" class="cls_020"><span class="cls_020">// 1</span></div>
<div style="position:absolute;left:72.00px;top:544.32px" class="cls_020"><span class="cls_020">Rational r2 = Rational(100);</span></div>
<div style="position:absolute;left:257.97px;top:544.32px" class="cls_020"><span class="cls_020">// 2</span></div>
<div style="position:absolute;left:72.00px;top:555.72px" class="cls_020"><span class="cls_020">Rational r3 = 100;</span></div>
<div style="position:absolute;left:257.97px;top:555.72px" class="cls_020"><span class="cls_020">// 3</span></div>
<div style="position:absolute;left:72.00px;top:581.40px" class="cls_006"><span class="cls_006">Only the first form of initialization is guaranteed, across compiler implementations, not to generate a</span></div>
<div style="position:absolute;left:72.00px;top:593.40px" class="cls_006"><span class="cls_006">temporary object. If you use forms 2 or 3, you may end up with a temporary, depending on the compiler</span></div>
<div style="position:absolute;left:72.00px;top:605.52px" class="cls_006"><span class="cls_006">implementation. Take form 3 for example:</span></div>
<div style="position:absolute;left:72.00px;top:631.20px" class="cls_020"><span class="cls_020">Rational r3 = 100; // 3</span></div>
<div style="position:absolute;left:72.00px;top:657.48px" class="cls_006"><span class="cls_006">This form may lead the compiler to use the </span><span class="cls_020">Rational::Rational(int,</span><span class="cls_006"> </span><span class="cls_020">int)</span><span class="cls_006"> constructor to turn the</span></div>
<div style="position:absolute;left:72.00px;top:670.20px" class="cls_006"><span class="cls_006">integer </span><span class="cls_020">100</span><span class="cls_006"> into a temporary object of type </span><span class="cls_020">Rational</span><span class="cls_006">, and then to use the copy constructor to initialize</span></div>
<div style="position:absolute;left:72.00px;top:683.04px" class="cls_020"><span class="cls_020">r3</span><span class="cls_006"> from the newly created temporary:</span></div>
<div style="position:absolute;left:72.00px;top:708.96px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:101.99px;top:708.96px" class="cls_020"><span class="cls_020">// C++ pseudo code</span></div>
<div style="position:absolute;left:101.99px;top:720.36px" class="cls_020"><span class="cls_020">Rational r3;</span></div>
<div style="position:absolute;left:101.99px;top:731.64px" class="cls_020"><span class="cls_020">Rational _temp;</span></div>
<div style="position:absolute;left:96.00px;top:754.32px" class="cls_020"><span class="cls_020">_temp.Rational::Rational(100,1);</span></div>
<div style="position:absolute;left:365.95px;top:754.32px" class="cls_020"><span class="cls_020">// Construct the temporary</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:43452px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background052.jpg" width=595 height=842></div>
<div style="position:absolute;left:101.99px;top:70.56px" class="cls_020"><span class="cls_020">r3.Rational::Rational(_temp);</span></div>
<div style="position:absolute;left:365.95px;top:70.56px" class="cls_020"><span class="cls_020">// Copy-construct r3</span></div>
<div style="position:absolute;left:101.99px;top:81.84px" class="cls_020"><span class="cls_020">_temp.Rational::~Rational();</span></div>
<div style="position:absolute;left:365.95px;top:81.84px" class="cls_020"><span class="cls_020">// Destroy the temporary</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:130.20px" class="cls_006"><span class="cls_006">The overall cost here is two constructors and one destructor. In the first form,</span></div>
<div style="position:absolute;left:72.00px;top:156.00px" class="cls_020"><span class="cls_020">Rational r1(100);</span></div>
<div style="position:absolute;left:197.98px;top:156.00px" class="cls_020"><span class="cls_020">// 1</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">we pay only the cost of one constructor.</span></div>
<div style="position:absolute;left:72.00px;top:207.72px" class="cls_006"><span class="cls_006">In practice, however, most compilers should optimize the temporary away, and the three initialization</span></div>
<div style="position:absolute;left:72.00px;top:219.84px" class="cls_006"><span class="cls_006">forms presented here would be equivalent in their efficiency.</span></div>
<div style="position:absolute;left:72.00px;top:273.60px" class="cls_016"><span class="cls_016">Type Mismatch</span></div>
<div style="position:absolute;left:72.00px;top:304.92px" class="cls_006"><span class="cls_006">The previous example is a special case of the more general type mismatch. We tried to initialize an object</span></div>
<div style="position:absolute;left:72.00px;top:317.40px" class="cls_006"><span class="cls_006">of type </span><span class="cls_020">Rational</span><span class="cls_006"> with an integer. The generic case of type mismatch is any time an object of type </span><span class="cls_020">X</span><span class="cls_006"> is</span></div>
<div style="position:absolute;left:72.00px;top:329.76px" class="cls_006"><span class="cls_006">expected and some other type is provided. The compiler needs, somehow, to convert the provided type into</span></div>
<div style="position:absolute;left:72.00px;top:342.36px" class="cls_006"><span class="cls_006">the expected object of type </span><span class="cls_020">X</span><span class="cls_006">. A temporary may get generated in the process. Look at the following:</span></div>
<div style="position:absolute;left:72.00px;top:368.28px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:379.68px" class="cls_020"><span class="cls_020">Rational r;</span></div>
<div style="position:absolute;left:96.00px;top:390.96px" class="cls_020"><span class="cls_020">r = 100;</span></div>
<div style="position:absolute;left:72.00px;top:413.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:439.80px" class="cls_006"><span class="cls_006">Our </span><span class="cls_020">Rational</span><span class="cls_006"> class did not declare an assignment operator that takes an integer parameter. The compiler,</span></div>
<div style="position:absolute;left:72.00px;top:452.64px" class="cls_006"><span class="cls_006">then, expects a </span><span class="cls_020">Rational</span><span class="cls_006"> object on the right-hand side that will be bit-blasted to the left-hand side. The</span></div>
<div style="position:absolute;left:72.00px;top:465.36px" class="cls_006"><span class="cls_006">compiler must find a way to convert the integer argument we provided into an object of type </span><span class="cls_020">Rational</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:477.72px" class="cls_006"><span class="cls_006">Fortunately (or unfortunately for performance), we have a constructor that knows how to do that:</span></div>
<div style="position:absolute;left:72.00px;top:503.40px" class="cls_020"><span class="cls_020">class Rational</span></div>
<div style="position:absolute;left:72.00px;top:514.80px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:526.08px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:537.36px" class="cls_020"><span class="cls_020">// If only one integer is provided, the second one will default</span></div>
<div style="position:absolute;left:96.00px;top:548.76px" class="cls_020"><span class="cls_020">// to 1.</span></div>
<div style="position:absolute;left:96.00px;top:560.04px" class="cls_020"><span class="cls_020">Rational (int a = 0, int b = 1 ) : m(a), n(b) {}</span></div>
<div style="position:absolute;left:72.00px;top:582.72px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:608.88px" class="cls_006"><span class="cls_006">This constructor knows how to create a </span><span class="cls_020">Rational</span><span class="cls_006"> object from an integer argument. The source statement</span></div>
<div style="position:absolute;left:72.00px;top:634.92px" class="cls_020"><span class="cls_020">r = 100;</span></div>
<div style="position:absolute;left:72.00px;top:660.48px" class="cls_006"><span class="cls_006">is transformed into the following C++ pseudocode:</span></div>
<div style="position:absolute;left:72.00px;top:686.28px" class="cls_020"><span class="cls_020">Rational _temp;</span></div>
<div style="position:absolute;left:209.97px;top:686.28px" class="cls_020"><span class="cls_020">// Place holder for temporary</span></div>
<div style="position:absolute;left:72.00px;top:708.96px" class="cls_020"><span class="cls_020">_temp.Rational::Rational(100,1);</span></div>
<div style="position:absolute;left:377.94px;top:708.96px" class="cls_020"><span class="cls_020">// Construct temporary</span></div>
<div style="position:absolute;left:72.00px;top:720.24px" class="cls_020"><span class="cls_020">r.Rational::operator=(_temp);</span></div>
<div style="position:absolute;left:377.94px;top:720.24px" class="cls_020"><span class="cls_020">// Assign temporary to r</span></div>
<div style="position:absolute;left:72.00px;top:731.64px" class="cls_020"><span class="cls_020">temp.Rational::~Rational();</span></div>
<div style="position:absolute;left:377.94px;top:731.64px" class="cls_020"><span class="cls_020">// Destroy the temporary</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">38</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:44304px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background053.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">This liberty taken by the compiler to convert between types is a programming convenience. There are</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">regions in your source code where convenience is overwhelmed by performance considerations. The new</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">C++ standard gives you the ability to restrict the compiler and forbid such conversions. You do that by</span></div>
<div style="position:absolute;left:72.00px;top:107.64px" class="cls_006"><span class="cls_006">declaring a constructor </span><span class="cls_020">explicit</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:133.56px" class="cls_020"><span class="cls_020">class Rational</span></div>
<div style="position:absolute;left:72.00px;top:144.96px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:156.24px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:167.52px" class="cls_020"><span class="cls_020">explicit Rational (int a = 0, int b = 1 ) : m(a), n(b) {}</span></div>
<div style="position:absolute;left:72.00px;top:190.20px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:216.00px" class="cls_006"><span class="cls_006">The explicit keyword tells the compiler that you oppose usage of this constructor as a conversion</span></div>
<div style="position:absolute;left:72.00px;top:228.00px" class="cls_006"><span class="cls_006">constructor.</span></div>
<div style="position:absolute;left:72.00px;top:254.04px" class="cls_006"><span class="cls_006">Alternatively, this type of temporary object can also be eliminated by overloading the</span></div>
<div style="position:absolute;left:72.00px;top:266.64px" class="cls_020"><span class="cls_020">Rational::operator=()</span><span class="cls_006"> function to accept an integer as an argument:</span></div>
<div style="position:absolute;left:72.00px;top:292.56px" class="cls_020"><span class="cls_020">class Rational {</span></div>
<div style="position:absolute;left:72.00px;top:303.96px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:125.99px;top:315.24px" class="cls_020"><span class="cls_020">// as before</span></div>
<div style="position:absolute;left:96.00px;top:326.52px" class="cls_020"><span class="cls_020">Rational& operator=(int a) {m=a; n=1; return *this; }</span></div>
<div style="position:absolute;left:72.00px;top:337.92px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:364.08px" class="cls_006"><span class="cls_006">The same principle can be generalized for all function calls. Let </span><span class="cls_020">g()</span><span class="cls_006"> be an arbitrary function call taking a</span></div>
<div style="position:absolute;left:72.00px;top:376.92px" class="cls_020"><span class="cls_020">string</span><span class="cls_006"> reference as an argument:</span></div>
<div style="position:absolute;left:72.00px;top:402.84px" class="cls_020"><span class="cls_020">void g(const string& s)</span></div>
<div style="position:absolute;left:72.00px;top:414.12px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:436.80px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:463.08px" class="cls_006"><span class="cls_006">An invocation of </span><span class="cls_020">g("message")</span><span class="cls_006"> will trigger the creation of a temporary </span><span class="cls_020">string</span><span class="cls_006"> object unless you</span></div>
<div style="position:absolute;left:72.00px;top:475.80px" class="cls_006"><span class="cls_006">overload </span><span class="cls_020">g()</span><span class="cls_006"> to accept a </span><span class="cls_020">char *</span><span class="cls_006"> as an argument:</span></div>
<div style="position:absolute;left:72.00px;top:501.72px" class="cls_020"><span class="cls_020">void g(const char* s)</span></div>
<div style="position:absolute;left:72.00px;top:513.12px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:535.80px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:561.48px" class="cls_006"><span class="cls_006">Cargil [</span><span class="cls_036">Car92</span><span class="cls_006">] points out an interesting twist on the type mismatch temporary generation. In the following</span></div>
<div style="position:absolute;left:72.00px;top:573.96px" class="cls_006"><span class="cls_006">code fragment the </span><span class="cls_020">operator+()</span><span class="cls_006"> expects two </span><span class="cls_020">Complex</span><span class="cls_006"> objects as arguments. A temporary </span><span class="cls_020">Complex</span></div>
<div style="position:absolute;left:72.00px;top:586.32px" class="cls_006"><span class="cls_006">object gets generated to represent the constant 1.0:</span></div>
<div style="position:absolute;left:72.00px;top:612.00px" class="cls_020"><span class="cls_020">Complex a, b;</span></div>
<div style="position:absolute;left:72.00px;top:634.68px" class="cls_020"><span class="cls_020">for (int i; i &lt; 100; i++) {</span></div>
<div style="position:absolute;left:96.00px;top:645.96px" class="cls_020"><span class="cls_020">a = i*b + 1.0;</span></div>
<div style="position:absolute;left:72.00px;top:657.36px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:683.04px" class="cls_006"><span class="cls_006">The problem is that this temporary is generated over and over every iteration through the loop. Lifting</span></div>
<div style="position:absolute;left:72.00px;top:695.64px" class="cls_006"><span class="cls_006">constant expressions out of a loop is a trivial and well-known optimization. The temporary generation in </span><span class="cls_020">a</span></div>
<div style="position:absolute;left:72.00px;top:708.36px" class="cls_020"><span class="cls_020">= b + 1.0</span><span class="cls_006">; is a computation whose value is constant from one iteration to the next. In that case, why</span></div>
<div style="position:absolute;left:72.00px;top:720.72px" class="cls_006"><span class="cls_006">should we do it over and over? Let's do it once and for all:</span></div>
<div style="position:absolute;left:72.00px;top:746.40px" class="cls_020"><span class="cls_020">Complex one(1.0);</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">39</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:45156px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background054.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">for (int i = 0; i &lt; 100; i++) {</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">a = i*b + one;</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:130.80px" class="cls_006"><span class="cls_006">We turned the temporary into a named </span><span class="cls_020">Complex</span><span class="cls_006"> object. It cost us one construction, but it still beats a</span></div>
<div style="position:absolute;left:72.00px;top:143.04px" class="cls_006"><span class="cls_006">temporary construction for every loop iteration.</span></div>
<div style="position:absolute;left:72.00px;top:196.80px" class="cls_016"><span class="cls_016">Pass by Value</span></div>
<div style="position:absolute;left:72.00px;top:228.12px" class="cls_006"><span class="cls_006">When passing an object by value, the initialization of the formal parameter with the actual parameter is</span></div>
<div style="position:absolute;left:72.00px;top:240.24px" class="cls_006"><span class="cls_006">equivalent to the following form [</span><span class="cls_036">ES90</span><span class="cls_006">]:</span></div>
<div style="position:absolute;left:72.00px;top:265.92px" class="cls_020"><span class="cls_020">T formalArg = actualArg;</span></div>
<div style="position:absolute;left:72.00px;top:292.20px" class="cls_006"><span class="cls_006">where </span><span class="cls_020">T</span><span class="cls_006"> is the class type. Suppose </span><span class="cls_020">g()</span><span class="cls_006"> is some function expecting a </span><span class="cls_020">T</span><span class="cls_006"> argument when invoked:</span></div>
<div style="position:absolute;left:72.00px;top:318.12px" class="cls_020"><span class="cls_020">void g (T formalArg)</span></div>
<div style="position:absolute;left:72.00px;top:329.40px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:352.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:378.24px" class="cls_006"><span class="cls_006">A typical invocation of </span><span class="cls_020">g()</span><span class="cls_006"> may look like:</span></div>
<div style="position:absolute;left:72.00px;top:404.16px" class="cls_020"><span class="cls_020">T t;</span></div>
<div style="position:absolute;left:72.00px;top:415.56px" class="cls_020"><span class="cls_020">g(t);</span></div>
<div style="position:absolute;left:72.00px;top:441.72px" class="cls_006"><span class="cls_006">The activation record for </span><span class="cls_020">g()</span><span class="cls_006"> has a place holder on the stack for its local argument </span><span class="cls_020">formalArg</span><span class="cls_006">. The</span></div>
<div style="position:absolute;left:72.00px;top:454.56px" class="cls_006"><span class="cls_006">compiler must copy the content of object </span><span class="cls_020">t</span><span class="cls_006"> into </span><span class="cls_020">g()</span><span class="cls_006">'s </span><span class="cls_020">formalArg</span><span class="cls_006"> on the stack. One popular technique of</span></div>
<div style="position:absolute;left:72.00px;top:466.80px" class="cls_006"><span class="cls_006">doing this will generate a temporary [</span><span class="cls_036">Lip96I</span><span class="cls_006">].</span></div>
<div style="position:absolute;left:72.00px;top:493.44px" class="cls_006"><span class="cls_006">The compiler will create a temporary object of type </span><span class="cls_020">T</span><span class="cls_006"> and copy-construct it using </span><span class="cls_020">t</span><span class="cls_006"> as an input argument.</span></div>
<div style="position:absolute;left:72.00px;top:506.16px" class="cls_006"><span class="cls_006">This temporary will then be passed to </span><span class="cls_020">g()</span><span class="cls_006"> as an actual argument. This newly created temporary object is</span></div>
<div style="position:absolute;left:72.00px;top:519.00px" class="cls_006"><span class="cls_006">then passed to </span><span class="cls_020">g()</span><span class="cls_006"> by reference. In C++ pseudocode, it looks something like:</span></div>
<div style="position:absolute;left:72.00px;top:544.92px" class="cls_020"><span class="cls_020">T _temp;</span></div>
<div style="position:absolute;left:72.00px;top:567.60px" class="cls_020"><span class="cls_020">_temp.T::T(t);</span></div>
<div style="position:absolute;left:167.98px;top:567.60px" class="cls_020"><span class="cls_020">// copy construct _temp from t</span></div>
<div style="position:absolute;left:72.00px;top:579.00px" class="cls_020"><span class="cls_020">g(_temp);</span></div>
<div style="position:absolute;left:167.98px;top:579.00px" class="cls_020"><span class="cls_020">// pass _temp by reference</span></div>
<div style="position:absolute;left:72.00px;top:590.28px" class="cls_020"><span class="cls_020">_temp.T::~T();</span></div>
<div style="position:absolute;left:167.98px;top:590.28px" class="cls_020"><span class="cls_020">// Destroy _temp</span></div>
<div style="position:absolute;left:72.00px;top:615.96px" class="cls_006"><span class="cls_006">Creating and destroying the temporary object is relatively expensive. If you can, you should pass objects</span></div>
<div style="position:absolute;left:72.00px;top:628.08px" class="cls_006"><span class="cls_006">by pointer or reference to avoid temporary generation. Sometimes, however, you have no choice but to</span></div>
<div style="position:absolute;left:72.00px;top:640.08px" class="cls_006"><span class="cls_006">pass an object by value. For a convincing argument, see Item 23 in [</span><span class="cls_036">Mey97</span><span class="cls_006">].</span></div>
<div style="position:absolute;left:72.00px;top:693.84px" class="cls_016"><span class="cls_016">Return by Value</span></div>
<div style="position:absolute;left:72.00px;top:725.28px" class="cls_006"><span class="cls_006">Another path that leads to temporary object creation is function return value. If you code a function that</span></div>
<div style="position:absolute;left:72.00px;top:737.28px" class="cls_006"><span class="cls_006">returns an object by value (as opposed to a reference or pointer), you can easily end up with a temporary.</span></div>
<div style="position:absolute;left:72.00px;top:749.88px" class="cls_006"><span class="cls_006">Consider </span><span class="cls_020">f()</span><span class="cls_006"> as a simple example:</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">40</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:46008px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background055.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">string f()</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">string s;</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">... // Compute "s"</span></div>
<div style="position:absolute;left:96.00px;top:115.92px" class="cls_020"><span class="cls_020">return s;</span></div>
<div style="position:absolute;left:72.00px;top:127.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:153.36px" class="cls_006"><span class="cls_006">The return value of </span><span class="cls_020">f()</span><span class="cls_006"> is an object of type </span><span class="cls_020">string</span><span class="cls_006">. A temporary is generated to hold that return value.</span></div>
<div style="position:absolute;left:72.00px;top:165.72px" class="cls_006"><span class="cls_006">For example:</span></div>
<div style="position:absolute;left:72.00px;top:191.40px" class="cls_020"><span class="cls_020">String p;</span></div>
<div style="position:absolute;left:72.00px;top:214.08px" class="cls_020"><span class="cls_020">p = f();</span></div>
<div style="position:absolute;left:72.00px;top:240.24px" class="cls_006"><span class="cls_006">The temporary object holding </span><span class="cls_020">f()</span><span class="cls_006">'s return value is then assigned to the left-hand side object </span><span class="cls_020">p</span><span class="cls_006">. For a more</span></div>
<div style="position:absolute;left:72.00px;top:253.08px" class="cls_006"><span class="cls_006">concrete example consider the </span><span class="cls_020">string operator+</span><span class="cls_006">. This operator will implement the intuitive</span></div>
<div style="position:absolute;left:72.00px;top:265.80px" class="cls_006"><span class="cls_006">interpretation of </span><span class="cls_020">string</span><span class="cls_006"> </span><span class="cls_020">"+"</span><span class="cls_006"> operation. It takes two input </span><span class="cls_020">string</span><span class="cls_006"> objects and returns a new </span><span class="cls_020">string</span></div>
<div style="position:absolute;left:72.00px;top:278.64px" class="cls_006"><span class="cls_006">object representing the result of concatenating the given </span><span class="cls_020">string</span><span class="cls_006">s. A possible implementation of this</span></div>
<div style="position:absolute;left:72.00px;top:291.00px" class="cls_006"><span class="cls_006">operator may look like this:</span></div>
<div style="position:absolute;left:72.00px;top:316.68px" class="cls_020"><span class="cls_020">string operator+ (const string& s, const string& p)</span></div>
<div style="position:absolute;left:72.00px;top:327.96px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:339.36px" class="cls_020"><span class="cls_020">char *buffer = new char[s.length() + p.length() + 1];</span></div>
<div style="position:absolute;left:96.00px;top:362.04px" class="cls_020"><span class="cls_020">strcpy(buffer,s.str);</span></div>
<div style="position:absolute;left:257.97px;top:362.04px" class="cls_020"><span class="cls_020">// Copy first character string</span></div>
<div style="position:absolute;left:96.00px;top:373.32px" class="cls_020"><span class="cls_020">strcat(buffer,p.str);</span></div>
<div style="position:absolute;left:257.97px;top:373.32px" class="cls_020"><span class="cls_020">// Add second character string</span></div>
<div style="position:absolute;left:96.00px;top:384.60px" class="cls_020"><span class="cls_020">string result(buffer);</span></div>
<div style="position:absolute;left:257.97px;top:384.60px" class="cls_020"><span class="cls_020">// Create return object</span></div>
<div style="position:absolute;left:96.00px;top:396.00px" class="cls_020"><span class="cls_020">delete buffer;</span></div>
<div style="position:absolute;left:96.00px;top:418.68px" class="cls_020"><span class="cls_020">return result;</span></div>
<div style="position:absolute;left:72.00px;top:429.96px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:456.12px" class="cls_006"><span class="cls_006">The following code segment is a typical invocation of the </span><span class="cls_020">string operator+</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:482.16px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:493.44px" class="cls_020"><span class="cls_020">string s1 = "Hello";</span></div>
<div style="position:absolute;left:96.00px;top:504.72px" class="cls_020"><span class="cls_020">string s2 = "World";</span></div>
<div style="position:absolute;left:96.00px;top:516.12px" class="cls_020"><span class="cls_020">string s3;</span></div>
<div style="position:absolute;left:96.00px;top:538.80px" class="cls_020"><span class="cls_020">s3 = s1 + s2;</span></div>
<div style="position:absolute;left:185.98px;top:538.80px" class="cls_020"><span class="cls_020">// s3 &lt;- "HelloWorld"</span></div>
<div style="position:absolute;left:72.00px;top:561.36px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:587.04px" class="cls_006"><span class="cls_006">The statement:</span></div>
<div style="position:absolute;left:72.00px;top:612.84px" class="cls_020"><span class="cls_020">s3 = s1 + s2;</span></div>
<div style="position:absolute;left:72.00px;top:638.40px" class="cls_006"><span class="cls_006">triggers several function calls:</span></div>
<div style="position:absolute;left:90.00px;top:665.28px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  operator+(const string &, const string &);</span><span class="cls_006"> ==> String addition operator. This is</span></div>
<div style="position:absolute;left:108.00px;top:678.12px" class="cls_006"><span class="cls_006">triggered by </span><span class="cls_020">s1+ s2</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:90.00px;top:691.20px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  string::string(const char *);</span><span class="cls_006">==> Constructor. Execute </span><span class="cls_020">string result(buffer)</span></div>
<div style="position:absolute;left:108.00px;top:703.92px" class="cls_006"><span class="cls_006">inside </span><span class="cls_020">operator+()</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:90.00px;top:717.00px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  string::string(const string &)</span><span class="cls_006">;==> We need a temporary object to hold the return</span></div>
<div style="position:absolute;left:108.00px;top:729.84px" class="cls_006"><span class="cls_006">value of </span><span class="cls_020">operator+()</span><span class="cls_006">. The copy constructor will create this temporary using the returned</span></div>
<div style="position:absolute;left:108.00px;top:742.68px" class="cls_020"><span class="cls_020">result string</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">41</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:46860px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background056.jpg" width=595 height=842></div>
<div style="position:absolute;left:90.00px;top:71.64px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  string::~string() ;</span><span class="cls_006"> ==> Before the </span><span class="cls_020">operator+()</span><span class="cls_006"> function exits, it destroys the </span><span class="cls_020">result</span></div>
<div style="position:absolute;left:108.00px;top:84.48px" class="cls_020"><span class="cls_020">string</span><span class="cls_006"> object whose lifetime is limited to the local scope.</span></div>
<div style="position:absolute;left:90.00px;top:97.56px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  string::operator=(const string &);</span><span class="cls_006"> ==> The assignment operator is invoked to</span></div>
<div style="position:absolute;left:108.00px;top:110.28px" class="cls_006"><span class="cls_006">assign the temporary produced by </span><span class="cls_020">operator+()</span><span class="cls_006"> to the left-hand side object </span><span class="cls_020">s3</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:90.00px;top:123.36px" class="cls_017"><span class="cls_017">• </span><span class="cls_020">  string::~string(); ==></span><span class="cls_006"> The temporary object used for the return value is destroyed.</span></div>
<div style="position:absolute;left:72.00px;top:149.76px" class="cls_006"><span class="cls_006">Six function call invocations is a hefty price for one source code statement. Even if most of them are</span></div>
<div style="position:absolute;left:72.00px;top:161.76px" class="cls_006"><span class="cls_006">inlined, you still have to execute their logic. The return-value optimization discussed in </span><span class="cls_036">Chapter 4</span><span class="cls_006"> can help</span></div>
<div style="position:absolute;left:72.00px;top:174.36px" class="cls_006"><span class="cls_006">us eliminate the </span><span class="cls_020">result string</span><span class="cls_006"> object. That takes care of a constructor and destructor call. Can we also</span></div>
<div style="position:absolute;left:72.00px;top:186.60px" class="cls_006"><span class="cls_006">eliminate the temporary object? That will eliminate two more function calls.</span></div>
<div style="position:absolute;left:72.00px;top:212.76px" class="cls_006"><span class="cls_006">Why does the statement:</span></div>
<div style="position:absolute;left:72.00px;top:238.44px" class="cls_020"><span class="cls_020">s3 = s1 + s2;</span></div>
<div style="position:absolute;left:72.00px;top:264.12px" class="cls_006"><span class="cls_006">generate a temporary in the first place? Because we do not have the liberty of clobbering the old contents</span></div>
<div style="position:absolute;left:72.00px;top:276.72px" class="cls_006"><span class="cls_006">of </span><span class="cls_020">string s3</span><span class="cls_006"> and overwrite it with the new content of </span><span class="cls_020">s1+s2</span><span class="cls_006">. The assignment operator is responsible</span></div>
<div style="position:absolute;left:72.00px;top:289.44px" class="cls_006"><span class="cls_006">for the transition of </span><span class="cls_020">string s3</span><span class="cls_006"> from old content to new content. The compiler does not have permission</span></div>
<div style="position:absolute;left:72.00px;top:302.28px" class="cls_006"><span class="cls_006">to skip </span><span class="cls_020">string::operator=()</span><span class="cls_006"> and hence a temporary is a must. But what if </span><span class="cls_020">s3</span><span class="cls_006"> is a brand new</span></div>
<div style="position:absolute;left:72.00px;top:315.12px" class="cls_020"><span class="cls_020">string</span><span class="cls_006"> object with no previous content? In this case there is no old content to worry about and the</span></div>
<div style="position:absolute;left:72.00px;top:327.96px" class="cls_006"><span class="cls_006">compiler could use the </span><span class="cls_020">s3</span><span class="cls_006"> storage instead of the temporary object. The result of </span><span class="cls_020">s1+s2</span><span class="cls_006"> is copy-</span></div>
<div style="position:absolute;left:72.00px;top:340.68px" class="cls_006"><span class="cls_006">constructed directly into the </span><span class="cls_020">string</span><span class="cls_006"> </span><span class="cls_020">s3</span><span class="cls_006"> object. </span><span class="cls_020">s3</span><span class="cls_006"> has taken the place of the temporary, which is no</span></div>
<div style="position:absolute;left:72.00px;top:353.04px" class="cls_006"><span class="cls_006">longer necessary. To make a long story short, the form:</span></div>
<div style="position:absolute;left:72.00px;top:378.72px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:390.12px" class="cls_020"><span class="cls_020">string s1 = "Hello";</span></div>
<div style="position:absolute;left:96.00px;top:401.40px" class="cls_020"><span class="cls_020">string s2 = "World";</span></div>
<div style="position:absolute;left:96.00px;top:412.68px" class="cls_020"><span class="cls_020">string s3 = s1 + s2;</span></div>
<div style="position:absolute;left:227.97px;top:412.68px" class="cls_020"><span class="cls_020">// No temporary here.</span></div>
<div style="position:absolute;left:72.00px;top:435.36px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:461.04px" class="cls_006"><span class="cls_006">is preferable to the form:</span></div>
<div style="position:absolute;left:72.00px;top:486.84px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:498.12px" class="cls_020"><span class="cls_020">string s1 = "Hello";</span></div>
<div style="position:absolute;left:96.00px;top:509.40px" class="cls_020"><span class="cls_020">string s2 = "World";</span></div>
<div style="position:absolute;left:96.00px;top:520.80px" class="cls_020"><span class="cls_020">string s3;</span></div>
<div style="position:absolute;left:96.00px;top:543.48px" class="cls_020"><span class="cls_020">s3 = s1 + s2;</span></div>
<div style="position:absolute;left:221.97px;top:543.48px" class="cls_020"><span class="cls_020">// Temporary generated here.</span></div>
<div style="position:absolute;left:72.00px;top:566.04px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:619.32px" class="cls_016"><span class="cls_016">Eliminate Temporaries with </span><span class="cls_029">op=()</span></div>
<div style="position:absolute;left:72.00px;top:650.64px" class="cls_006"><span class="cls_006">In the previous discussion we have supplied the compiler with an existing object to work with so it will not</span></div>
<div style="position:absolute;left:72.00px;top:663.24px" class="cls_006"><span class="cls_006">invent a temporary one. That same idea can get recycled in other situations as well. Suppose that </span><span class="cls_020">s3</span><span class="cls_006"> does</span></div>
<div style="position:absolute;left:72.00px;top:675.96px" class="cls_006"><span class="cls_006">have a previous value and we are not in position to initialize </span><span class="cls_020">s3</span><span class="cls_006"> from scratch with:</span></div>
<div style="position:absolute;left:72.00px;top:702.00px" class="cls_020"><span class="cls_020">string s3 = s1 + s2;</span></div>
<div style="position:absolute;left:72.00px;top:727.56px" class="cls_006"><span class="cls_006">If we are looking at the case:</span></div>
<div style="position:absolute;left:72.00px;top:753.36px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">42</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:47712px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background057.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">string s1,s2,s3;</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">s3 = s1 + s2;</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">we can still prevent the creation of a temporary. We can do that by using the </span><span class="cls_020">string operator+=()</span></div>
<div style="position:absolute;left:72.00px;top:154.80px" class="cls_006"><span class="cls_006">and rewriting the code to use </span><span class="cls_020">+=</span><span class="cls_006"> instead of </span><span class="cls_020">+</span><span class="cls_006">, so</span></div>
<div style="position:absolute;left:72.00px;top:180.84px" class="cls_020"><span class="cls_020">s3 = s1 + s2;</span></div>
<div style="position:absolute;left:185.98px;top:180.84px" class="cls_020"><span class="cls_020">// Temporary generated here</span></div>
<div style="position:absolute;left:72.00px;top:206.40px" class="cls_006"><span class="cls_006">is rewritten as:</span></div>
<div style="position:absolute;left:72.00px;top:232.20px" class="cls_020"><span class="cls_020">s3</span></div>
<div style="position:absolute;left:96.00px;top:232.20px" class="cls_020"><span class="cls_020">= s1;</span></div>
<div style="position:absolute;left:161.98px;top:232.20px" class="cls_020"><span class="cls_020">// operator=(). No temporary.</span></div>
<div style="position:absolute;left:72.00px;top:243.60px" class="cls_020"><span class="cls_020">s3 += s2;</span></div>
<div style="position:absolute;left:161.98px;top:243.60px" class="cls_020"><span class="cls_020">// operator+=(). No temporary.</span></div>
<div style="position:absolute;left:72.00px;top:269.76px" class="cls_006"><span class="cls_006">If </span><span class="cls_020">string::operator+=()</span><span class="cls_006"> and </span><span class="cls_020">operator+()</span><span class="cls_006"> are implemented in a consistent fashion (both</span></div>
<div style="position:absolute;left:72.00px;top:282.00px" class="cls_006"><span class="cls_006">implementing "addition," as they should) then the two code fragments are semantically equivalent. They</span></div>
<div style="position:absolute;left:72.00px;top:294.12px" class="cls_006"><span class="cls_006">differ only in performance. Although both invoke a copy constructor and an operator function, the former</span></div>
<div style="position:absolute;left:72.00px;top:306.24px" class="cls_006"><span class="cls_006">creates a temporary object where the latter does not. Hence the latter is more efficient.</span></div>
<div style="position:absolute;left:72.00px;top:332.28px" class="cls_006"><span class="cls_006">As pointed out in [</span><span class="cls_036">Mey96</span><span class="cls_006">]:</span></div>
<div style="position:absolute;left:72.00px;top:357.96px" class="cls_020"><span class="cls_020">s5 = s1 + s2 + s3 + s4; // Three temporaries generated.</span></div>
<div style="position:absolute;left:72.00px;top:383.52px" class="cls_006"><span class="cls_006">is much more elegant than:</span></div>
<div style="position:absolute;left:72.00px;top:409.32px" class="cls_020"><span class="cls_020">s5</span></div>
<div style="position:absolute;left:96.00px;top:409.32px" class="cls_020"><span class="cls_020">= s1;</span></div>
<div style="position:absolute;left:72.00px;top:420.72px" class="cls_020"><span class="cls_020">s5 += s2;</span></div>
<div style="position:absolute;left:72.00px;top:432.00px" class="cls_020"><span class="cls_020">s5 += s3;</span></div>
<div style="position:absolute;left:72.00px;top:443.40px" class="cls_020"><span class="cls_020">s5 += s4;</span></div>
<div style="position:absolute;left:72.00px;top:469.08px" class="cls_006"><span class="cls_006">But on a performance-critical path you need to forgo elegance in favor of raw performance. The second,</span></div>
<div style="position:absolute;left:72.00px;top:481.08px" class="cls_006"><span class="cls_006">"ugly" form is much more efficient. It creates zero temporaries.</span></div>
<div style="position:absolute;left:72.00px;top:534.96px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:566.52px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A temporary object could penalize performance twice in the form of constructor and destructor</span></div>
<div style="position:absolute;left:108.00px;top:578.52px" class="cls_006"><span class="cls_006">computations.</span></div>
<div style="position:absolute;left:90.00px;top:591.36px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Declaring a constructor </span><span class="cls_020">explicit</span><span class="cls_006"> will prevent the compiler from using it for type conversion</span></div>
<div style="position:absolute;left:108.00px;top:603.72px" class="cls_006"><span class="cls_006">behind your back.</span></div>
<div style="position:absolute;left:90.00px;top:615.96px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A temporary object is often created by the compiler to fix a type mismatch. You can avoid it by</span></div>
<div style="position:absolute;left:108.00px;top:628.08px" class="cls_006"><span class="cls_006">function overloading.</span></div>
<div style="position:absolute;left:90.00px;top:640.44px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Avoid object copy if you can. Pass and return objects by reference.</span></div>
<div style="position:absolute;left:90.00px;top:653.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   You can eliminate temporaries by using </span><span class="cls_020">&lt;op>=</span><span class="cls_006"> operators where </span><span class="cls_020">&lt;op></span><span class="cls_006"> may be </span><span class="cls_020">+</span><span class="cls_006">, </span><span class="cls_020">-</span><span class="cls_006">, </span><span class="cls_020">*</span><span class="cls_006">, or</span><span class="cls_020"> /</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">43</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:48564px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background058.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 6. Single-Threaded Memory Pooling</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">Frequent memory allocation and deallocation can play a significant role in degrading application</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">performance. The performance degradation stems from the fact that the default memory manager is, by</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">nature, general purpose. An application may use memory in a very specific way and pay a performance</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">penalty for functionality it does not need. You could counter that by developing specialized memory</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">managers. The design space for special-purpose memory managers is multidimensional. At least two</span></div>
<div style="position:absolute;left:72.00px;top:178.32px" class="cls_006"><span class="cls_006">dimensions easily come to mind: size and concurrency. The size dimension has two distinct points:</span></div>
<div style="position:absolute;left:90.00px;top:204.60px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Fixed-size</span><span class="cls_006"> Memory managers that allocate memory blocks of a single fixed size.</span></div>
<div style="position:absolute;left:90.00px;top:216.96px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Variable-size</span><span class="cls_006"> Memory managers that allocate memory blocks of any size. Request size is not</span></div>
<div style="position:absolute;left:108.00px;top:228.96px" class="cls_006"><span class="cls_006">known in advance.</span></div>
<div style="position:absolute;left:72.00px;top:255.12px" class="cls_006"><span class="cls_006">Similarly, the concurrent dimension has two points as well:</span></div>
<div style="position:absolute;left:90.00px;top:281.40px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Single-threaded</span><span class="cls_006"> The memory manager is confined to a single thread. The memory is used by a</span></div>
<div style="position:absolute;left:108.00px;top:293.52px" class="cls_006"><span class="cls_006">single thread and does not cross thread boundary. This class is not concerned with multiple threads</span></div>
<div style="position:absolute;left:108.00px;top:305.52px" class="cls_006"><span class="cls_006">stepping on one another.</span></div>
<div style="position:absolute;left:90.00px;top:317.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_015">   Multithreaded</span><span class="cls_006"> This memory manager is used by multiple threads concurrently. The</span></div>
<div style="position:absolute;left:108.00px;top:329.88px" class="cls_006"><span class="cls_006">implementation will have code fragments whose exceution is mutually exclusive. Only one thread</span></div>
<div style="position:absolute;left:108.00px;top:342.00px" class="cls_006"><span class="cls_006">can execute in any of these fragments at any point in time.</span></div>
<div style="position:absolute;left:72.00px;top:368.04px" class="cls_006"><span class="cls_006">Right now we already have four distinct flavors of specialized managers: those corresponding to the</span></div>
<div style="position:absolute;left:72.00px;top:380.16px" class="cls_006"><span class="cls_006">product of the size dimension, {fixed, variable}, with the concurrent dimension, {single-threaded,</span></div>
<div style="position:absolute;left:72.00px;top:392.28px" class="cls_006"><span class="cls_006">multithreaded}. In this chapter we will examine the single-threaded dimension of special-purpose</span></div>
<div style="position:absolute;left:72.00px;top:404.28px" class="cls_006"><span class="cls_006">managers and their performance implications. Our goal, of course, is to develop alternative memory</span></div>
<div style="position:absolute;left:72.00px;top:416.40px" class="cls_006"><span class="cls_006">managers that are much faster than the default one. At the same time, we don't want to develop too many</span></div>
<div style="position:absolute;left:72.00px;top:428.40px" class="cls_006"><span class="cls_006">specialized managers. The ultimate goal is to combine speed with as much flexibility and code reuse as we</span></div>
<div style="position:absolute;left:72.00px;top:440.52px" class="cls_006"><span class="cls_006">can.</span></div>
<div style="position:absolute;left:72.00px;top:494.28px" class="cls_016"><span class="cls_016">Version 0: The Global </span><span class="cls_029">new()</span><span class="cls_016"> and </span><span class="cls_029">delete()</span></div>
<div style="position:absolute;left:72.00px;top:525.60px" class="cls_006"><span class="cls_006">The default memory manager is, by design, a general-purpose one. This is what you get when you call the</span></div>
<div style="position:absolute;left:72.00px;top:538.20px" class="cls_006"><span class="cls_006">global </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006">. The implementation of these two functions cannot make any simplifying</span></div>
<div style="position:absolute;left:72.00px;top:550.56px" class="cls_006"><span class="cls_006">assumptions. They manage memory in the process context, and since a process may spawn multiple</span></div>
<div style="position:absolute;left:72.00px;top:563.04px" class="cls_006"><span class="cls_006">threads, </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006"> must be able to operate in a multithreaded environment. In addition, the</span></div>
<div style="position:absolute;left:72.00px;top:575.40px" class="cls_006"><span class="cls_006">size of memory requests may vary from one request to the next. This flexibility trades off with speed. The</span></div>
<div style="position:absolute;left:72.00px;top:587.52px" class="cls_006"><span class="cls_006">more you have to compute, the more cycles it is going to consume.</span></div>
<div style="position:absolute;left:72.00px;top:614.04px" class="cls_006"><span class="cls_006">It is often the case that client code does not need the full power of the global </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006">. It</span></div>
<div style="position:absolute;left:72.00px;top:626.40px" class="cls_006"><span class="cls_006">may be that client code only (or mostly) needs memory chunks of specific size. It may be that client code</span></div>
<div style="position:absolute;left:72.00px;top:638.88px" class="cls_006"><span class="cls_006">operates in a single-threaded environment where the concurrency protection provided by the default </span><span class="cls_020">new()</span></div>
<div style="position:absolute;left:72.00px;top:651.72px" class="cls_006"><span class="cls_006">and </span><span class="cls_020">delete()</span><span class="cls_006"> is not really necessary. If this is the case, utilizing the full power of those functions is a</span></div>
<div style="position:absolute;left:72.00px;top:664.08px" class="cls_006"><span class="cls_006">waste of CPU cycles. You can gain significant efficiency by tailoring a memory allocation scheme to</span></div>
<div style="position:absolute;left:72.00px;top:676.08px" class="cls_006"><span class="cls_006">better match your specific requirements.</span></div>
<div style="position:absolute;left:72.00px;top:702.24px" class="cls_006"><span class="cls_006">Say that your code requires frequent allocations and deallocations of objects representing rational numbers:</span></div>
<div style="position:absolute;left:72.00px;top:727.92px" class="cls_020"><span class="cls_020">class Rational {</span></div>
<div style="position:absolute;left:72.00px;top:739.20px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:750.60px" class="cls_020"><span class="cls_020">Rational (int a = 0, int b = 1 ) : n(a), d(b) {}</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">44</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:49416px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background059.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">int n;</span></div>
<div style="position:absolute;left:149.99px;top:81.84px" class="cls_020"><span class="cls_020">// Numerator</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">int d;</span></div>
<div style="position:absolute;left:149.99px;top:93.24px" class="cls_020"><span class="cls_020">// Denominator</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:130.80px" class="cls_006"><span class="cls_006">To measure a baseline performance of the global </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006"> we executed the following test:</span></div>
<div style="position:absolute;left:72.00px;top:156.72px" class="cls_020"><span class="cls_020">int main()</span></div>
<div style="position:absolute;left:72.00px;top:168.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:179.28px" class="cls_020"><span class="cls_020">Rational *array[1000];</span></div>
<div style="position:absolute;left:96.00px;top:201.96px" class="cls_020"><span class="cls_020">// Start timing here</span></div>
<div style="position:absolute;left:96.00px;top:224.64px" class="cls_020"><span class="cls_020">for (int j = 0; j &lt; 500; j++)</span></div>
<div style="position:absolute;left:287.96px;top:224.64px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:119.99px;top:235.92px" class="cls_020"><span class="cls_020">for (int i = 0; i &lt; 1000; i++)</span></div>
<div style="position:absolute;left:317.96px;top:235.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:143.99px;top:247.32px" class="cls_020"><span class="cls_020">array[i] = new Rational(i);</span></div>
<div style="position:absolute;left:119.99px;top:258.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:119.99px;top:270.00px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; 1000; i++)</span></div>
<div style="position:absolute;left:293.96px;top:270.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:143.99px;top:281.28px" class="cls_020"><span class="cls_020">delete array[i];</span></div>
<div style="position:absolute;left:119.99px;top:292.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:303.96px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:326.64px" class="cls_020"><span class="cls_020">// Stop timing here</span></div>
<div style="position:absolute;left:72.00px;top:360.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:386.76px" class="cls_006"><span class="cls_006">Each iteration of the outermost loop executes a thousand allocations and deallocations of </span><span class="cls_020">Rational</span></div>
<div style="position:absolute;left:72.00px;top:399.12px" class="cls_006"><span class="cls_006">objects. Five hundred iterations yield a million operations.</span></div>
<div style="position:absolute;left:72.00px;top:425.16px" class="cls_006"><span class="cls_006">The time elapsed for this code fragment was 1,500 milliseconds. What kind of speed can we gain by</span></div>
<div style="position:absolute;left:72.00px;top:437.76px" class="cls_006"><span class="cls_006">tailoring a specific </span><span class="cls_020">Rational</span><span class="cls_006"> memory manager? To answer the question we need to roll our own memory</span></div>
<div style="position:absolute;left:72.00px;top:450.48px" class="cls_006"><span class="cls_006">manager and overload the </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006"> methods for the </span><span class="cls_020">Rational</span><span class="cls_006"> class.</span></div>
<div style="position:absolute;left:72.00px;top:504.60px" class="cls_016"><span class="cls_016">Version 1: Specialized Rational Memory Manager</span></div>
<div style="position:absolute;left:72.00px;top:536.40px" class="cls_006"><span class="cls_006">To avoid frequent hits to the default manager, the </span><span class="cls_020">Rational</span><span class="cls_006"> class will maintain a static linked list of</span></div>
<div style="position:absolute;left:72.00px;top:549.12px" class="cls_006"><span class="cls_006">preallocated </span><span class="cls_020">Rational</span><span class="cls_006"> objects, which will serve as the free list of available objects. When we need a new</span></div>
<div style="position:absolute;left:72.00px;top:561.96px" class="cls_020"><span class="cls_020">Rational</span><span class="cls_006"> object, we will get one from the free list. When we are done with an object, we will return it to</span></div>
<div style="position:absolute;left:72.00px;top:574.32px" class="cls_006"><span class="cls_006">the free list for future allocations.</span></div>
<div style="position:absolute;left:72.00px;top:600.36px" class="cls_006"><span class="cls_006">We declare a helper structure to link adjacent elements on the free list.</span></div>
<div style="position:absolute;left:72.00px;top:626.04px" class="cls_020"><span class="cls_020">class NextOnFreeList {</span></div>
<div style="position:absolute;left:72.00px;top:637.44px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:648.72px" class="cls_020"><span class="cls_020">NextOnFreeList *next;</span></div>
<div style="position:absolute;left:72.00px;top:660.12px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:686.28px" class="cls_006"><span class="cls_006">The free list is declared as a linked list of </span><span class="cls_020">NextOnFreeList</span><span class="cls_006"> elements.</span></div>
<div style="position:absolute;left:72.00px;top:712.20px" class="cls_020"><span class="cls_020">class Rational {</span></div>
<div style="position:absolute;left:96.00px;top:734.88px" class="cls_020"><span class="cls_020">static NextOnFreeList *freeList;</span></div>
<div style="position:absolute;left:72.00px;top:746.16px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">45</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:50268px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background060.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">If the free list is a list of </span><span class="cls_020">NextOnFreeList</span><span class="cls_006"> structures, you may wonder where the </span><span class="cls_020">Rational</span><span class="cls_006"> objects</span></div>
<div style="position:absolute;left:72.00px;top:84.24px" class="cls_006"><span class="cls_006">reside. Although each element on the free list is declared as a </span><span class="cls_020">NextOnFreeList</span><span class="cls_006"> structure, it is also a</span></div>
<div style="position:absolute;left:72.00px;top:96.96px" class="cls_020"><span class="cls_020">Rational</span><span class="cls_006"> object. When we create an element, we allocate it big enough to contain a </span><span class="cls_020">Rational</span><span class="cls_006"> object.</span></div>
<div style="position:absolute;left:72.00px;top:109.80px" class="cls_006"><span class="cls_006">To step from one object to the next, we will use the first few bytes of each </span><span class="cls_020">Rational</span><span class="cls_006"> object to point to</span></div>
<div style="position:absolute;left:72.00px;top:122.64px" class="cls_006"><span class="cls_006">the next object on the free list. We do that by casting the object into a pointer of type </span><span class="cls_020">NextOnFreeList</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:149.40px" class="cls_006"><span class="cls_006">The free list, then, will have a dual role as a sequence of </span><span class="cls_020">Rational</span><span class="cls_006"> objects as well as a sequence of</span></div>
<div style="position:absolute;left:72.00px;top:162.24px" class="cls_020"><span class="cls_020">NextOnFreeList</span><span class="cls_006"> elements (</span><span class="cls_036">Figure 6.1</span><span class="cls_006">).</span></div>
<div style="position:absolute;left:189.00px;top:187.80px" class="cls_021"><span class="cls_021">Figure 6.1. A free list of </span><span class="cls_024">Rational</span><span class="cls_021"> objects.</span></div>
<div style="position:absolute;left:72.00px;top:669.12px" class="cls_006"><span class="cls_006">The free list is declared as a static member of the </span><span class="cls_020">Rational</span><span class="cls_006"> class. The static free list is manipulated by</span></div>
<div style="position:absolute;left:72.00px;top:681.84px" class="cls_006"><span class="cls_006">the </span><span class="cls_020">Rational new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006"> operators. These operators overload the global ones.</span></div>
<div style="position:absolute;left:72.00px;top:707.88px" class="cls_020"><span class="cls_020">class Rational {</span></div>
<div style="position:absolute;left:72.00px;top:719.16px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:730.56px" class="cls_020"><span class="cls_020">Rational (int a = 0, int b = 1 ) : n(a), d(b) {}</span></div>
<div style="position:absolute;left:96.00px;top:753.12px" class="cls_020"><span class="cls_020">inline void *operator new(size_t size);</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">46</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:51120px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background061.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">inline void operator delete(void *doomed, size_t size);</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">static void newMemPool() { expandTheFreeList(); }</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">static void deleteMemPool();</span></div>
<div style="position:absolute;left:72.00px;top:127.20px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">static NextOnFreeList *freeList;</span></div>
<div style="position:absolute;left:311.96px;top:138.48px" class="cls_020"><span class="cls_020">// A free list of</span></div>
<div style="position:absolute;left:311.96px;top:149.88px" class="cls_020"><span class="cls_020">// Rational objects.</span></div>
<div style="position:absolute;left:96.00px;top:161.16px" class="cls_020"><span class="cls_020">static void expandTheFreeList();</span></div>
<div style="position:absolute;left:96.00px;top:172.56px" class="cls_020"><span class="cls_020">enum { EXPANSION_SIZE = 32};</span></div>
<div style="position:absolute;left:96.00px;top:195.12px" class="cls_020"><span class="cls_020">int n;</span></div>
<div style="position:absolute;left:149.99px;top:195.12px" class="cls_020"><span class="cls_020">// Numerator</span></div>
<div style="position:absolute;left:96.00px;top:206.52px" class="cls_020"><span class="cls_020">int d;</span></div>
<div style="position:absolute;left:149.99px;top:206.52px" class="cls_020"><span class="cls_020">// Denominator</span></div>
<div style="position:absolute;left:72.00px;top:217.80px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:244.08px" class="cls_006"><span class="cls_006">Operator </span><span class="cls_020">new()</span><span class="cls_006"> allocates a new </span><span class="cls_020">Rational</span><span class="cls_006"> object from the free list. If the free list is empty, it will get</span></div>
<div style="position:absolute;left:72.00px;top:256.32px" class="cls_006"><span class="cls_006">expanded. We pick off the head of the free list and return it after adjusting the free list pointer.</span></div>
<div style="position:absolute;left:72.00px;top:282.00px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:293.40px" class="cls_020"><span class="cls_020">void * Rational::operator new(size_t size)</span></div>
<div style="position:absolute;left:72.00px;top:304.68px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:315.96px" class="cls_020"><span class="cls_020">if (0 == freeList) {// If the list is empty, fill it up.</span></div>
<div style="position:absolute;left:119.99px;top:327.36px" class="cls_020"><span class="cls_020">expandTheFreeList();</span></div>
<div style="position:absolute;left:96.00px;top:338.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:361.32px" class="cls_020"><span class="cls_020">NextOnFreeList *head = freeList;</span></div>
<div style="position:absolute;left:96.00px;top:372.60px" class="cls_020"><span class="cls_020">freeList = head->next;</span></div>
<div style="position:absolute;left:96.00px;top:395.28px" class="cls_020"><span class="cls_020">return head;</span></div>
<div style="position:absolute;left:72.00px;top:406.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:432.84px" class="cls_006"><span class="cls_006">Operator </span><span class="cls_020">delete()</span><span class="cls_006"> returns a </span><span class="cls_020">Rational</span><span class="cls_006"> object to the free list by simply adding it to the front of the free</span></div>
<div style="position:absolute;left:72.00px;top:445.08px" class="cls_006"><span class="cls_006">list.</span></div>
<div style="position:absolute;left:72.00px;top:470.88px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:482.16px" class="cls_020"><span class="cls_020">void Rational::operator delete(void *doomed, size_t size)</span></div>
<div style="position:absolute;left:72.00px;top:493.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:504.84px" class="cls_020"><span class="cls_020">NextOnFreeList *head = static_cast &lt;NextOnFreeList *> doomed;</span></div>
<div style="position:absolute;left:96.00px;top:516.12px" class="cls_020"><span class="cls_020">head->next = freeList;</span></div>
<div style="position:absolute;left:96.00px;top:527.52px" class="cls_020"><span class="cls_020">freeList</span></div>
<div style="position:absolute;left:155.98px;top:527.52px" class="cls_020"><span class="cls_020">= head;</span></div>
<div style="position:absolute;left:72.00px;top:538.80px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:565.08px" class="cls_006"><span class="cls_006">When the free list is exhausted, we must allocate more </span><span class="cls_020">Rational</span><span class="cls_006"> objects from the heap. There is a little</span></div>
<div style="position:absolute;left:72.00px;top:577.80px" class="cls_006"><span class="cls_006">subtlety here that should be pointed out. Switching between </span><span class="cls_020">Rational</span><span class="cls_006"> and </span><span class="cls_020">NextOnFreeList</span><span class="cls_006"> types is</span></div>
<div style="position:absolute;left:72.00px;top:590.16px" class="cls_006"><span class="cls_006">slightly dangerous. We need to make sure that the elements of the free list are large enough to serve as</span></div>
<div style="position:absolute;left:72.00px;top:602.64px" class="cls_006"><span class="cls_006">either type. When we populate the free list with </span><span class="cls_020">Rational</span><span class="cls_006"> objects, we have to remember to compare the</span></div>
<div style="position:absolute;left:72.00px;top:615.48px" class="cls_006"><span class="cls_006">size of </span><span class="cls_020">Rational</span><span class="cls_006"> to the size of </span><span class="cls_020">NextOnFreeList</span><span class="cls_006"> and allocate the larger of the two.</span></div>
<div style="position:absolute;left:72.00px;top:641.40px" class="cls_020"><span class="cls_020">void Rational::expandTheFreeList()</span></div>
<div style="position:absolute;left:72.00px;top:652.80px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:664.08px" class="cls_020"><span class="cls_020">// We must allocate an object large enough to contain the next</span></div>
<div style="position:absolute;left:96.00px;top:675.48px" class="cls_020"><span class="cls_020">// pointer.</span></div>
<div style="position:absolute;left:96.00px;top:686.76px" class="cls_020"><span class="cls_020">size_t size = (sizeof(Rational) > sizeof(NextOnFreeList *)) ?</span></div>
<div style="position:absolute;left:119.99px;top:698.04px" class="cls_020"><span class="cls_020">sizeof(Rational) : sizeof(NextOnFreeList *);</span></div>
<div style="position:absolute;left:96.00px;top:720.72px" class="cls_020"><span class="cls_020">NextOnFreeList *runner =</span></div>
<div style="position:absolute;left:96.00px;top:732.12px" class="cls_020"><span class="cls_020">static_cast &lt;NextOnFreeList *> new char [size];</span></div>
<div style="position:absolute;left:96.00px;top:754.68px" class="cls_020"><span class="cls_020">freeList =  runner;</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:51972px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background062.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">for (int i = 0; i &lt; EXPANSION_SIZE; i++) {</span></div>
<div style="position:absolute;left:119.99px;top:81.84px" class="cls_020"><span class="cls_020">runner->next =</span></div>
<div style="position:absolute;left:143.99px;top:93.24px" class="cls_020"><span class="cls_020">static_cast &lt;NextOnFreeList *> new char [size];</span></div>
<div style="position:absolute;left:119.99px;top:104.52px" class="cls_020"><span class="cls_020">runner = runner->next;</span></div>
<div style="position:absolute;left:96.00px;top:115.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">runner->next = 0;</span></div>
<div style="position:absolute;left:72.00px;top:149.88px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:176.04px" class="cls_006"><span class="cls_006">This implementation of </span><span class="cls_020">expandTheFreeList(</span><span class="cls_006">), in itself, is not optimal. It invokes </span><span class="cls_020">operator</span><span class="cls_006"> </span><span class="cls_020">new</span></div>
<div style="position:absolute;left:72.00px;top:188.88px" class="cls_006"><span class="cls_006">multiple times, once per free list element. It would be more efficient to invoke </span><span class="cls_020">operator</span><span class="cls_006"> </span><span class="cls_020">new</span><span class="cls_006"> once, get a</span></div>
<div style="position:absolute;left:72.00px;top:201.12px" class="cls_006"><span class="cls_006">large block of memory, and slice it ourselves into multiple elements [</span><span class="cls_036">Mey97</span><span class="cls_006">]. In isolation, this is a correct</span></div>
<div style="position:absolute;left:72.00px;top:213.24px" class="cls_006"><span class="cls_006">observation. In reality, however, we build a memory manager with the idea that expanding and shrinking it</span></div>
<div style="position:absolute;left:72.00px;top:225.36px" class="cls_006"><span class="cls_006">will be performed very infrequently, otherwise we must revisit the implementation and fix it. Our</span></div>
<div style="position:absolute;left:72.00px;top:237.36px" class="cls_006"><span class="cls_006">implementation is such that the free list never shrinks; it will grow to a steady-state size and stay there. If</span></div>
<div style="position:absolute;left:72.00px;top:249.96px" class="cls_006"><span class="cls_006">you want to implement a more efficient version of </span><span class="cls_020">expandTheFreeList()</span><span class="cls_006">, there is no harm in it, but it</span></div>
<div style="position:absolute;left:72.00px;top:262.20px" class="cls_006"><span class="cls_006">is not likely to have an effect on overall performance.</span></div>
<div style="position:absolute;left:72.00px;top:288.00px" class="cls_020"><span class="cls_020">void Rational::deleteMemPool()</span></div>
<div style="position:absolute;left:72.00px;top:299.28px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:310.68px" class="cls_020"><span class="cls_020">NextOnFreeList *nextPtr;</span></div>
<div style="position:absolute;left:96.00px;top:321.96px" class="cls_020"><span class="cls_020">for (nextPtr = freeList; nextPtr != NULL; nextPtr = freeList) {</span></div>
<div style="position:absolute;left:119.99px;top:333.24px" class="cls_020"><span class="cls_020">freeList = freeList->next;</span></div>
<div style="position:absolute;left:119.99px;top:344.64px" class="cls_020"><span class="cls_020">delete [] nextPtr;</span></div>
<div style="position:absolute;left:96.00px;top:355.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:367.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:393.48px" class="cls_006"><span class="cls_006">We repeated the following performance test, but this time, the use of </span><span class="cls_020">new</span><span class="cls_006"> and </span><span class="cls_020">delete</span><span class="cls_006"> invokes the</span></div>
<div style="position:absolute;left:72.00px;top:406.20px" class="cls_006"><span class="cls_006">overloaded operators of the </span><span class="cls_020">Rational</span><span class="cls_006"> class:</span></div>
<div style="position:absolute;left:72.00px;top:432.24px" class="cls_020"><span class="cls_020">NextOnFreeList *Rational::freeList = 0;</span></div>
<div style="position:absolute;left:72.00px;top:454.92px" class="cls_020"><span class="cls_020">int main()</span></div>
<div style="position:absolute;left:72.00px;top:466.20px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:488.88px" class="cls_020"><span class="cls_020">Rational *array[1000];</span></div>
<div style="position:absolute;left:96.00px;top:511.56px" class="cls_020"><span class="cls_020">Rational::newMemPool();</span></div>
<div style="position:absolute;left:96.00px;top:534.12px" class="cls_020"><span class="cls_020">// Start timing here</span></div>
<div style="position:absolute;left:96.00px;top:556.80px" class="cls_020"><span class="cls_020">for (int j = 0; j &lt; 500; j++)</span></div>
<div style="position:absolute;left:287.96px;top:556.80px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:119.99px;top:568.20px" class="cls_020"><span class="cls_020">for (int i = 0; i &lt; 1000; i++)</span></div>
<div style="position:absolute;left:317.96px;top:568.20px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:143.99px;top:579.48px" class="cls_020"><span class="cls_020">array[i] = new Rational(i);</span></div>
<div style="position:absolute;left:119.99px;top:590.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:119.99px;top:602.16px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; 1000; i++)</span></div>
<div style="position:absolute;left:293.96px;top:602.16px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:143.99px;top:613.44px" class="cls_020"><span class="cls_020">delete array[i];</span></div>
<div style="position:absolute;left:119.99px;top:624.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:636.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:658.80px" class="cls_020"><span class="cls_020">// Stop timing here</span></div>
<div style="position:absolute;left:96.00px;top:681.48px" class="cls_020"><span class="cls_020">Rational::deleteMemPool();</span></div>
<div style="position:absolute;left:72.00px;top:704.04px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:730.32px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006"> calls now result in invocations of the </span><span class="cls_020">Rational::operator new()</span><span class="cls_006"> and</span></div>
<div style="position:absolute;left:72.00px;top:743.04px" class="cls_020"><span class="cls_020">delete()</span><span class="cls_006"> calls that we implemented. The execution time of the loop dropped from 1,500 milliseconds to</span></div>
<div style="position:absolute;left:72.00px;top:755.40px" class="cls_006"><span class="cls_006">43 milliseconds. This is more than an order-of-magnitude improvement (</span><span class="cls_036">Figure 6.2</span><span class="cls_006">).</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">48</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:52824px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background063.jpg" width=595 height=842></div>
<div style="position:absolute;left:91.80px;top:70.20px" class="cls_021"><span class="cls_021">Figure 6.2. Global </span><span class="cls_024">new()</span><span class="cls_021"> and </span><span class="cls_024">delete()</span><span class="cls_021"> compared to a </span><span class="cls_024">Rational</span><span class="cls_021"> memory pool.</span></div>
<div style="position:absolute;left:72.00px;top:334.68px" class="cls_006"><span class="cls_006">Where does the speed gain come from? Since we are in a single-threaded environment, our </span><span class="cls_020">Rational</span></div>
<div style="position:absolute;left:72.00px;top:347.04px" class="cls_006"><span class="cls_006">memory management routines do not bother with concurrency issues. We do not protect memory</span></div>
<div style="position:absolute;left:72.00px;top:359.16px" class="cls_006"><span class="cls_006">manipulation because we don't have any critical sections to worry about. We also take advantage of the</span></div>
<div style="position:absolute;left:72.00px;top:371.64px" class="cls_006"><span class="cls_006">fact that all allocations are of fixed size—the size of a </span><span class="cls_020">Rational</span><span class="cls_006"> object. Fixed-size allocations are much</span></div>
<div style="position:absolute;left:72.00px;top:384.00px" class="cls_006"><span class="cls_006">simpler; there are a lot less computations to perform (like finding the next available memory chunk big</span></div>
<div style="position:absolute;left:72.00px;top:396.00px" class="cls_006"><span class="cls_006">enough to satisfy the request). We simply adjust the free list pointer, and we are done.</span></div>
<div style="position:absolute;left:72.00px;top:449.88px" class="cls_016"><span class="cls_016">Version 2: Fixed-Size Object Memory Pool</span></div>
<div style="position:absolute;left:72.00px;top:481.68px" class="cls_006"><span class="cls_006">Version 1 is limited to managing </span><span class="cls_020">Rational</span><span class="cls_006"> objects only. What if we wanted a memory manager for some</span></div>
<div style="position:absolute;left:72.00px;top:494.04px" class="cls_006"><span class="cls_006">other class of a different size? Duplicating the memory management logic for every class will be an</span></div>
<div style="position:absolute;left:72.00px;top:506.52px" class="cls_006"><span class="cls_006">unnecessary waste of developer time. If we look at the implementation of the </span><span class="cls_020">Rational</span><span class="cls_006"> memory manager,</span></div>
<div style="position:absolute;left:72.00px;top:519.36px" class="cls_006"><span class="cls_006">it becomes apparent that the memory management logic is really independent of the particular </span><span class="cls_020">Rational</span></div>
<div style="position:absolute;left:72.00px;top:531.72px" class="cls_006"><span class="cls_006">class. The only dependency is the size of the class object—a good candidate for a template implementation</span></div>
<div style="position:absolute;left:72.00px;top:543.72px" class="cls_006"><span class="cls_006">of a memory pool. The memory pool will manage a pool of available objects of a certain type. A template</span></div>
<div style="position:absolute;left:72.00px;top:555.84px" class="cls_006"><span class="cls_006">implementation would allow us to vary the specific class that we are managing.</span></div>
<div style="position:absolute;left:72.00px;top:581.52px" class="cls_020"><span class="cls_020">template &lt; class T ></span></div>
<div style="position:absolute;left:72.00px;top:592.80px" class="cls_020"><span class="cls_020">class MemoryPool {</span></div>
<div style="position:absolute;left:72.00px;top:604.20px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:615.48px" class="cls_020"><span class="cls_020">MemoryPool (size_t size = EXPANSION_SIZE);</span></div>
<div style="position:absolute;left:96.00px;top:626.88px" class="cls_020"><span class="cls_020">~MemoryPool ();</span></div>
<div style="position:absolute;left:96.00px;top:649.44px" class="cls_020"><span class="cls_020">// Allocate a T element from the free list.</span></div>
<div style="position:absolute;left:96.00px;top:660.84px" class="cls_020"><span class="cls_020">inline void* alloc (size_t size);</span></div>
<div style="position:absolute;left:96.00px;top:683.52px" class="cls_020"><span class="cls_020">// Return a T element to the free list.</span></div>
<div style="position:absolute;left:96.00px;top:694.80px" class="cls_020"><span class="cls_020">inline void free (void *someElement);</span></div>
<div style="position:absolute;left:72.00px;top:706.08px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:717.48px" class="cls_020"><span class="cls_020">// next element on the free list.</span></div>
<div style="position:absolute;left:96.00px;top:728.76px" class="cls_020"><span class="cls_020">MemoryPool&lt;T> *next;</span></div>
<div style="position:absolute;left:96.00px;top:751.44px" class="cls_020"><span class="cls_020">// If the freeList is empty, expand it by this amount.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">49</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:53676px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background064.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">enum { EXPANSION_SIZE = 32};</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">// Add free elements to the free list</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">void expandTheFreeList(int howMany = EXPANSION_SIZE);</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">MemoryPool</span><span class="cls_006"> constructor initializes the free list. The </span><span class="cls_020">size</span><span class="cls_006"> argument specifies the initial length of the</span></div>
<div style="position:absolute;left:72.00px;top:154.32px" class="cls_006"><span class="cls_006">free list.</span></div>
<div style="position:absolute;left:72.00px;top:180.12px" class="cls_020"><span class="cls_020">template &lt; class T ></span></div>
<div style="position:absolute;left:72.00px;top:191.40px" class="cls_020"><span class="cls_020">MemoryPool &lt; T > :: MemoryPool (size_t size)</span></div>
<div style="position:absolute;left:72.00px;top:202.68px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:214.08px" class="cls_020"><span class="cls_020">expandTheFreeList(size);</span></div>
<div style="position:absolute;left:72.00px;top:225.36px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:251.04px" class="cls_006"><span class="cls_006">The destructor marches down the free list and deletes all its elements.</span></div>
<div style="position:absolute;left:72.00px;top:276.84px" class="cls_020"><span class="cls_020">template &lt; class T ></span></div>
<div style="position:absolute;left:72.00px;top:288.12px" class="cls_020"><span class="cls_020">MemoryPool &lt; T > :: ~MemoryPool ()</span></div>
<div style="position:absolute;left:72.00px;top:299.40px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:310.80px" class="cls_020"><span class="cls_020">MemoryPool&lt;T> *nextPtr = next;</span></div>
<div style="position:absolute;left:96.00px;top:322.08px" class="cls_020"><span class="cls_020">for (nextPtr = next; nextPtr != NULL; nextPtr = next) {</span></div>
<div style="position:absolute;left:119.99px;top:333.48px" class="cls_020"><span class="cls_020">next = next->next;</span></div>
<div style="position:absolute;left:119.99px;top:344.76px" class="cls_020"><span class="cls_020">delete [] nextPtr;</span></div>
<div style="position:absolute;left:96.00px;top:356.04px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:367.44px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:393.60px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">alloc()</span><span class="cls_006"> member function allocates space large enough for a </span><span class="cls_020">T</span><span class="cls_006"> element. If the free list has been</span></div>
<div style="position:absolute;left:72.00px;top:406.44px" class="cls_006"><span class="cls_006">depleted, we call </span><span class="cls_020">expandTheFreeList()</span><span class="cls_006"> to replenish it.</span></div>
<div style="position:absolute;left:72.00px;top:432.36px" class="cls_020"><span class="cls_020">template &lt; class T ></span></div>
<div style="position:absolute;left:72.00px;top:443.64px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:455.04px" class="cls_020"><span class="cls_020">void* MemoryPool &lt; T > :: alloc (size_t)</span></div>
<div style="position:absolute;left:72.00px;top:466.32px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:477.72px" class="cls_020"><span class="cls_020">if (!next) {</span></div>
<div style="position:absolute;left:119.99px;top:489.00px" class="cls_020"><span class="cls_020">expandTheFreeList();</span></div>
<div style="position:absolute;left:96.00px;top:500.28px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:522.96px" class="cls_020"><span class="cls_020">MemoryPool&lt;T> *head = next;</span></div>
<div style="position:absolute;left:96.00px;top:534.36px" class="cls_020"><span class="cls_020">next = head->next;</span></div>
<div style="position:absolute;left:96.00px;top:556.92px" class="cls_020"><span class="cls_020">return head;</span></div>
<div style="position:absolute;left:72.00px;top:568.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:594.48px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">free()</span><span class="cls_006"> member function deallocates a </span><span class="cls_020">T</span><span class="cls_006"> element by placing it back on the free list.</span></div>
<div style="position:absolute;left:72.00px;top:620.40px" class="cls_020"><span class="cls_020">template &lt; class T ></span></div>
<div style="position:absolute;left:72.00px;top:631.80px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:643.08px" class="cls_020"><span class="cls_020">void MemoryPool &lt; T > :: free (void *doomed)</span></div>
<div style="position:absolute;left:72.00px;top:654.36px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:665.76px" class="cls_020"><span class="cls_020">MemoryPool&lt;T> *head = static_cast &lt;MemoryPool&lt;T> *> doomed;</span></div>
<div style="position:absolute;left:96.00px;top:688.44px" class="cls_020"><span class="cls_020">head->next = next;</span></div>
<div style="position:absolute;left:96.00px;top:699.72px" class="cls_020"><span class="cls_020">next</span></div>
<div style="position:absolute;left:131.99px;top:699.72px" class="cls_020"><span class="cls_020">= head;</span></div>
<div style="position:absolute;left:72.00px;top:711.00px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">50</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:54528px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background065.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_020"><span class="cls_020">expandTheFreeList()</span><span class="cls_006"> is used to add new elements to the free list. The new elements are allocated</span></div>
<div style="position:absolute;left:72.00px;top:83.76px" class="cls_006"><span class="cls_006">from the heap and stitched together into a linked list. This member function is called when the free list is</span></div>
<div style="position:absolute;left:72.00px;top:95.76px" class="cls_006"><span class="cls_006">depleted.</span></div>
<div style="position:absolute;left:72.00px;top:121.56px" class="cls_020"><span class="cls_020">template &lt; class T ></span></div>
<div style="position:absolute;left:72.00px;top:132.84px" class="cls_020"><span class="cls_020">void MemoryPool &lt; T > :: expandTheFreeList(int howMany)</span></div>
<div style="position:absolute;left:72.00px;top:144.12px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:155.52px" class="cls_020"><span class="cls_020">// We must allocate an object large enough to contain the</span></div>
<div style="position:absolute;left:96.00px;top:166.80px" class="cls_020"><span class="cls_020">// next pointer.</span></div>
<div style="position:absolute;left:96.00px;top:178.20px" class="cls_020"><span class="cls_020">size_t size = (sizeof(T) > sizeof(MemoryPool&lt;T> *)) ?</span></div>
<div style="position:absolute;left:119.99px;top:189.48px" class="cls_020"><span class="cls_020">sizeof(T) : sizeof(MemoryPool&lt;T> *);</span></div>
<div style="position:absolute;left:96.00px;top:212.16px" class="cls_020"><span class="cls_020">MemoryPool&lt;T> *runner = static_cast &lt;MemoryPool&lt;T> *> new char</span></div>
<div style="position:absolute;left:72.00px;top:223.44px" class="cls_020"><span class="cls_020">[size];</span></div>
<div style="position:absolute;left:96.00px;top:246.12px" class="cls_020"><span class="cls_020">next =  runner;</span></div>
<div style="position:absolute;left:96.00px;top:257.40px" class="cls_020"><span class="cls_020">for (int i = 0; i &lt; howMany ; i++) {</span></div>
<div style="position:absolute;left:119.99px;top:268.80px" class="cls_020"><span class="cls_020">runner->next =</span></div>
<div style="position:absolute;left:143.99px;top:280.08px" class="cls_020"><span class="cls_020">static_cast &lt;MemoryPool&lt;T> *> new char [size];</span></div>
<div style="position:absolute;left:119.99px;top:291.48px" class="cls_020"><span class="cls_020">runner = runner->next;</span></div>
<div style="position:absolute;left:96.00px;top:302.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:314.04px" class="cls_020"><span class="cls_020">runner->next = 0;</span></div>
<div style="position:absolute;left:72.00px;top:325.44px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:351.60px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">Rational</span><span class="cls_006"> class no longer needs to maintain its own free list. This responsibility is delegated to the</span></div>
<div style="position:absolute;left:72.00px;top:364.44px" class="cls_020"><span class="cls_020">MemoryPool</span><span class="cls_006"> class.</span></div>
<div style="position:absolute;left:72.00px;top:390.36px" class="cls_020"><span class="cls_020">class Rational {</span></div>
<div style="position:absolute;left:72.00px;top:401.64px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:413.04px" class="cls_020"><span class="cls_020">Rational (int a = 0, int b = 1 ) : n(a), d(b) {}</span></div>
<div style="position:absolute;left:96.00px;top:435.72px" class="cls_020"><span class="cls_020">void *operator new(size_t size) { return memPool->alloc(size); }</span></div>
<div style="position:absolute;left:96.00px;top:447.00px" class="cls_020"><span class="cls_020">void operator delete(void *doomed,size_t size)</span></div>
<div style="position:absolute;left:179.98px;top:458.28px" class="cls_020"><span class="cls_020">{ memPool->free(doomed); }</span></div>
<div style="position:absolute;left:96.00px;top:480.96px" class="cls_020"><span class="cls_020">static void newMemPool() { memPool = new MemoryPool &lt;Rational>; }</span></div>
<div style="position:absolute;left:96.00px;top:492.36px" class="cls_020"><span class="cls_020">static void deleteMemPool() { delete memPool; }</span></div>
<div style="position:absolute;left:72.00px;top:503.64px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:514.92px" class="cls_020"><span class="cls_020">int n; // Numerator</span></div>
<div style="position:absolute;left:96.00px;top:526.32px" class="cls_020"><span class="cls_020">int d; // Denominator</span></div>
<div style="position:absolute;left:96.00px;top:549.00px" class="cls_020"><span class="cls_020">static MemoryPool &lt;Rational> *memPool;</span></div>
<div style="position:absolute;left:72.00px;top:560.28px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:586.44px" class="cls_006"><span class="cls_006">We eliminated the static </span><span class="cls_020">freeList</span><span class="cls_006"> member pointer plus its related functions and replaced it with a</span></div>
<div style="position:absolute;left:72.00px;top:599.28px" class="cls_006"><span class="cls_006">pointer to a memory pool. In the preceding </span><span class="cls_020">Rational</span><span class="cls_006"> implementation, the template memory pool was</span></div>
<div style="position:absolute;left:72.00px;top:612.12px" class="cls_006"><span class="cls_006">specialized in its definition to be a </span><span class="cls_020">Rational</span><span class="cls_006"> memory pool.</span></div>
<div style="position:absolute;left:72.00px;top:638.40px" class="cls_006"><span class="cls_006">Our test loop is almost identical to the previous one:</span></div>
<div style="position:absolute;left:72.00px;top:664.08px" class="cls_020"><span class="cls_020">MemoryPool &lt;Rational> *Rational::memPool = 0;</span></div>
<div style="position:absolute;left:72.00px;top:686.76px" class="cls_020"><span class="cls_020">int main()</span></div>
<div style="position:absolute;left:72.00px;top:698.04px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:720.72px" class="cls_020"><span class="cls_020">Rational *array[1000];</span></div>
<div style="position:absolute;left:96.00px;top:743.40px" class="cls_020"><span class="cls_020">Rational::newMemPool();</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">51</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:55380px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background066.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">// Start timing here</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">for (int j = 0; j &lt; 500; j++)</span></div>
<div style="position:absolute;left:287.96px;top:93.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:119.99px;top:104.52px" class="cls_020"><span class="cls_020">for (int i = 0; i &lt; 1000; i++)</span></div>
<div style="position:absolute;left:317.96px;top:104.52px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:143.99px;top:115.92px" class="cls_020"><span class="cls_020">array[i] = new Rational(i);</span></div>
<div style="position:absolute;left:119.99px;top:127.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:119.99px;top:138.48px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; 1000; i++)</span></div>
<div style="position:absolute;left:293.96px;top:138.48px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:143.99px;top:149.88px" class="cls_020"><span class="cls_020">delete array[i];</span></div>
<div style="position:absolute;left:119.99px;top:161.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:172.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:195.12px" class="cls_020"><span class="cls_020">// Stop timing here</span></div>
<div style="position:absolute;left:96.00px;top:217.80px" class="cls_020"><span class="cls_020">Rational::deleteMemPool();</span></div>
<div style="position:absolute;left:72.00px;top:251.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:278.04px" class="cls_006"><span class="cls_006">We expected this measurement to be identical to the previous </span><span class="cls_020">Rational</span><span class="cls_006"> free list memory manager</span></div>
<div style="position:absolute;left:72.00px;top:290.28px" class="cls_006"><span class="cls_006">(Version 1), which executed the loop in 43 milliseconds. For some reason, the template version (Version 2)</span></div>
<div style="position:absolute;left:72.00px;top:302.40px" class="cls_006"><span class="cls_006">of the memory pool clocked in at 63 ms (</span><span class="cls_036">Figure 6.3</span><span class="cls_006">), a little slower than the previous version. Also, the</span></div>
<div style="position:absolute;left:72.00px;top:314.88px" class="cls_006"><span class="cls_006">assembler code generated for Version 2 had some extra instructions. Still, it beats the global </span><span class="cls_020">new()</span><span class="cls_006"> and</span></div>
<div style="position:absolute;left:72.00px;top:327.72px" class="cls_020"><span class="cls_020">delete()</span><span class="cls_006"> by more than an order of magnitude.</span></div>
<div style="position:absolute;left:139.80px;top:354.24px" class="cls_021"><span class="cls_021">Figure 6.3. Adding a template memory pool for generic objects.</span></div>
<div style="position:absolute;left:72.00px;top:616.92px" class="cls_006"><span class="cls_006">So far, we have focused on a single point in the design space of memory allocation. That was the specific</span></div>
<div style="position:absolute;left:72.00px;top:628.92px" class="cls_006"><span class="cls_006">problem of fixed-size allocations in a single-threaded environment. We now extend our options by</span></div>
<div style="position:absolute;left:72.00px;top:641.04px" class="cls_006"><span class="cls_006">expanding in the size dimension. We stay in the realm of single-threaded memory pools but relax the</span></div>
<div style="position:absolute;left:72.00px;top:653.16px" class="cls_006"><span class="cls_006">assumption that all allocations are of the same size.</span></div>
<div style="position:absolute;left:72.00px;top:706.92px" class="cls_016"><span class="cls_016">Version 3: Single-Threaded Variable-Size Memory Manager</span></div>
<div style="position:absolute;left:72.00px;top:738.24px" class="cls_006"><span class="cls_006">Speeding up the allocation and deallocation of fixed-size memory will only take you so far. There is a class</span></div>
<div style="position:absolute;left:72.00px;top:750.36px" class="cls_006"><span class="cls_006">of applications that require variable-size memory allocations. A Web server implementation is a perfect</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">52</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:56232px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background067.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">example. Typical implementations of a Web server are gigantic string crunchers. If you peek into the code</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">you'll find that the handling of a single HTTP request requires a large number of string surgeries. Many of</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">those calls require space allocation to create new or duplicated strings. Furthermore, you cannot tell in</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">advance how many string allocations would be necessary and of what size. Potentially, strings are</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">unbounded. The nature of string manipulations is dictated by the content of the particular HTTP request. A</span></div>
<div style="position:absolute;left:72.00px;top:131.76px" class="cls_006"><span class="cls_006">fixed-size memory manager would fall short of the requirement. Relying on the global </span><span class="cls_020">new()</span><span class="cls_006"> and</span></div>
<div style="position:absolute;left:72.00px;top:144.60px" class="cls_020"><span class="cls_020">delete()</span><span class="cls_006">, however, is out of the question. The global </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006"> are expensive. They</span></div>
<div style="position:absolute;left:72.00px;top:156.96px" class="cls_006"><span class="cls_006">consume hundreds of instructions and moreover, they contain mutually exclusive critical sections that</span></div>
<div style="position:absolute;left:72.00px;top:168.96px" class="cls_006"><span class="cls_006">prevent concurrent thread execution and consequently hurt scalabilty. It would damage the speed and</span></div>
<div style="position:absolute;left:72.00px;top:181.08px" class="cls_006"><span class="cls_006">scalability of a Web server. This is a perfect place for a home-grown, variable-size memory manager.</span></div>
<div style="position:absolute;left:72.00px;top:207.12px" class="cls_006"><span class="cls_006">There are many ways to implement a variable-size memory manager [</span><span class="cls_036">ALG95</span><span class="cls_006">]. The one we used in our</span></div>
<div style="position:absolute;left:72.00px;top:219.24px" class="cls_006"><span class="cls_006">Web server is discussed next.</span></div>
<div style="position:absolute;left:72.00px;top:245.76px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">MemoryChunk</span><span class="cls_006"> class replaces the </span><span class="cls_020">NextOnFreeList</span><span class="cls_006"> class we used in earlier versions. It is used to</span></div>
<div style="position:absolute;left:72.00px;top:258.12px" class="cls_006"><span class="cls_006">string together chunks of memory of varying sizes into a sequence of chunks.</span></div>
<div style="position:absolute;left:72.00px;top:283.80px" class="cls_020"><span class="cls_020">class MemoryChunk {</span></div>
<div style="position:absolute;left:72.00px;top:295.08px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:306.48px" class="cls_020"><span class="cls_020">MemoryChunk (MemoryChunk *nextChunk, size_t chunkSize);</span></div>
<div style="position:absolute;left:96.00px;top:317.76px" class="cls_020"><span class="cls_020">~MemoryChunk() {delete mem; }</span></div>
<div style="position:absolute;left:96.00px;top:340.44px" class="cls_020"><span class="cls_020">inline void *alloc (size_t size);</span></div>
<div style="position:absolute;left:96.00px;top:351.72px" class="cls_020"><span class="cls_020">inline void free (void* someElement);</span></div>
<div style="position:absolute;left:96.00px;top:374.40px" class="cls_020"><span class="cls_020">// Pointer to next memory chunk on the list.</span></div>
<div style="position:absolute;left:96.00px;top:385.80px" class="cls_020"><span class="cls_020">MemoryChunk *nextMemChunk()</span></div>
<div style="position:absolute;left:275.96px;top:385.80px" class="cls_020"><span class="cls_020">{return next;}</span></div>
<div style="position:absolute;left:96.00px;top:408.36px" class="cls_020"><span class="cls_020">// How much space do we have left on this memory chunk?</span></div>
<div style="position:absolute;left:96.00px;top:419.76px" class="cls_020"><span class="cls_020">size_t spaceAvailable()</span></div>
<div style="position:absolute;left:131.99px;top:431.04px" class="cls_020"><span class="cls_020">{ return chunkSize -</span></div>
<div style="position:absolute;left:269.96px;top:431.04px" class="cls_020"><span class="cls_020">bytesAlreadyAllocated; }</span></div>
<div style="position:absolute;left:96.00px;top:453.72px" class="cls_020"><span class="cls_020">// this is the default size of a single memory chunk.</span></div>
<div style="position:absolute;left:96.00px;top:465.00px" class="cls_020"><span class="cls_020">enum { DEFAULT_CHUNK_SIZE = 4096 };</span></div>
<div style="position:absolute;left:72.00px;top:476.40px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:487.68px" class="cls_020"><span class="cls_020">MemoryChunk *next;</span></div>
<div style="position:absolute;left:96.00px;top:499.08px" class="cls_020"><span class="cls_020">void</span></div>
<div style="position:absolute;left:167.98px;top:499.08px" class="cls_020"><span class="cls_020">*mem;</span></div>
<div style="position:absolute;left:96.00px;top:521.64px" class="cls_020"><span class="cls_020">// The size of a single memory chunk.</span></div>
<div style="position:absolute;left:96.00px;top:533.04px" class="cls_020"><span class="cls_020">size_t chunkSize;</span></div>
<div style="position:absolute;left:96.00px;top:555.72px" class="cls_020"><span class="cls_020">// This many bytes already allocated on the current memory chunk.</span></div>
<div style="position:absolute;left:96.00px;top:567.00px" class="cls_020"><span class="cls_020">size_t bytesAlreadyAllocated;</span></div>
<div style="position:absolute;left:72.00px;top:578.28px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:604.56px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">MemoryChunk</span><span class="cls_006"> class is a cleaner version of </span><span class="cls_020">NextOnFreeList</span><span class="cls_006">. It separates the </span><span class="cls_020">next</span><span class="cls_006"> pointer from</span></div>
<div style="position:absolute;left:72.00px;top:617.28px" class="cls_006"><span class="cls_006">the actual memory used for the allocated object. It uses explicit </span><span class="cls_020">next</span><span class="cls_006"> and </span><span class="cls_020">mem</span><span class="cls_006"> pointers, with no need for</span></div>
<div style="position:absolute;left:72.00px;top:629.64px" class="cls_006"><span class="cls_006">casting. It is given pictorially in </span><span class="cls_036">Figure 6.4</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:194.28px;top:655.80px" class="cls_021"><span class="cls_021">Figure 6.4. Variable-size memory free list.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">53</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:57084px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background068.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:266.16px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">MemoryChunk</span><span class="cls_006"> constructor first determines the appropriate size of the memory block. It uses this size</span></div>
<div style="position:absolute;left:72.00px;top:279.00px" class="cls_006"><span class="cls_006">to allocate its private storage from the heap. The constructor also makes the </span><span class="cls_020">next</span><span class="cls_006"> member point to the</span></div>
<div style="position:absolute;left:72.00px;top:291.72px" class="cls_020"><span class="cls_020">nextChunk</span><span class="cls_006"> input argument. The </span><span class="cls_020">nextChunk</span><span class="cls_006"> is the previous head of the linked list. Effectively, we are</span></div>
<div style="position:absolute;left:72.00px;top:304.56px" class="cls_006"><span class="cls_006">making the newly constructed </span><span class="cls_020">MemoryChunk</span><span class="cls_006"> the new head of the linked list of </span><span class="cls_020">MemoryChunk</span><span class="cls_006"> objects.</span></div>
<div style="position:absolute;left:72.00px;top:317.40px" class="cls_006"><span class="cls_006">The number of bytes already allocated on this chunk is set to </span><span class="cls_020">0</span><span class="cls_006"> since this is a brand new </span><span class="cls_020">MemoryChunk</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:343.32px" class="cls_020"><span class="cls_020">MemoryChunk::MemoryChunk(MemoryChunk *nextChunk, size_t reqSize)</span></div>
<div style="position:absolute;left:72.00px;top:354.72px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:366.00px" class="cls_020"><span class="cls_020">chunkSize = (reqSize > DEFAULT_CHUNK_SIZE) ?</span></div>
<div style="position:absolute;left:173.98px;top:377.28px" class="cls_020"><span class="cls_020">reqSize : DEFAULT_CHUNK_SIZE;</span></div>
<div style="position:absolute;left:96.00px;top:388.68px" class="cls_020"><span class="cls_020">next = nextChunk;</span></div>
<div style="position:absolute;left:96.00px;top:399.96px" class="cls_020"><span class="cls_020">bytesAlreadyAllocated = 0;</span></div>
<div style="position:absolute;left:96.00px;top:411.36px" class="cls_020"><span class="cls_020">mem = new char [chunkSize];</span></div>
<div style="position:absolute;left:72.00px;top:422.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:448.20px" class="cls_006"><span class="cls_006">The destructor deletes the memory obtained by the constructor:</span></div>
<div style="position:absolute;left:72.00px;top:474.00px" class="cls_020"><span class="cls_020">MemoryChunk :: ~MemoryChunk() { delete [] mem; }</span></div>
<div style="position:absolute;left:72.00px;top:500.28px" class="cls_006"><span class="cls_006">A memory allocation request is handled by the </span><span class="cls_020">alloc()</span><span class="cls_006"> method. It returns a pointer to available space in</span></div>
<div style="position:absolute;left:72.00px;top:513.00px" class="cls_006"><span class="cls_006">the </span><span class="cls_020">MemoryChunk</span><span class="cls_006"> private storage pointed to by </span><span class="cls_020">mem</span><span class="cls_006">. It keeps track of available space by updating the</span></div>
<div style="position:absolute;left:72.00px;top:525.36px" class="cls_006"><span class="cls_006">number of bytes already allocated in this block.</span></div>
<div style="position:absolute;left:72.00px;top:551.04px" class="cls_020"><span class="cls_020">void* MemoryChunk :: alloc (size_t requestSize)</span></div>
<div style="position:absolute;left:72.00px;top:562.32px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:573.72px" class="cls_020"><span class="cls_020">void *addr = static_cast &lt;void*></span></div>
<div style="position:absolute;left:125.99px;top:585.00px" class="cls_020"><span class="cls_020">(static_cast &lt;size_t> mem + bytesAlreadyAllocated);</span></div>
<div style="position:absolute;left:96.00px;top:596.40px" class="cls_020"><span class="cls_020">bytesAlreadyAllocated += requestSize;</span></div>
<div style="position:absolute;left:96.00px;top:607.68px" class="cls_020"><span class="cls_020">return addr;</span></div>
<div style="position:absolute;left:72.00px;top:618.96px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:644.76px" class="cls_006"><span class="cls_006">In this implementation we do not bother freeing memory fragments on the fly. The whole memory chunk</span></div>
<div style="position:absolute;left:72.00px;top:656.76px" class="cls_006"><span class="cls_006">gets deallocated and sent back to the heap when the object is deleted:</span></div>
<div style="position:absolute;left:72.00px;top:682.44px" class="cls_020"><span class="cls_020">inline void MemoryChunk :: free (void *doomed) {}</span></div>
<div style="position:absolute;left:72.00px;top:708.72px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">MemoryChunk</span><span class="cls_006"> is just a helper class. It is used by the </span><span class="cls_020">ByteMemoryPool</span><span class="cls_006"> class to implement a</span></div>
<div style="position:absolute;left:72.00px;top:720.96px" class="cls_006"><span class="cls_006">variable-size memory manager:</span></div>
<div style="position:absolute;left:72.00px;top:746.76px" class="cls_020"><span class="cls_020">class ByteMemoryPool {</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">54</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:57936px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background069.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">ByteMemoryPool (size_t initSize =</span></div>
<div style="position:absolute;left:191.98px;top:93.24px" class="cls_020"><span class="cls_020">MemoryChunk::DEFAULT_CHUNK_SIZE);</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">~ByteMemoryPool ();</span></div>
<div style="position:absolute;left:96.00px;top:127.20px" class="cls_020"><span class="cls_020">// Allocate memory from private pool.</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">inline void *alloc (size_t size);</span></div>
<div style="position:absolute;left:96.00px;top:161.16px" class="cls_020"><span class="cls_020">// Free memory previously allocated from the pool</span></div>
<div style="position:absolute;left:96.00px;top:172.56px" class="cls_020"><span class="cls_020">inline void free (void* someElement);</span></div>
<div style="position:absolute;left:72.00px;top:183.84px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:195.12px" class="cls_020"><span class="cls_020">// A list of memory chunks. This is our private storage.</span></div>
<div style="position:absolute;left:96.00px;top:206.52px" class="cls_020"><span class="cls_020">MemoryChunk *listOfMemoryChunks;</span></div>
<div style="position:absolute;left:96.00px;top:229.20px" class="cls_020"><span class="cls_020">// Add one memory chunk to our private storage</span></div>
<div style="position:absolute;left:96.00px;top:240.48px" class="cls_020"><span class="cls_020">void expandStorage(size_t reqSize);</span></div>
<div style="position:absolute;left:72.00px;top:251.76px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:277.56px" class="cls_006"><span class="cls_006">Although the list of memory chunks may contain more than a single chunk, only the first chunk has</span></div>
<div style="position:absolute;left:72.00px;top:289.56px" class="cls_006"><span class="cls_006">memory available for allocation. The rest of the chunks represent memory that has already been allocated.</span></div>
<div style="position:absolute;left:72.00px;top:301.68px" class="cls_006"><span class="cls_006">The first element of the list is the only chunk capable of allocating available memory.</span></div>
<div style="position:absolute;left:72.00px;top:328.20px" class="cls_006"><span class="cls_006">The constructor takes an </span><span class="cls_020">initSize</span><span class="cls_006"> argument to specify the size of a single memory chunk. It sets the size</span></div>
<div style="position:absolute;left:72.00px;top:341.04px" class="cls_006"><span class="cls_006">of a single memory chunk accordingly. The </span><span class="cls_020">expandStorage()</span><span class="cls_006"> method sets </span><span class="cls_020">listOfMemoryChunks</span><span class="cls_006"> to</span></div>
<div style="position:absolute;left:72.00px;top:353.76px" class="cls_006"><span class="cls_006">point to an allocated </span><span class="cls_020">MemoryChunk</span><span class="cls_006"> object:</span></div>
<div style="position:absolute;left:72.00px;top:379.80px" class="cls_020"><span class="cls_020">// Construct the ByteMemoryPool object. Build the private storage.</span></div>
<div style="position:absolute;left:72.00px;top:391.08px" class="cls_020"><span class="cls_020">ByteMemoryPool :: ByteMemoryPool (size_t initSize)</span></div>
<div style="position:absolute;left:72.00px;top:402.48px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:413.76px" class="cls_020"><span class="cls_020">expandStorage(initSize);</span></div>
<div style="position:absolute;left:72.00px;top:425.04px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:450.72px" class="cls_006"><span class="cls_006">The destructor marches down the list of memory chunks and deletes them:</span></div>
<div style="position:absolute;left:72.00px;top:476.52px" class="cls_020"><span class="cls_020">ByteMemoryPool :: ~ByteMemoryPool ()</span></div>
<div style="position:absolute;left:72.00px;top:487.80px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:499.20px" class="cls_020"><span class="cls_020">MemoryChunk *memChunk = listOfMemoryChunks;</span></div>
<div style="position:absolute;left:96.00px;top:521.76px" class="cls_020"><span class="cls_020">while (memChunk) {</span></div>
<div style="position:absolute;left:143.99px;top:533.16px" class="cls_020"><span class="cls_020">listOfMemoryChunks = memChunk->nextMemChunk();</span></div>
<div style="position:absolute;left:143.99px;top:544.44px" class="cls_020"><span class="cls_020">delete memChunk;</span></div>
<div style="position:absolute;left:143.99px;top:555.84px" class="cls_020"><span class="cls_020">memChunk = listOfMemoryChunks;</span></div>
<div style="position:absolute;left:143.99px;top:567.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:578.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:604.68px" class="cls_020"><span class="cls_020">ByteMemoryPool::alloc()</span><span class="cls_006"> guarantees that we have sufficient space available, and then delegates the</span></div>
<div style="position:absolute;left:72.00px;top:617.40px" class="cls_006"><span class="cls_006">allocation task to the </span><span class="cls_020">MemoryChunk</span><span class="cls_006"> at the top of the list:</span></div>
<div style="position:absolute;left:72.00px;top:643.44px" class="cls_020"><span class="cls_020">void* ByteMemoryPool :: alloc (size_t requestSize)</span></div>
<div style="position:absolute;left:72.00px;top:654.72px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:666.00px" class="cls_020"><span class="cls_020">size_t space = listOfMemoryChunks->spaceAvailable();</span></div>
<div style="position:absolute;left:96.00px;top:688.68px" class="cls_020"><span class="cls_020">if ( space &lt; requestSize ) {</span></div>
<div style="position:absolute;left:119.99px;top:700.08px" class="cls_020"><span class="cls_020">expandStorage(requestSize);</span></div>
<div style="position:absolute;left:96.00px;top:711.36px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:734.04px" class="cls_020"><span class="cls_020">return listOfMemoryChunks->alloc(requestSize);</span></div>
<div style="position:absolute;left:72.00px;top:745.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">55</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:58788px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background070.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">The implementation of </span><span class="cls_020">ByteMemoryPool::alloc()</span><span class="cls_006"> is somewhat more complex than our previous</span></div>
<div style="position:absolute;left:72.00px;top:84.24px" class="cls_006"><span class="cls_006">equivalent implementations of </span><span class="cls_020">MemoryPool&lt;T>::alloc()</span><span class="cls_006">, and the </span><span class="cls_020">Rational::operator</span><span class="cls_006"> </span><span class="cls_020">new()</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:96.96px" class="cls_006"><span class="cls_006">Take </span><span class="cls_020">MemoryPool&lt;T>::alloc()</span><span class="cls_006">, for example. We check the state of the free list. If it is empty, we</span></div>
<div style="position:absolute;left:72.00px;top:109.32px" class="cls_006"><span class="cls_006">replenish it. Compu-tationally, all we need to do then is to return the element to the top of the free list.</span></div>
<div style="position:absolute;left:72.00px;top:121.92px" class="cls_006"><span class="cls_006">That's fast and easy. There's a lot more we need to compute in the case of </span><span class="cls_020">ByteMemoryPool::alloc()</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:134.16px" class="cls_006"><span class="cls_006">Since we are dealing with unknown request size, we have to make sure that we have sufficient space</span></div>
<div style="position:absolute;left:72.00px;top:146.76px" class="cls_006"><span class="cls_006">available in the </span><span class="cls_020">MemoryChunk</span><span class="cls_006">. If not, we must call </span><span class="cls_020">expandStorage()</span><span class="cls_006"> to allocate a new</span></div>
<div style="position:absolute;left:72.00px;top:159.60px" class="cls_020"><span class="cls_020">MemoryChunk</span><span class="cls_006"> and push it on top of the list of chunks. Either way, we are now guaranteed to have enough</span></div>
<div style="position:absolute;left:72.00px;top:172.44px" class="cls_006"><span class="cls_006">room to satisfy the request. Next, we call </span><span class="cls_020">MemoryChunk::alloc()</span><span class="cls_006"> to compute the memory address to</span></div>
<div style="position:absolute;left:72.00px;top:184.68px" class="cls_006"><span class="cls_006">be returned to the caller and to adjust its bookkeeping to reflect the number of bytes already allocated in</span></div>
<div style="position:absolute;left:72.00px;top:196.80px" class="cls_006"><span class="cls_006">that chunk. All these extra computations will degrade performance to some extent. That's the price of</span></div>
<div style="position:absolute;left:72.00px;top:208.80px" class="cls_006"><span class="cls_006">extended functionality.</span></div>
<div style="position:absolute;left:72.00px;top:235.44px" class="cls_006"><span class="cls_006">Freeing previously allocated memory is delegated to the </span><span class="cls_020">MemoryChunk</span><span class="cls_006"> on top of the list:</span></div>
<div style="position:absolute;left:72.00px;top:261.36px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:272.76px" class="cls_020"><span class="cls_020">void ByteMemoryPool :: free (void *doomed)</span></div>
<div style="position:absolute;left:72.00px;top:284.04px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:295.32px" class="cls_020"><span class="cls_020">listOfMemoryChunks->free(doomed);</span></div>
<div style="position:absolute;left:72.00px;top:306.72px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:332.88px" class="cls_006"><span class="cls_006">Recall that the </span><span class="cls_020">MemoryChunk::free()</span><span class="cls_006"> method is very simple—it does nothing. Why are we so lazy</span></div>
<div style="position:absolute;left:72.00px;top:345.72px" class="cls_006"><span class="cls_006">when it comes to freeing memory? Because this implementation of </span><span class="cls_020">ByteMemoryPool</span><span class="cls_006"> does not reuse</span></div>
<div style="position:absolute;left:72.00px;top:357.96px" class="cls_006"><span class="cls_006">memory that was previously allocated. If we need more memory, we will create a new chunk and use it for</span></div>
<div style="position:absolute;left:72.00px;top:370.08px" class="cls_006"><span class="cls_006">future allocations. The memory is released back to the heap upon pool destruction. The</span></div>
<div style="position:absolute;left:72.00px;top:382.56px" class="cls_020"><span class="cls_020">ByteMemoryPool</span><span class="cls_006"> destructor releases all the memory chunks back to the heap.</span></div>
<div style="position:absolute;left:72.00px;top:409.44px" class="cls_006"><span class="cls_006">This is not as wasteful as it sounds. We used this scheme to handle HTTP requests. A </span><span class="cls_020">ByteMemoryPool</span></div>
<div style="position:absolute;left:72.00px;top:421.80px" class="cls_006"><span class="cls_006">object was created at the beginning of each request. The memory chunk size was 4,096 bytes and that was</span></div>
<div style="position:absolute;left:72.00px;top:433.80px" class="cls_006"><span class="cls_006">good enough for 99% of HTTP requests. So in the typical case, we never had to expand our private storage</span></div>
<div style="position:absolute;left:72.00px;top:445.92px" class="cls_006"><span class="cls_006">because a single chunk was sufficient. Since the handling of an HTTP request is a very short-lived task,</span></div>
<div style="position:absolute;left:72.00px;top:457.92px" class="cls_006"><span class="cls_006">there is no need to worry about freeing and reusing private memory on the fly. It was much more efficient</span></div>
<div style="position:absolute;left:72.00px;top:470.04px" class="cls_006"><span class="cls_006">to unload the whole chunk at once during pool destruction (at the end of a request). This is yet another</span></div>
<div style="position:absolute;left:72.00px;top:482.16px" class="cls_006"><span class="cls_006">example of a message that is repeated in various forms throughout the book: Special circumstances allow</span></div>
<div style="position:absolute;left:72.00px;top:494.16px" class="cls_006"><span class="cls_006">for simplifying assumptions. Simplifying assumptions, in turn, provide opportunities for significant</span></div>
<div style="position:absolute;left:72.00px;top:506.28px" class="cls_006"><span class="cls_006">optimizations. You don't want to use solutions that were meant for bigger problems. Another issue that</span></div>
<div style="position:absolute;left:72.00px;top:518.28px" class="cls_006"><span class="cls_006">pops up here is that performance sometimes compromises reuse. To boost performance you sometimes</span></div>
<div style="position:absolute;left:72.00px;top:530.40px" class="cls_006"><span class="cls_006">need to tailor niche solutions for special circumstances. Those solutions don't tend to be very flexible or</span></div>
<div style="position:absolute;left:72.00px;top:542.52px" class="cls_006"><span class="cls_006">reusable outside of their intended, narrow domain.</span></div>
<div style="position:absolute;left:72.00px;top:568.56px" class="cls_006"><span class="cls_006">In the unlikely case that our storage chunk was exhausted, we expand it by creating a new memory chunk</span></div>
<div style="position:absolute;left:72.00px;top:580.68px" class="cls_006"><span class="cls_006">and adding it to the top of the list of memory chunks.</span></div>
<div style="position:absolute;left:72.00px;top:606.36px" class="cls_020"><span class="cls_020">void ByteMemoryPool :: expandStorage(size_t reqSize)</span></div>
<div style="position:absolute;left:72.00px;top:617.64px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:90.00px;top:629.04px" class="cls_020"><span class="cls_020">listOfMemoryChunks = new MemoryChunk(listOfMemoryChunks, reqSize);</span></div>
<div style="position:absolute;left:72.00px;top:640.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:666.60px" class="cls_006"><span class="cls_006">To test this memory manager, we modified the </span><span class="cls_020">Rational</span><span class="cls_006"> class implementation by replacing the</span></div>
<div style="position:absolute;left:72.00px;top:679.32px" class="cls_020"><span class="cls_020">MemoryPool&lt;Rational></span><span class="cls_006"> object with a </span><span class="cls_020">ByteMemoryPool</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:705.24px" class="cls_020"><span class="cls_020">class Rational {</span></div>
<div style="position:absolute;left:72.00px;top:716.64px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:727.92px" class="cls_020"><span class="cls_020">Rational (int a = 0, int b = 1 ) : n(a), d(b) {}</span></div>
<div style="position:absolute;left:96.00px;top:750.60px" class="cls_020"><span class="cls_020">void *operator new(size_t size) {return memPool->alloc(size);}</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">56</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:59640px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background071.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">void operator delete(void *doomed,size_t size)</span></div>
<div style="position:absolute;left:179.98px;top:81.84px" class="cls_020"><span class="cls_020">{memPool->free(doomed);}</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">static void newMemPool() { memPool = new ByteMemoryPool;}</span></div>
<div style="position:absolute;left:96.00px;top:115.92px" class="cls_020"><span class="cls_020">static void deleteMemPool() { delete memPool; }</span></div>
<div style="position:absolute;left:72.00px;top:127.20px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">int n; // Numerator</span></div>
<div style="position:absolute;left:96.00px;top:149.88px" class="cls_020"><span class="cls_020">int d; // Denominator</span></div>
<div style="position:absolute;left:96.00px;top:172.56px" class="cls_020"><span class="cls_020">static ByteMemoryPool *memPool;</span></div>
<div style="position:absolute;left:72.00px;top:183.84px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:209.52px" class="cls_006"><span class="cls_006">With this implementation of the memory pool, we measured our test loop one more time, allocating and</span></div>
<div style="position:absolute;left:72.00px;top:222.12px" class="cls_006"><span class="cls_006">deallocating </span><span class="cls_020">Rational</span><span class="cls_006"> objects:</span></div>
<div style="position:absolute;left:72.00px;top:248.04px" class="cls_020"><span class="cls_020">MemoryPool &lt;Rational> *Rational::memPool = 0;</span></div>
<div style="position:absolute;left:72.00px;top:270.72px" class="cls_020"><span class="cls_020">int main()</span></div>
<div style="position:absolute;left:72.00px;top:282.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:304.68px" class="cls_020"><span class="cls_020">Rational *array[1000];</span></div>
<div style="position:absolute;left:96.00px;top:327.36px" class="cls_020"><span class="cls_020">Rational::newMemPool();</span></div>
<div style="position:absolute;left:96.00px;top:350.04px" class="cls_020"><span class="cls_020">// Start timing here</span></div>
<div style="position:absolute;left:96.00px;top:372.60px" class="cls_020"><span class="cls_020">for (int j = 0; j &lt; 500; j++)</span></div>
<div style="position:absolute;left:287.96px;top:372.60px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:119.99px;top:384.00px" class="cls_020"><span class="cls_020">for (int i = 0; i &lt; 1000; i++)</span></div>
<div style="position:absolute;left:317.96px;top:384.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:143.99px;top:395.28px" class="cls_020"><span class="cls_020">array[i] = new Rational(i);</span></div>
<div style="position:absolute;left:119.99px;top:406.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:119.99px;top:417.96px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; 1000; i++)</span></div>
<div style="position:absolute;left:293.96px;top:417.96px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:143.99px;top:429.24px" class="cls_020"><span class="cls_020">delete array[i];</span></div>
<div style="position:absolute;left:119.99px;top:440.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:451.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:474.60px" class="cls_020"><span class="cls_020">// Stop timing here</span></div>
<div style="position:absolute;left:96.00px;top:497.28px" class="cls_020"><span class="cls_020">Rational::deleteMemPool();</span></div>
<div style="position:absolute;left:72.00px;top:531.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:556.92px" class="cls_006"><span class="cls_006">This loop executed in 140 milliseconds. </span><span class="cls_036">Figure 6.5</span><span class="cls_006"> compares the execution speed of the following:</span></div>
<div style="position:absolute;left:90.00px;top:583.68px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Version 1, the </span><span class="cls_020">Rational</span><span class="cls_006"> memory manager</span></div>
<div style="position:absolute;left:90.00px;top:596.28px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Version 2, a template implementation of an object memory manager</span></div>
<div style="position:absolute;left:90.00px;top:608.64px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Version 3, variable-size memory manager</span></div>
<div style="position:absolute;left:111.96px;top:634.80px" class="cls_021"><span class="cls_021">Figure 6.5. A variable-size memory pool is naturally slower than fixed-size.</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:60492px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background072.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:304.68px" class="cls_006"><span class="cls_006">As expected, Version 3 is slower than Versions 1 and 2, due to the increased complexity of the allocation</span></div>
<div style="position:absolute;left:72.00px;top:316.80px" class="cls_006"><span class="cls_006">logic. As we march forward to more powerful memory management, we have to give up some speed.</span></div>
<div style="position:absolute;left:72.00px;top:370.56px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:402.12px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Flexibility trades off with speed. As the power and flexibility of memory management increases,</span></div>
<div style="position:absolute;left:108.00px;top:414.24px" class="cls_006"><span class="cls_006">execution speed decreases.</span></div>
<div style="position:absolute;left:90.00px;top:426.96px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The global memory manager (implemented by </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete())</span><span class="cls_006"> is general purpose and</span></div>
<div style="position:absolute;left:108.00px;top:439.32px" class="cls_006"><span class="cls_006">consequently expensive.</span></div>
<div style="position:absolute;left:90.00px;top:451.68px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Specialized memory managers can be more than an order of magnitude faster than the global one.</span></div>
<div style="position:absolute;left:90.00px;top:463.92px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   If you allocate mostly memory blocks of a fixed size, a specialized fixed-size memory manager</span></div>
<div style="position:absolute;left:108.00px;top:476.04px" class="cls_006"><span class="cls_006">will provide a significant performance boost.</span></div>
<div style="position:absolute;left:90.00px;top:488.40px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A similar boost is available if you allocate mostly memory blocks that are confined to a single</span></div>
<div style="position:absolute;left:108.00px;top:500.40px" class="cls_006"><span class="cls_006">thread. A single-threaded memory manager will help by skipping over the concurrency issues that</span></div>
<div style="position:absolute;left:108.00px;top:513.00px" class="cls_006"><span class="cls_006">the global </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006"> must handle.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">58</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:61344px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background073.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 7. Multithreaded Memory Pooling</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">The previous chapter stayed entirely within the realm of a single-threaded environment. The memory pool</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">was owned by a single thread and concurrency issues were absent. We now extend our design to a</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">multithreaded environment. The memory pool will no longer belong to any particular thread; instead it will</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">be shared among all threads in the application process.</span></div>
<div style="position:absolute;left:72.00px;top:180.24px" class="cls_006"><span class="cls_006">The allocators developed for the single-threaded environment will not work properly in a multithreaded</span></div>
<div style="position:absolute;left:72.00px;top:192.24px" class="cls_006"><span class="cls_006">environment. To allow multiple threads to allocate and free memory concurrently, we must add mutual</span></div>
<div style="position:absolute;left:72.00px;top:204.36px" class="cls_006"><span class="cls_006">exclusion to the allocator methods. We could duplicate the single-threaded implementations and add</span></div>
<div style="position:absolute;left:72.00px;top:216.36px" class="cls_006"><span class="cls_006">locking at the right spots, but this brute force mechanism requires that you provide a distinct</span></div>
<div style="position:absolute;left:72.00px;top:228.48px" class="cls_006"><span class="cls_006">implementation for each memory pool type and each locking scheme. This is one of those design scenarios</span></div>
<div style="position:absolute;left:72.00px;top:240.60px" class="cls_006"><span class="cls_006">that begs for a template implementation. Such an implementation of a multi-threaded memory pool could</span></div>
<div style="position:absolute;left:72.00px;top:253.08px" class="cls_006"><span class="cls_006">be parameterized by the memory pool type. It would simply decorate the </span><span class="cls_020">alloc()</span><span class="cls_006"> and </span><span class="cls_020">free()</span><span class="cls_006"> calls</span></div>
<div style="position:absolute;left:72.00px;top:265.44px" class="cls_006"><span class="cls_006">(developed in the previous chapter) with a lock protection. We can take it a step further by making the lock</span></div>
<div style="position:absolute;left:72.00px;top:277.56px" class="cls_006"><span class="cls_006">type a template parameter as well, allowing us to instantiate memory pools with distinct locking schemes.</span></div>
<div style="position:absolute;left:72.00px;top:289.56px" class="cls_006"><span class="cls_006">That's another degree of freedom.</span></div>
<div style="position:absolute;left:72.00px;top:343.32px" class="cls_016"><span class="cls_016">Version 4: Implementation</span></div>
<div style="position:absolute;left:72.00px;top:374.76px" class="cls_006"><span class="cls_006">Version 4 implements a multithreaded memory pool. It can handle any pool and lock type that conform to</span></div>
<div style="position:absolute;left:72.00px;top:386.76px" class="cls_006"><span class="cls_006">the expected interface:</span></div>
<div style="position:absolute;left:72.00px;top:412.44px" class="cls_020"><span class="cls_020">template &lt;class POOLTYPE, class LOCK></span></div>
<div style="position:absolute;left:72.00px;top:423.84px" class="cls_020"><span class="cls_020">class MTMemoryPool {</span></div>
<div style="position:absolute;left:72.00px;top:435.12px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:446.52px" class="cls_020"><span class="cls_020">// Allocate an element from the freeList.</span></div>
<div style="position:absolute;left:96.00px;top:457.80px" class="cls_020"><span class="cls_020">inline void* alloc (size_t size);</span></div>
<div style="position:absolute;left:96.00px;top:480.48px" class="cls_020"><span class="cls_020">// Return an element to the freeList.</span></div>
<div style="position:absolute;left:96.00px;top:491.76px" class="cls_020"><span class="cls_020">inline void free (void* someElement);</span></div>
<div style="position:absolute;left:72.00px;top:503.16px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:514.44px" class="cls_020"><span class="cls_020">POOLTYPE stPool;</span></div>
<div style="position:absolute;left:203.98px;top:514.44px" class="cls_020"><span class="cls_020">// Single-threaded pool.</span></div>
<div style="position:absolute;left:96.00px;top:525.72px" class="cls_020"><span class="cls_020">LOCK</span></div>
<div style="position:absolute;left:155.98px;top:525.72px" class="cls_020"><span class="cls_020">theLock;</span></div>
<div style="position:absolute;left:72.00px;top:537.12px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:563.28px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">alloc()</span><span class="cls_006"> method delegates the allocation to the memory pool member, and the locking to the lock</span></div>
<div style="position:absolute;left:72.00px;top:575.64px" class="cls_006"><span class="cls_006">member, respectively:</span></div>
<div style="position:absolute;left:72.00px;top:601.32px" class="cls_020"><span class="cls_020">template &lt;class M, class L></span></div>
<div style="position:absolute;left:72.00px;top:612.60px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:624.00px" class="cls_020"><span class="cls_020">void* MTMemoryPool&lt;M,L>::alloc (size_t size)</span></div>
<div style="position:absolute;left:72.00px;top:635.28px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:646.68px" class="cls_020"><span class="cls_020">void * mem;</span></div>
<div style="position:absolute;left:96.00px;top:669.24px" class="cls_020"><span class="cls_020">theLock.lock();</span></div>
<div style="position:absolute;left:96.00px;top:680.64px" class="cls_020"><span class="cls_020">mem = stPool.alloc(size);</span></div>
<div style="position:absolute;left:96.00px;top:691.92px" class="cls_020"><span class="cls_020">theLock.unlock();</span></div>
<div style="position:absolute;left:96.00px;top:714.60px" class="cls_020"><span class="cls_020">return mem;</span></div>
<div style="position:absolute;left:72.00px;top:725.88px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:748.56px" class="cls_020"><span class="cls_020">template &lt;class M, class L></span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">59</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:62196px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background074.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">void MTMemoryPool&lt;M,L>::free (void* doomed)</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">theLock.lock();</span></div>
<div style="position:absolute;left:96.00px;top:115.92px" class="cls_020"><span class="cls_020">stPool.free(doomed);</span></div>
<div style="position:absolute;left:96.00px;top:127.20px" class="cls_020"><span class="cls_020">theLock.unlock();</span></div>
<div style="position:absolute;left:72.00px;top:138.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:164.76px" class="cls_006"><span class="cls_006">To instantiate a </span><span class="cls_020">MemPool</span><span class="cls_006"> template, we'll need to provide a memory pool type plus a lock type. For</span></div>
<div style="position:absolute;left:72.00px;top:177.00px" class="cls_006"><span class="cls_006">memory pools, we'll reuse the ones developed in the previous chapter. For lock types, we start with the</span></div>
<div style="position:absolute;left:72.00px;top:189.12px" class="cls_006"><span class="cls_006">following:</span></div>
<div style="position:absolute;left:72.00px;top:214.80px" class="cls_020"><span class="cls_020">class ABCLock {// Abstract base class</span></div>
<div style="position:absolute;left:72.00px;top:226.08px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:237.48px" class="cls_020"><span class="cls_020">virtual ~ABCLock() {}</span></div>
<div style="position:absolute;left:96.00px;top:248.76px" class="cls_020"><span class="cls_020">virtual void lock() = 0;</span></div>
<div style="position:absolute;left:96.00px;top:260.16px" class="cls_020"><span class="cls_020">virtual void unlock() = 0;</span></div>
<div style="position:absolute;left:72.00px;top:271.44px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:282.72px" class="cls_020"><span class="cls_020">class MutexLock : public ABCLock {</span></div>
<div style="position:absolute;left:72.00px;top:294.12px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:305.40px" class="cls_020"><span class="cls_020">MutexLock() {pthread_mutex_init(&lock, NULL);}</span></div>
<div style="position:absolute;left:96.00px;top:316.80px" class="cls_020"><span class="cls_020">~MutexLock() {pthread_mutex_destroy(&lock);}</span></div>
<div style="position:absolute;left:96.00px;top:339.36px" class="cls_020"><span class="cls_020">inline void lock() {pthread_mutex_lock(&lock);}</span></div>
<div style="position:absolute;left:96.00px;top:350.76px" class="cls_020"><span class="cls_020">inline void unlock() {pthread_mutex_unlock(&lock);}</span></div>
<div style="position:absolute;left:72.00px;top:362.04px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:373.44px" class="cls_020"><span class="cls_020">pthread_mutex_t lock;</span></div>
<div style="position:absolute;left:72.00px;top:384.72px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:411.00px" class="cls_006"><span class="cls_006">We also need to modify the implementation of </span><span class="cls_020">Rational</span><span class="cls_006"> to instantiate a multithreaded memory pool.</span></div>
<div style="position:absolute;left:72.00px;top:423.72px" class="cls_006"><span class="cls_006">The core memory pool is of type </span><span class="cls_020">MemoryPool&lt;Rational></span><span class="cls_006"> and the </span><span class="cls_020">MutexLock</span><span class="cls_006"> provides the locking</span></div>
<div style="position:absolute;left:72.00px;top:436.08px" class="cls_006"><span class="cls_006">services:</span></div>
<div style="position:absolute;left:72.00px;top:461.76px" class="cls_020"><span class="cls_020">class Rational {</span></div>
<div style="position:absolute;left:72.00px;top:473.04px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:495.72px" class="cls_020"><span class="cls_020">static void newMemPool() {</span></div>
<div style="position:absolute;left:119.99px;top:507.00px" class="cls_020"><span class="cls_020">memPool = new MTMemoryPool &lt;MemoryPool &lt;Rational>,</span></div>
<div style="position:absolute;left:287.96px;top:518.40px" class="cls_020"><span class="cls_020">MutexLock>;</span></div>
<div style="position:absolute;left:96.00px;top:529.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:541.08px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:563.64px" class="cls_020"><span class="cls_020">static MTMemoryPool &lt;MemoryPool&lt;Rational>, MutexLock> *memPool;</span></div>
<div style="position:absolute;left:72.00px;top:575.04px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:600.72px" class="cls_006"><span class="cls_006">Our test driver remains unchanged. It's the same old loop we used previously to measure allocation and</span></div>
<div style="position:absolute;left:72.00px;top:613.32px" class="cls_006"><span class="cls_006">deallocation of </span><span class="cls_020">Rational</span><span class="cls_006"> objects:</span></div>
<div style="position:absolute;left:72.00px;top:639.24px" class="cls_020"><span class="cls_020">for (int j = 0; j &lt; 500; j++)</span></div>
<div style="position:absolute;left:263.97px;top:639.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:650.52px" class="cls_020"><span class="cls_020">for (int i = 0; i &lt; 1000; i++)</span></div>
<div style="position:absolute;left:293.96px;top:650.52px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:119.99px;top:661.92px" class="cls_020"><span class="cls_020">array[i] = new Rational(i);</span></div>
<div style="position:absolute;left:96.00px;top:673.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:684.60px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; 1000; i++)</span></div>
<div style="position:absolute;left:269.96px;top:684.60px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:119.99px;top:695.88px" class="cls_020"><span class="cls_020">delete array[i];</span></div>
<div style="position:absolute;left:96.00px;top:707.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:718.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">60</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:63048px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background075.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">The last time we measured the execution time of the </span><span class="cls_020">MemoryPool</span><span class="cls_006">, we clocked in at 63 milliseconds for</span></div>
<div style="position:absolute;left:72.00px;top:83.76px" class="cls_006"><span class="cls_006">Version 2. So we were a little surprised to see the execution time of Version 4 increased to 1,300</span></div>
<div style="position:absolute;left:72.00px;top:95.76px" class="cls_006"><span class="cls_006">milliseconds. </span><span class="cls_036">Figure 7.1</span><span class="cls_006"> compares the following:</span></div>
<div style="position:absolute;left:90.00px;top:122.64px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Version 0. Global </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:90.00px;top:135.60px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Version 2. </span><span class="cls_020">MemoryPool:</span><span class="cls_006"> A single-threaded template implementation of a fixed object memory</span></div>
<div style="position:absolute;left:108.00px;top:147.96px" class="cls_006"><span class="cls_006">manager.</span></div>
<div style="position:absolute;left:90.00px;top:160.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Version 4. </span><span class="cls_020">MTMemoryPool</span><span class="cls_006">: Multithreaded </span><span class="cls_020">MemoryPool</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:114.72px;top:187.20px" class="cls_021"><span class="cls_021">Figure 7.1. Comparing multithreaded to single-threaded memory pooling.</span></div>
<div style="position:absolute;left:72.00px;top:447.00px" class="cls_006"><span class="cls_006">Something has gone wrong with the implementation of Version 4. A quick analysis reveals that execution</span></div>
<div style="position:absolute;left:72.00px;top:459.00px" class="cls_006"><span class="cls_006">time is dominated entirely by the pthreads library locking calls. Allocating memory contains a call to</span></div>
<div style="position:absolute;left:72.00px;top:471.60px" class="cls_020"><span class="cls_020">pthread_mutex_lock()</span><span class="cls_006"> followed by </span><span class="cls_020">pthread_mutex_unlock()</span><span class="cls_006">. The same holds for deallocating</span></div>
<div style="position:absolute;left:72.00px;top:484.32px" class="cls_006"><span class="cls_006">memory. Overall, each iteration of the main loop triggers two calls to </span><span class="cls_020">pthread_mutex_lock()</span><span class="cls_006"> and two</span></div>
<div style="position:absolute;left:72.00px;top:497.16px" class="cls_006"><span class="cls_006">more to </span><span class="cls_020">pthread_mutex_unlock()</span><span class="cls_006">: one pair for allocating an object and another pair for freeing it.</span></div>
<div style="position:absolute;left:72.00px;top:509.52px" class="cls_006"><span class="cls_006">Since locking is mandatory in this environment, the only hope we have is a drastic improvement of our</span></div>
<div style="position:absolute;left:72.00px;top:521.64px" class="cls_006"><span class="cls_006">locking calls.</span></div>
<div style="position:absolute;left:72.00px;top:575.40px" class="cls_016"><span class="cls_016">Version 5: Faster Locking</span></div>
<div style="position:absolute;left:72.00px;top:606.72px" class="cls_006"><span class="cls_006">What's wrong with our use of the pthreads locking calls? We suggested earlier that sometimes you don't</span></div>
<div style="position:absolute;left:72.00px;top:618.72px" class="cls_006"><span class="cls_006">really need the full power and flexibility of the default memory management. We are running into a similar</span></div>
<div style="position:absolute;left:72.00px;top:630.84px" class="cls_006"><span class="cls_006">issue with locking. Sometimes, you don't really need the full power of the pthreads library locking services.</span></div>
<div style="position:absolute;left:72.00px;top:643.44px" class="cls_006"><span class="cls_006">For example, </span><span class="cls_020">pthread_mutex_lock()</span><span class="cls_006"> must check that the calling thread does not already hold the lock,</span></div>
<div style="position:absolute;left:72.00px;top:656.16px" class="cls_006"><span class="cls_006">otherwise we are going to deadlock. </span><span class="cls_020">pthread_mutex_unlock()</span><span class="cls_006"> must check that the calling thread is</span></div>
<div style="position:absolute;left:72.00px;top:668.52px" class="cls_006"><span class="cls_006">the one that actually holds the lock. All these little checks and computations consume precious CPU cycles.</span></div>
<div style="position:absolute;left:72.00px;top:694.56px" class="cls_006"><span class="cls_006">Suppose we don't really need all this locking flexibility in Version 4. Suppose that our application's use of</span></div>
<div style="position:absolute;left:72.00px;top:706.68px" class="cls_006"><span class="cls_006">the locking services is so simple that we can guarantee that the locking thread does not already hold the</span></div>
<div style="position:absolute;left:72.00px;top:718.80px" class="cls_006"><span class="cls_006">lock. Further suppose that we can guarantee that the unlocking thread is the one that locked it in the first</span></div>
<div style="position:absolute;left:72.00px;top:730.80px" class="cls_006"><span class="cls_006">place. Now we can get away with a locking scheme that's a lot less sophisticated than the one provided by</span></div>
<div style="position:absolute;left:72.00px;top:742.92px" class="cls_006"><span class="cls_006">the pthreads library. What we ought to do is implement a new lock class using faster and more primitive</span></div>
<div style="position:absolute;left:72.00px;top:754.92px" class="cls_006"><span class="cls_006">building blocks to provide locking. Along the way we are trading portability for speed. Our next</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">61</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:63900px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background076.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">implementation of a lock class is platform-specific. Each platform, however, provides primitive basic</span></div>
<div style="position:absolute;left:72.00px;top:83.52px" class="cls_006"><span class="cls_006">blocks that are much faster than the pthreads library. In this case the </span><span class="cls_020">PrimitiveLock</span><span class="cls_006"> implementation</span></div>
<div style="position:absolute;left:72.00px;top:95.76px" class="cls_006"><span class="cls_006">was tailored for AIX.</span></div>
<div style="position:absolute;left:72.00px;top:122.40px" class="cls_006"><span class="cls_006">Version 5 simply replaces the implementation of </span><span class="cls_020">MutexLock</span><span class="cls_006"> with a faster one called </span><span class="cls_020">PrimitiveLock</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:148.32px" class="cls_020"><span class="cls_020">class PrimitiveLock : public ABCLock {</span></div>
<div style="position:absolute;left:72.00px;top:159.60px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:171.00px" class="cls_020"><span class="cls_020">PrimitiveLock() {</span></div>
<div style="position:absolute;left:149.99px;top:182.28px" class="cls_020"><span class="cls_020">_clear_lock((static_cast&lt;atomic_p>) &_lock,</span></div>
<div style="position:absolute;left:221.97px;top:193.68px" class="cls_020"><span class="cls_020">LOCK_FREE);}</span></div>
<div style="position:absolute;left:96.00px;top:204.96px" class="cls_020"><span class="cls_020">~PrimitiveLock() {}</span></div>
<div style="position:absolute;left:96.00px;top:227.64px" class="cls_020"><span class="cls_020">inline void lock() {</span></div>
<div style="position:absolute;left:239.97px;top:227.64px" class="cls_020"><span class="cls_020">// Spin lock</span></div>
<div style="position:absolute;left:119.99px;top:238.92px" class="cls_020"><span class="cls_020">while (!_check_lock((static_cast&lt;atomic_p>)&_lock,</span></div>
<div style="position:absolute;left:233.97px;top:250.32px" class="cls_020"><span class="cls_020">LOCK_FREE, LOCK_BUSY));</span></div>
<div style="position:absolute;left:96.00px;top:261.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:284.28px" class="cls_020"><span class="cls_020">inline void unlock() {</span></div>
<div style="position:absolute;left:113.99px;top:295.56px" class="cls_020"><span class="cls_020">_clear_lock((static_cast&lt;atomic_p>) &_lock, LOCK_FREE);</span></div>
<div style="position:absolute;left:96.00px;top:306.96px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:329.52px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:340.92px" class="cls_020"><span class="cls_020">int _lock;</span></div>
<div style="position:absolute;left:96.00px;top:352.20px" class="cls_020"><span class="cls_020">enum {LOCK_FREE = 0, LOCK_BUSY = 1};</span></div>
<div style="position:absolute;left:72.00px;top:363.60px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:389.76px" class="cls_006"><span class="cls_006">The implementation of </span><span class="cls_020">MTMemoryPool</span><span class="cls_006"> remains unchanged. That's the power of a template. We only need</span></div>
<div style="position:absolute;left:72.00px;top:402.48px" class="cls_006"><span class="cls_006">to make a slight modification to the </span><span class="cls_020">Rational</span><span class="cls_006"> class to instantiate an </span><span class="cls_020">MTMemoryPool</span><span class="cls_006"> template using the</span></div>
<div style="position:absolute;left:72.00px;top:415.32px" class="cls_020"><span class="cls_020">PrimitiveLock</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:441.24px" class="cls_020"><span class="cls_020">class Rational {</span></div>
<div style="position:absolute;left:72.00px;top:452.64px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:475.32px" class="cls_020"><span class="cls_020">static void newMemPool() {</span></div>
<div style="position:absolute;left:119.99px;top:486.60px" class="cls_020"><span class="cls_020">memPool = new MTMempryPool &lt;MemoryPool &lt;Rational>,</span></div>
<div style="position:absolute;left:281.96px;top:497.88px" class="cls_020"><span class="cls_020">PrimitiveLock>;</span></div>
<div style="position:absolute;left:96.00px;top:509.28px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:520.56px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:543.24px" class="cls_020"><span class="cls_020">static MTMemoryPool &lt; MemoryPool&lt;Rational>, PrimitiveLock></span></div>
<div style="position:absolute;left:137.99px;top:554.64px" class="cls_020"><span class="cls_020">*memPool;</span></div>
<div style="position:absolute;left:72.00px;top:565.92px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:591.48px" class="cls_006"><span class="cls_006">With this faster locking class, execution time improved significantly to 900 milliseconds (</span><span class="cls_036">Figure 7.2</span><span class="cls_006">).</span></div>
<div style="position:absolute;left:153.00px;top:617.76px" class="cls_021"><span class="cls_021">Figure 7.2. Multithreaded memory pool using faster locks.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">62</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:64752px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background077.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:306.60px" class="cls_006"><span class="cls_006">So far we have positioned the </span><span class="cls_020">MTMemoryPool</span><span class="cls_006"> template as a multithreaded solution. It is actually more</span></div>
<div style="position:absolute;left:72.00px;top:318.96px" class="cls_006"><span class="cls_006">flexible than that. You can instantiate it in a single-threaded environment, and it will perform just as well</span></div>
<div style="position:absolute;left:72.00px;top:331.56px" class="cls_006"><span class="cls_006">and as fast as the single-threaded solutions. You can achieve that by instantiating </span><span class="cls_020">MTMemoryPool</span><span class="cls_006"> with a</span></div>
<div style="position:absolute;left:72.00px;top:344.28px" class="cls_020"><span class="cls_020">DummyLock</span><span class="cls_006"> class that does nothing:</span></div>
<div style="position:absolute;left:72.00px;top:370.32px" class="cls_020"><span class="cls_020">class DummyLock : public ABCLock {</span></div>
<div style="position:absolute;left:72.00px;top:381.60px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:393.00px" class="cls_020"><span class="cls_020">inline void lock() {}</span></div>
<div style="position:absolute;left:96.00px;top:404.28px" class="cls_020"><span class="cls_020">inline void unlock() {}</span></div>
<div style="position:absolute;left:72.00px;top:415.56px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:441.84px" class="cls_006"><span class="cls_006">When you instantiate an </span><span class="cls_020">MTMemoryPool</span><span class="cls_006"> with a </span><span class="cls_020">DummyLock</span><span class="cls_006"> as in</span></div>
<div style="position:absolute;left:72.00px;top:468.60px" class="cls_020"><span class="cls_020">MTMemoryPool</span><span class="cls_006"> </span><span class="cls_020">&lt;MemoryPool&lt;Rational></span><span class="cls_006">, </span><span class="cls_020">DummyLock></span><span class="cls_006"> </span><span class="cls_020">myRationalPool</span><span class="cls_006">;</span></div>
<div style="position:absolute;left:72.00px;top:494.88px" class="cls_006"><span class="cls_006">you essentially get the equivalent of</span></div>
<div style="position:absolute;left:72.00px;top:520.08px" class="cls_020"><span class="cls_020">MemoryPool&lt;Rational> myRationalPool;</span></div>
<div style="position:absolute;left:72.00px;top:546.36px" class="cls_006"><span class="cls_006">The performance of these two forms is identical if inlining is performed by the compiler. Inlining will</span></div>
<div style="position:absolute;left:72.00px;top:558.84px" class="cls_006"><span class="cls_006">flatten </span><span class="cls_020">DummyLock::lock()</span><span class="cls_006"> and </span><span class="cls_020">DummyLock:unlock()</span><span class="cls_006"> down to zero instructions.</span></div>
<div style="position:absolute;left:72.00px;top:585.24px" class="cls_006"><span class="cls_006">In the previous chapter we developed a single-threaded, variable-size memory allocator named</span></div>
<div style="position:absolute;left:72.00px;top:597.72px" class="cls_020"><span class="cls_020">ByteMemoryPool</span><span class="cls_006">. We can extend </span><span class="cls_020">ByteMemoryPool</span><span class="cls_006"> into a multithreaded environment in the same</span></div>
<div style="position:absolute;left:72.00px;top:610.56px" class="cls_006"><span class="cls_006">way we extended </span><span class="cls_020">MemoryPool</span><span class="cls_006">. We simply instantiate the </span><span class="cls_020">MTMemoryPool</span><span class="cls_006"> template with a</span></div>
<div style="position:absolute;left:72.00px;top:623.40px" class="cls_020"><span class="cls_020">ByteMemoryPool</span><span class="cls_006"> parameter. To test it we only need to modify two lines in the </span><span class="cls_020">Rational</span></div>
<div style="position:absolute;left:72.00px;top:635.64px" class="cls_006"><span class="cls_006">implementation:</span></div>
<div style="position:absolute;left:72.00px;top:661.44px" class="cls_020"><span class="cls_020">class Rational {</span></div>
<div style="position:absolute;left:72.00px;top:672.72px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:695.40px" class="cls_020"><span class="cls_020">static void newMemPool() {</span></div>
<div style="position:absolute;left:119.99px;top:706.68px" class="cls_020"><span class="cls_020">memPool = new MTMemoryPool &lt;ByteMemoryPool, MutexLock>;</span></div>
<div style="position:absolute;left:96.00px;top:718.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:729.36px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:752.04px" class="cls_020"><span class="cls_020">static MTMemoryPool &lt;ByteMemoryPool, MutexLock> *memPool;</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">63</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:65604px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background078.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:96.24px" class="cls_036"><span class="cls_036">Figure 7.3</span><span class="cls_006"> contrasts the performance numbers of various memory pool classes developed in </span><span class="cls_036">Chapters 5</span><span class="cls_006"> and</span></div>
<div style="position:absolute;left:72.00px;top:108.36px" class="cls_036"><span class="cls_036">6</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:90.00px;top:135.12px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Version 0. Global </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:90.00px;top:148.20px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Version 2. </span><span class="cls_020">MemoryPool</span><span class="cls_006">. A single-threaded template implementation of a fixed object memory</span></div>
<div style="position:absolute;left:108.00px;top:160.56px" class="cls_006"><span class="cls_006">manager.</span></div>
<div style="position:absolute;left:90.00px;top:173.28px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Version 4. Multithreaded, fixed object memory manager using </span><span class="cls_020">MemoryPool</span><span class="cls_006"> and pthreads</span></div>
<div style="position:absolute;left:108.00px;top:185.64px" class="cls_006"><span class="cls_006">locking.</span></div>
<div style="position:absolute;left:90.00px;top:198.00px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Version 5. Essentially Version 4 with faster, platform-dependent locks.</span></div>
<div style="position:absolute;left:90.00px;top:210.72px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Version 6. Multithreaded, variable-size memory manager using </span><span class="cls_020">ByteMemoryPool</span><span class="cls_006"> and fast locks.</span></div>
<div style="position:absolute;left:143.52px;top:237.24px" class="cls_021"><span class="cls_021">Figure 7.3. Comparing the various flavors of memory pooling.</span></div>
<div style="position:absolute;left:72.00px;top:496.20px" class="cls_006"><span class="cls_006">We presented various memory allocators in </span><span class="cls_036">Chapters 5</span><span class="cls_006"> and </span><span class="cls_036">6</span><span class="cls_006">, but they are far from being exhaustive. We</span></div>
<div style="position:absolute;left:72.00px;top:508.20px" class="cls_006"><span class="cls_006">have not explored the whole space of memory allocators, just a small subset. Consider the variable-size</span></div>
<div style="position:absolute;left:72.00px;top:520.32px" class="cls_006"><span class="cls_006">allocator defined by</span></div>
<div style="position:absolute;left:72.00px;top:546.00px" class="cls_020"><span class="cls_020">MemPool &lt;ByteMemoryPool, PrimitiveLock> myPool;</span></div>
<div style="position:absolute;left:72.00px;top:571.80px" class="cls_006"><span class="cls_006">This allocator has a serious flaw in SMP environments. It is not scalable. Our implementation of</span></div>
<div style="position:absolute;left:72.00px;top:584.28px" class="cls_020"><span class="cls_020">ByteMemoryPool</span><span class="cls_006"> manipulates a single </span><span class="cls_020">MemoryChunk</span><span class="cls_006"> to allocate storage. This </span><span class="cls_020">MemoryChunk</span><span class="cls_006"> is a</span></div>
<div style="position:absolute;left:72.00px;top:596.64px" class="cls_006"><span class="cls_006">single resource that cannot be accessed concurrently. If two threads are trying to allocate memory, they</span></div>
<div style="position:absolute;left:72.00px;top:608.64px" class="cls_006"><span class="cls_006">must be serialized. To break up this scalability bottleneck, we could divide our critical resource into</span></div>
<div style="position:absolute;left:72.00px;top:620.76px" class="cls_006"><span class="cls_006">multiple resources. For example, we could have one resource for small allocations (less than 512 bytes)</span></div>
<div style="position:absolute;left:72.00px;top:632.88px" class="cls_006"><span class="cls_006">and another one for large (512 bytes or more). Now two requests for 100 and 1,000 bytes could proceed</span></div>
<div style="position:absolute;left:72.00px;top:644.88px" class="cls_006"><span class="cls_006">concurrently without getting in each other's way. We will not pursue this particular allocator here. General</span></div>
<div style="position:absolute;left:72.00px;top:657.00px" class="cls_006"><span class="cls_006">scalability considerations are discussed in </span><span class="cls_036">Chapter 15</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:710.76px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:742.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The global memory manager (implemented by </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006">) is general-purpose and</span></div>
<div style="position:absolute;left:108.00px;top:755.16px" class="cls_006"><span class="cls_006">consequently expensive.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">64</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:66456px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background079.jpg" width=595 height=842></div>
<div style="position:absolute;left:90.00px;top:71.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A significant boost is available if you mostly allocate memory blocks that are confined to a single</span></div>
<div style="position:absolute;left:108.00px;top:83.28px" class="cls_006"><span class="cls_006">thread. A single-threaded memory manager is much faster than a multithreaded one.</span></div>
<div style="position:absolute;left:90.00px;top:95.52px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   If you develop a set of efficient single-threaded allocators, you can easily extend their reach into</span></div>
<div style="position:absolute;left:108.00px;top:107.64px" class="cls_006"><span class="cls_006">multithreaded environments by the use of templates.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">65</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:67308px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background080.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 8. Inlining Basics</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">This chapter leaves the realm of design and begins a focus on speed mechanisms that are largely design</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">independent. These techniques will improve any program's performance, independent of its overall design</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">quality, However, these mechanistic techniques will not make badly designed programs fast—it will just</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">make them faster than they were. They will not make selection sorts faster than quick sorts, though they</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">can change the data set size of a problem that can be efficiently handled by an otherwise less efficient</span></div>
<div style="position:absolute;left:72.00px;top:178.32px" class="cls_006"><span class="cls_006">algorithm. Some of these techniques are free; that is, they are pure performance gains with no negative</span></div>
<div style="position:absolute;left:72.00px;top:190.32px" class="cls_006"><span class="cls_006">impacts on other software quality characteristics. Most of these techniques, however, force a designer to</span></div>
<div style="position:absolute;left:72.00px;top:202.44px" class="cls_006"><span class="cls_006">trade some aspect of design, like code size, portability, extensibility, or generality, for a needed</span></div>
<div style="position:absolute;left:72.00px;top:214.44px" class="cls_006"><span class="cls_006">performance bump. Almost all of these techniques have negative maintenance implications.</span></div>
<div style="position:absolute;left:72.00px;top:268.32px" class="cls_016"><span class="cls_016">What Is Inlining?</span></div>
<div style="position:absolute;left:72.00px;top:299.64px" class="cls_006"><span class="cls_006">Inlining replaces method calls with a macro-like expansion of the called method within the calling method.</span></div>
<div style="position:absolute;left:72.00px;top:311.64px" class="cls_006"><span class="cls_006">There are two mechanisms for specifying an intent to inline. One is to prefix the method definition with the</span></div>
<div style="position:absolute;left:72.00px;top:323.76px" class="cls_006"><span class="cls_006">reserved word inline, and the other is to define the method within the declaration header. A code sample</span></div>
<div style="position:absolute;left:72.00px;top:335.88px" class="cls_006"><span class="cls_006">make this easier to demonstrate:</span></div>
<div style="position:absolute;left:72.00px;top:361.56px" class="cls_020"><span class="cls_020">Class GatedInt {</span></div>
<div style="position:absolute;left:96.00px;top:372.84px" class="cls_020"><span class="cls_020">int x;</span></div>
<div style="position:absolute;left:72.00px;top:384.24px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:395.52px" class="cls_020"><span class="cls_020">int get () {</span></div>
<div style="position:absolute;left:119.99px;top:406.80px" class="cls_020"><span class="cls_020">return x;</span></div>
<div style="position:absolute;left:96.00px;top:418.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:429.48px" class="cls_020"><span class="cls_020">void set (int arg) {</span></div>
<div style="position:absolute;left:119.99px;top:440.88px" class="cls_020"><span class="cls_020">x = arg;</span></div>
<div style="position:absolute;left:96.00px;top:452.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:463.44px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:489.72px" class="cls_020"><span class="cls_020">GatedInt::get</span><span class="cls_006"> and </span><span class="cls_020">GeatedInt::set</span><span class="cls_006"> will both be inlined because they are defined within the</span></div>
<div style="position:absolute;left:72.00px;top:501.96px" class="cls_006"><span class="cls_006">declaration. Conversely, the methods to be inlined can be defined outside the class declaration but within</span></div>
<div style="position:absolute;left:72.00px;top:514.08px" class="cls_006"><span class="cls_006">the header file or within a file included by the header file.</span></div>
<div style="position:absolute;left:72.00px;top:539.76px" class="cls_020"><span class="cls_020">Class GatedInt {</span></div>
<div style="position:absolute;left:96.00px;top:551.16px" class="cls_020"><span class="cls_020">int x;</span></div>
<div style="position:absolute;left:72.00px;top:562.44px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:573.72px" class="cls_020"><span class="cls_020">int get();</span></div>
<div style="position:absolute;left:96.00px;top:585.12px" class="cls_020"><span class="cls_020">void set (int arg) ;</span></div>
<div style="position:absolute;left:72.00px;top:596.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:619.08px" class="cls_020"><span class="cls_020">inline int GatedInt::get ()</span></div>
<div style="position:absolute;left:72.00px;top:630.36px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:641.76px" class="cls_020"><span class="cls_020">return x;</span></div>
<div style="position:absolute;left:72.00px;top:653.04px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:675.72px" class="cls_020"><span class="cls_020">inline void GatedInt::set (int arg)</span></div>
<div style="position:absolute;left:72.00px;top:687.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:698.40px" class="cls_020"><span class="cls_020">x = arg;</span></div>
<div style="position:absolute;left:72.00px;top:709.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:735.48px" class="cls_006"><span class="cls_006">Inlined methods are called like any other method, but they do not compile like normal methods. The fact</span></div>
<div style="position:absolute;left:72.00px;top:747.48px" class="cls_006"><span class="cls_006">that the code for the inlined method needs to be expanded inline means that any code that calls the inlined</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">66</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:68160px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background081.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">method must have access to the definition of the method. The fact that the definition of the inlined method</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">has been incorporated into its calling methods means that any change in the inlined method will require a</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">complete recompilation of every module that uses the method. One of the costs of the potentially</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">significant performance improvement inlining provides is an increase in compile-time. Sometimes the</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">increase will be modest, but in some instances it can be immense, and in the most extreme cases a</span></div>
<div style="position:absolute;left:72.00px;top:131.28px" class="cls_006"><span class="cls_006">modification to an inlined method may require a complete recompilation of the entire program. This</span></div>
<div style="position:absolute;left:72.00px;top:143.40px" class="cls_006"><span class="cls_006">generally makes it a good idea to wait until the later stages of code development to inline anything.</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">These methods could be called with a program like this:</span></div>
<div style="position:absolute;left:72.00px;top:195.12px" class="cls_020"><span class="cls_020">int main ()</span></div>
<div style="position:absolute;left:72.00px;top:206.52px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:217.80px" class="cls_020"><span class="cls_020">GatedInt gi;</span></div>
<div style="position:absolute;left:96.00px;top:229.08px" class="cls_020"><span class="cls_020">gi.set(12);</span></div>
<div style="position:absolute;left:96.00px;top:240.48px" class="cls_020"><span class="cls_020">cout &lt;&lt; gi.get();</span></div>
<div style="position:absolute;left:72.00px;top:251.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:277.56px" class="cls_006"><span class="cls_006">A method is represented in a program by a contiguous block of code that contains the operations</span></div>
<div style="position:absolute;left:72.00px;top:290.04px" class="cls_006"><span class="cls_006">performed by the method. Using our sample program, </span><span class="cls_020">get</span><span class="cls_006">, </span><span class="cls_020">set</span><span class="cls_006">, and </span><span class="cls_020">main</span><span class="cls_006"> would each be represented by</span></div>
<div style="position:absolute;left:72.00px;top:302.40px" class="cls_006"><span class="cls_006">independent code blocks that contain the machine language instructions selected by the compiler to</span></div>
<div style="position:absolute;left:72.00px;top:314.88px" class="cls_006"><span class="cls_006">perform their respective operations. In our example program, </span><span class="cls_020">main</span><span class="cls_006"> instantiates an instance of a</span></div>
<div style="position:absolute;left:72.00px;top:327.72px" class="cls_020"><span class="cls_020">GatedInt</span><span class="cls_006">, pushes the literal </span><span class="cls_020">12</span><span class="cls_006"> onto the stack and calls </span><span class="cls_020">GatedInt::set</span><span class="cls_006">. It then calls</span></div>
<div style="position:absolute;left:72.00px;top:340.56px" class="cls_020"><span class="cls_020">GatedInt::get</span><span class="cls_006"> and pushes the returned value onto the stack so that </span><span class="cls_020">iostream::operator&lt;&lt;</span><span class="cls_006"> can</span></div>
<div style="position:absolute;left:72.00px;top:353.28px" class="cls_006"><span class="cls_006">output the value. </span><span class="cls_020">GatedInt::get</span><span class="cls_006"> returns the value of the private member variable </span><span class="cls_020">GatedInt::x</span><span class="cls_006">, and</span></div>
<div style="position:absolute;left:72.00px;top:366.12px" class="cls_020"><span class="cls_020">GatedInt::set</span><span class="cls_006"> assigns the input argument </span><span class="cls_020">arg</span><span class="cls_006"> to </span><span class="cls_020">GatedInt::x</span><span class="cls_006">. Ignoring the work performed by the</span></div>
<div style="position:absolute;left:72.00px;top:378.48px" class="cls_006"><span class="cls_006">operating system to get this program loaded and running, an outlined (not inlined) version of this program</span></div>
<div style="position:absolute;left:72.00px;top:390.48px" class="cls_006"><span class="cls_006">makes three calls. The first two calls require probably an order of magnitude more effort to perform call</span></div>
<div style="position:absolute;left:72.00px;top:402.60px" class="cls_006"><span class="cls_006">and return overhead than to actually execute the code within the called methods.</span></div>
<div style="position:absolute;left:72.00px;top:429.12px" class="cls_006"><span class="cls_006">Conversely, inlined </span><span class="cls_020">get</span><span class="cls_006"> and </span><span class="cls_020">set</span><span class="cls_006"> would result in a </span><span class="cls_020">main</span><span class="cls_006"> program containing a single call to</span></div>
<div style="position:absolute;left:72.00px;top:441.96px" class="cls_020"><span class="cls_020">iostream::&lt;&lt;</span><span class="cls_006">, and the main program logically would look something like this after </span><span class="cls_020">get</span><span class="cls_006"> and </span><span class="cls_020">set</span><span class="cls_006"> were</span></div>
<div style="position:absolute;left:72.00px;top:454.80px" class="cls_006"><span class="cls_006">inlined and before </span><span class="cls_020">main</span><span class="cls_006"> was compiled:</span></div>
<div style="position:absolute;left:72.00px;top:480.72px" class="cls_020"><span class="cls_020">int main ()</span></div>
<div style="position:absolute;left:72.00px;top:492.12px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:503.40px" class="cls_020"><span class="cls_020">GatedInt gi;</span></div>
<div style="position:absolute;left:96.00px;top:514.68px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:119.99px;top:526.08px" class="cls_020"><span class="cls_020">gi::x = 12;</span></div>
<div style="position:absolute;left:96.00px;top:537.36px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:548.76px" class="cls_020"><span class="cls_020">int temp = gi::x;</span></div>
<div style="position:absolute;left:96.00px;top:560.04px" class="cls_020"><span class="cls_020">cout &lt;&lt; temp;</span></div>
<div style="position:absolute;left:72.00px;top:571.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:597.60px" class="cls_006"><span class="cls_006">Notice that we said logically; the compiler should do much better than this. An optimization pass on </span><span class="cls_020">main</span></div>
<div style="position:absolute;left:72.00px;top:609.84px" class="cls_006"><span class="cls_006">would reduce it to:</span></div>
<div style="position:absolute;left:72.00px;top:635.52px" class="cls_020"><span class="cls_020">int main ()</span></div>
<div style="position:absolute;left:72.00px;top:646.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:658.20px" class="cls_020"><span class="cls_020">cout &lt;&lt; 12;</span></div>
<div style="position:absolute;left:72.00px;top:669.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:695.28px" class="cls_006"><span class="cls_006">Logically, the procedure used by a compiler to inline a method is as follows: The contiguous code block of</span></div>
<div style="position:absolute;left:72.00px;top:707.28px" class="cls_006"><span class="cls_006">the method to be inlined is copied into the invoking method at what would have been its point of call. Any</span></div>
<div style="position:absolute;left:72.00px;top:719.40px" class="cls_006"><span class="cls_006">local variables in the inlined method are allocated in block. The inlined method's input arguments and</span></div>
<div style="position:absolute;left:72.00px;top:731.52px" class="cls_006"><span class="cls_006">return value are mapped into the invoking method's local variable space. If the inlined method has multiple</span></div>
<div style="position:absolute;left:72.00px;top:743.52px" class="cls_006"><span class="cls_006">returns they become branches (the dreaded GOTO) to the end of the inlined block. All vestiges associated</span></div>
<div style="position:absolute;left:72.00px;top:755.64px" class="cls_006"><span class="cls_006">with what would have been a call (with the possible exception of an SP modification associated with the</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:69012px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background082.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">creation of a new block) are erased and, along with them, all the performance penalties of the call.</span></div>
<div style="position:absolute;left:72.00px;top:83.52px" class="cls_006"><span class="cls_006">However, call avoidance is only half the performance story of inlining. Suppose we had two methods </span><span class="cls_020">y</span></div>
<div style="position:absolute;left:72.00px;top:96.24px" class="cls_006"><span class="cls_006">and </span><span class="cls_020">build_mask</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:122.28px" class="cls_020"><span class="cls_020">int x::y (int a)</span></div>
<div style="position:absolute;left:72.00px;top:133.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:156.24px" class="cls_020"><span class="cls_020">int b = 6;</span></div>
<div style="position:absolute;left:149.99px;top:167.52px" class="cls_020"><span class="cls_020">// b is not modified within this section</span></div>
<div style="position:absolute;left:96.00px;top:178.92px" class="cls_020"><span class="cls_020">int m = build_mask(b);</span></div>
<div style="position:absolute;left:149.99px;top:190.20px" class="cls_020"><span class="cls_020">// m is not modified in this section</span></div>
<div style="position:absolute;left:96.00px;top:201.60px" class="cls_020"><span class="cls_020">int n = m + 1;</span></div>
<div style="position:absolute;left:72.00px;top:224.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:246.84px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:258.24px" class="cls_020"><span class="cls_020">int build_mask (int q)</span></div>
<div style="position:absolute;left:72.00px;top:269.52px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:280.80px" class="cls_020"><span class="cls_020">if (q > WORD_SIZE) return -1;</span></div>
<div style="position:absolute;left:96.00px;top:292.20px" class="cls_020"><span class="cls_020">else if (q > 0) return (1 &lt;&lt; q) - 1;</span></div>
<div style="position:absolute;left:96.00px;top:303.48px" class="cls_020"><span class="cls_020">else return 0;</span></div>
<div style="position:absolute;left:72.00px;top:314.88px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:341.04px" class="cls_006"><span class="cls_006">The unoptimized result of inlining </span><span class="cls_020">build_mask</span><span class="cls_006"> into </span><span class="cls_020">y</span><span class="cls_006"> would be:</span></div>
<div style="position:absolute;left:72.00px;top:366.96px" class="cls_020"><span class="cls_020">int x::y (int a)</span></div>
<div style="position:absolute;left:72.00px;top:378.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:400.92px" class="cls_020"><span class="cls_020">int b = 6;</span></div>
<div style="position:absolute;left:143.99px;top:412.32px" class="cls_020"><span class="cls_020">// b is not modified in this section</span></div>
<div style="position:absolute;left:96.00px;top:423.60px" class="cls_020"><span class="cls_020">int m;</span></div>
<div style="position:absolute;left:96.00px;top:434.88px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:119.99px;top:446.28px" class="cls_020"><span class="cls_020">int _temp_q = 6;</span></div>
<div style="position:absolute;left:119.99px;top:457.56px" class="cls_020"><span class="cls_020">int _temp;</span></div>
<div style="position:absolute;left:119.99px;top:468.96px" class="cls_020"><span class="cls_020">if (_temp_q > WORD_SIZE) _temp = -1;</span></div>
<div style="position:absolute;left:119.99px;top:480.24px" class="cls_020"><span class="cls_020">else if (_temp_q > 0) _temp = (1 &lt;&lt; q) - 1;</span></div>
<div style="position:absolute;left:119.99px;top:491.52px" class="cls_020"><span class="cls_020">else _temp = 0;</span></div>
<div style="position:absolute;left:119.99px;top:502.92px" class="cls_020"><span class="cls_020">m = _temp;</span></div>
<div style="position:absolute;left:96.00px;top:514.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:137.99px;top:525.60px" class="cls_020"><span class="cls_020">// m is not modified in this section</span></div>
<div style="position:absolute;left:96.00px;top:536.88px" class="cls_020"><span class="cls_020">int n = m + 1;</span></div>
<div style="position:absolute;left:72.00px;top:559.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:585.12px" class="cls_006"><span class="cls_006">However, the optimized result would be:</span></div>
<div style="position:absolute;left:72.00px;top:610.92px" class="cls_020"><span class="cls_020">int x::y (int a)</span></div>
<div style="position:absolute;left:72.00px;top:622.32px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:644.88px" class="cls_020"><span class="cls_020">int b = 6;</span></div>
<div style="position:absolute;left:143.99px;top:656.28px" class="cls_020"><span class="cls_020">// b is not modified in this section</span></div>
<div style="position:absolute;left:96.00px;top:667.56px" class="cls_020"><span class="cls_020">int m = 0x3F;</span></div>
<div style="position:absolute;left:143.99px;top:678.96px" class="cls_020"><span class="cls_020">// m is not modified in this section</span></div>
<div style="position:absolute;left:96.00px;top:690.24px" class="cls_020"><span class="cls_020">int n = 0x40;</span></div>
<div style="position:absolute;left:72.00px;top:712.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:738.60px" class="cls_006"><span class="cls_006">Cross-call optimizations are the other half of the inlining performance equation. A good optimizing</span></div>
<div style="position:absolute;left:72.00px;top:750.60px" class="cls_006"><span class="cls_006">compiler can make any vestiges of an inlined method's block boundaries unrecognizable. The bulk, and in</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">68</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:69864px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background083.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">some instances the entirety, of a method may be optimized out of existence. The compiler may reorder</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">significant amounts of the method. Thus, while logically it is useful to think of inlined methods as</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">maintaining some cohesion, one of the main benefits of inlining is that this is not necessarily the case.</span></div>
<div style="position:absolute;left:72.00px;top:148.92px" class="cls_016"><span class="cls_016">Method Invocation Costs</span></div>
<div style="position:absolute;left:72.00px;top:180.24px" class="cls_006"><span class="cls_006">To understand fully what is involved in the performance benefits of inlining, we must understand what is</span></div>
<div style="position:absolute;left:72.00px;top:192.24px" class="cls_006"><span class="cls_006">involved in a method invocation (procedure call) and return. This will help us to understand what we are</span></div>
<div style="position:absolute;left:72.00px;top:204.36px" class="cls_006"><span class="cls_006">avoiding and why its avoidance can significantly improve our programs' performance.</span></div>
<div style="position:absolute;left:72.00px;top:230.40px" class="cls_006"><span class="cls_006">Most systems have three or four "housekeeping" registers: an Instruction Pointer (also frequently referred</span></div>
<div style="position:absolute;left:72.00px;top:242.52px" class="cls_006"><span class="cls_006">to as a Program Counter in spite of the fact that it does not count programs), a Link Register, a Stack</span></div>
<div style="position:absolute;left:72.00px;top:254.52px" class="cls_006"><span class="cls_006">Pointer, a Frame Pointer, and an Argument Pointer, or IP, LR, SP, FP, and AP, respectively. You may have</span></div>
<div style="position:absolute;left:72.00px;top:266.64px" class="cls_006"><span class="cls_006">noticed that we listed five registers but said that a system has three or four housekeeping registers. This is</span></div>
<div style="position:absolute;left:72.00px;top:278.76px" class="cls_006"><span class="cls_006">because systems tend to mix-and-match combinations of them. We are unaware of any systems that do not</span></div>
<div style="position:absolute;left:72.00px;top:290.76px" class="cls_006"><span class="cls_006">use at least three of these registers, but we are also unaware of any systems that use all five.</span></div>
<div style="position:absolute;left:72.00px;top:316.80px" class="cls_006"><span class="cls_006">Following is a brief explanation of each maintenance register's function.</span></div>
<div style="position:absolute;left:72.00px;top:342.96px" class="cls_006"><span class="cls_006">The Instruction Pointer (IP) contains the address of the instruction to be executed next. A method</span></div>
<div style="position:absolute;left:72.00px;top:354.96px" class="cls_006"><span class="cls_006">invocation involves a jump to the invoked methods instructions and hence a modification to the IP. But the</span></div>
<div style="position:absolute;left:72.00px;top:367.08px" class="cls_006"><span class="cls_006">IP cannot just be overwritten. Its old value must be saved before it is changed, or there would be no way to</span></div>
<div style="position:absolute;left:72.00px;top:379.20px" class="cls_006"><span class="cls_006">get back to the invoking method.</span></div>
<div style="position:absolute;left:72.00px;top:405.24px" class="cls_006"><span class="cls_006">A Link Register (LR) contains the address IP of the method that called the current method. This is the</span></div>
<div style="position:absolute;left:72.00px;top:417.24px" class="cls_006"><span class="cls_006">location to which the method needs to return after it completes its execution. An LR is typically tied in to</span></div>
<div style="position:absolute;left:72.00px;top:429.36px" class="cls_006"><span class="cls_006">the operation of an architecture's call instruction and its value is set automatically as a side effect of</span></div>
<div style="position:absolute;left:72.00px;top:441.48px" class="cls_006"><span class="cls_006">executing a call. This is a single register, not a stack of registers. If a method itself calls any other methods,</span></div>
<div style="position:absolute;left:72.00px;top:453.48px" class="cls_006"><span class="cls_006">then the LR must be saved to prevent it from being overwritten, as it is difficult to return from a call</span></div>
<div style="position:absolute;left:72.00px;top:465.60px" class="cls_006"><span class="cls_006">efficiently if the identity of the caller has been destroyed. The function of an LR is performed in some</span></div>
<div style="position:absolute;left:72.00px;top:477.72px" class="cls_006"><span class="cls_006">architectures by automatically or explicitly pushing the calling method's IP on the program's process stack,</span></div>
<div style="position:absolute;left:72.00px;top:489.72px" class="cls_006"><span class="cls_006">in which case the architecture will not have an explicit LR.</span></div>
<div style="position:absolute;left:72.00px;top:515.76px" class="cls_006"><span class="cls_006">The local (automatic) variables in a method are allocated on the process' stack. The Stack Pointer (SP)</span></div>
<div style="position:absolute;left:72.00px;top:527.88px" class="cls_006"><span class="cls_006">keeps track of how much of the stack has been consumed. Each call consumes stack space and each return</span></div>
<div style="position:absolute;left:72.00px;top:540.00px" class="cls_006"><span class="cls_006">releases the previously allocated stack space. Similar to the invoker's IP and LR, after a return, the stack</span></div>
<div style="position:absolute;left:72.00px;top:552.00px" class="cls_006"><span class="cls_006">must be restored with possible adjustments to the arguments passed on the stack. This means that the SP</span></div>
<div style="position:absolute;left:72.00px;top:564.12px" class="cls_006"><span class="cls_006">must also be saved as part of a method call sequence.</span></div>
<div style="position:absolute;left:72.00px;top:590.16px" class="cls_006"><span class="cls_006">The Argument Pointer (AP) and Frame Pointer (FP) are very system dependent. Some architectures do not</span></div>
<div style="position:absolute;left:72.00px;top:602.28px" class="cls_006"><span class="cls_006">have either, some have only one, and some have both. An FP is used to mark the boundary between two</span></div>
<div style="position:absolute;left:72.00px;top:614.28px" class="cls_006"><span class="cls_006">areas on the stack: the one where the invoking method saved the registers whose state needed to be</span></div>
<div style="position:absolute;left:72.00px;top:626.40px" class="cls_006"><span class="cls_006">preserved, and the other where the invoked method's automatic variables are located. The SP typically has</span></div>
<div style="position:absolute;left:72.00px;top:638.52px" class="cls_006"><span class="cls_006">a fair amount of volatility during method execution. An FP is commonly used as a nonvolatile reference</span></div>
<div style="position:absolute;left:72.00px;top:650.52px" class="cls_006"><span class="cls_006">point for the method's local variables.</span></div>
<div style="position:absolute;left:72.00px;top:676.68px" class="cls_006"><span class="cls_006">Good call performance necessitates that only those registers that are used by a method be saved. Saving the</span></div>
<div style="position:absolute;left:72.00px;top:688.68px" class="cls_006"><span class="cls_006">entire register set on each call would be a needless overhead, but saving only a subset of the registers</span></div>
<div style="position:absolute;left:72.00px;top:700.80px" class="cls_006"><span class="cls_006">creates a potentially variable sized memory allocation between the arguments being passed into a method</span></div>
<div style="position:absolute;left:72.00px;top:712.80px" class="cls_006"><span class="cls_006">and the memory allocated to the method's automatic variables. If a variable number of register stores are</span></div>
<div style="position:absolute;left:72.00px;top:724.92px" class="cls_006"><span class="cls_006">associated with a given method call (that is, the number of register values saved is dependent on the state</span></div>
<div style="position:absolute;left:72.00px;top:737.04px" class="cls_006"><span class="cls_006">of the calling method) then an AP is needed to indicate where the arguments (parameters) that are being</span></div>
<div style="position:absolute;left:72.00px;top:749.04px" class="cls_006"><span class="cls_006">passed into a method are located in the stack (</span><span class="cls_036">Figure 8.1</span><span class="cls_006">).</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">69</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:70716px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background084.jpg" width=595 height=842></div>
<div style="position:absolute;left:198.72px;top:71.04px" class="cls_021"><span class="cls_021">Figure 8.1. Call frame register mapping.</span></div>
<div style="position:absolute;left:72.00px;top:288.72px" class="cls_006"><span class="cls_006">Some newer processing systems have gone to a caller/callee save paradigm in which some registers are</span></div>
<div style="position:absolute;left:72.00px;top:300.84px" class="cls_006"><span class="cls_006">guaranteed by the calling method to be usable by the called method without any action on the called</span></div>
<div style="position:absolute;left:72.00px;top:312.84px" class="cls_006"><span class="cls_006">method's part (the called method can overwrite their contents without negatively impacting the calling</span></div>
<div style="position:absolute;left:72.00px;top:324.96px" class="cls_006"><span class="cls_006">method), and some registers need to be saved by the called method before they can be used. However, not</span></div>
<div style="position:absolute;left:72.00px;top:337.08px" class="cls_006"><span class="cls_006">even the most sophisticated call and return mechanism can totally avoid at least some register storage and</span></div>
<div style="position:absolute;left:72.00px;top:349.08px" class="cls_006"><span class="cls_006">retrieval per call and return.</span></div>
<div style="position:absolute;left:72.00px;top:375.24px" class="cls_006"><span class="cls_006">A typical call sequence that uses these registers would involve the following.</span></div>
<div style="position:absolute;left:90.00px;top:401.52px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The invoking method marshals the arguments to be passed to the invoked method. This typically</span></div>
<div style="position:absolute;left:108.00px;top:413.64px" class="cls_006"><span class="cls_006">means pushing the arguments onto the stack, usually in reverse order. When all the arguments</span></div>
<div style="position:absolute;left:108.00px;top:425.64px" class="cls_006"><span class="cls_006">have been pushed on the stack, the SP will be pointing to the first argument.</span></div>
<div style="position:absolute;left:90.00px;top:438.00px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The address of the instruction to be returned to is then pushed on the stack and the call instruction</span></div>
<div style="position:absolute;left:108.00px;top:450.00px" class="cls_006"><span class="cls_006">then branches to the first instruction of the invoked method.</span></div>
<div style="position:absolute;left:90.00px;top:462.36px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The invoked method then saves the SP, AP, and FP from the invoking method on the stack and</span></div>
<div style="position:absolute;left:108.00px;top:474.48px" class="cls_006"><span class="cls_006">adjusts each of the housekeepers to reflect the context of the invoked method.</span></div>
<div style="position:absolute;left:90.00px;top:486.72px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The invoked method also saves (pushes onto the stack) any other registers that it will be using.</span></div>
<div style="position:absolute;left:108.00px;top:498.84px" class="cls_006"><span class="cls_006">(This must be done so that after the method returns, the invoking method's context will be</span></div>
<div style="position:absolute;left:108.00px;top:510.96px" class="cls_006"><span class="cls_006">undisturbed. This is typically another three or four registers.)</span></div>
<div style="position:absolute;left:72.00px;top:537.00px" class="cls_006"><span class="cls_006">A typical return sequence to undo the previous call sequence would involve the following.</span></div>
<div style="position:absolute;left:90.00px;top:563.28px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   If the method returns a value, then the value is usually returned in register 0 and sometimes also in</span></div>
<div style="position:absolute;left:108.00px;top:575.40px" class="cls_006"><span class="cls_006">register 1. This typically means that registers 0 and 1 must be scratch pad registers (registers that</span></div>
<div style="position:absolute;left:108.00px;top:587.52px" class="cls_006"><span class="cls_006">aren't saved and restored as part of a method call and return). Returning through a register makes</span></div>
<div style="position:absolute;left:108.00px;top:599.52px" class="cls_006"><span class="cls_006">it easier to clean up the stack for a return.</span></div>
<div style="position:absolute;left:90.00px;top:611.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The registers that were saved because they were used by the method are restored from the stack to</span></div>
<div style="position:absolute;left:108.00px;top:624.00px" class="cls_006"><span class="cls_006">their original locations.</span></div>
<div style="position:absolute;left:90.00px;top:636.24px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The saved values of the caller's FP and AP registers must then be restored from the stack to their</span></div>
<div style="position:absolute;left:108.00px;top:648.36px" class="cls_006"><span class="cls_006">corresponding locations.</span></div>
<div style="position:absolute;left:90.00px;top:660.72px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The SP must be adjusted such that it points to its position prior to pushing the method's first</span></div>
<div style="position:absolute;left:108.00px;top:672.72px" class="cls_006"><span class="cls_006">argument on the stack.</span></div>
<div style="position:absolute;left:90.00px;top:685.08px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The return address is then retrieved from the stack and placed in the IP, forcing a return to the</span></div>
<div style="position:absolute;left:108.00px;top:697.20px" class="cls_006"><span class="cls_006">point in the method's caller that immediately followed the point of the call.</span></div>
<div style="position:absolute;left:72.00px;top:723.24px" class="cls_006"><span class="cls_006">A simple count of the data movement associated with a method invocation will indicate that six to eight</span></div>
<div style="position:absolute;left:72.00px;top:735.24px" class="cls_006"><span class="cls_006">registers (four maintenance registers and two to four registers for use by the method) are saved, four of</span></div>
<div style="position:absolute;left:72.00px;top:747.36px" class="cls_006"><span class="cls_006">which are then modified. This generally takes at least a dozen cycles (data movement to or from memory is</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">70</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:71568px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background085.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">seldom actually single cycle) and sometimes consumes in excess of 40 cycles. Hence the work associated</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">with a method invocation is very expensive in terms of machine cycles. Unfortunately, this is only half the</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">story. When the method returns, the work done to effect the call must all be undone. The previously saved</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">values must be retrieved from the stack and the machine state must be returned to something</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">approximating its precall state. This means that a method invocation typically requires somewhere between</span></div>
<div style="position:absolute;left:72.00px;top:131.28px" class="cls_006"><span class="cls_006">25 and 100 cycles of overhead, and even this will occasionally be an understatement.</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">Part of this understatement involves argument preparation and retrieval. The arguments that are pushed on</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">the stack as part of a call prologue frequently could have been directly mapped into the invoked method's</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">view of memory. This is always true of references and sometimes true of pointers and objects. Thus there</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">is additional call overhead associated with pushing arguments on the stack before the call, and then reading</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">them back off the stack within the called method. In some instances these arguments are passed in registers,</span></div>
<div style="position:absolute;left:72.00px;top:217.68px" class="cls_006"><span class="cls_006">which provide very good performance (though not free), but the canonical mechanism involves using</span></div>
<div style="position:absolute;left:72.00px;top:229.80px" class="cls_006"><span class="cls_006">memory to pass arguments.</span></div>
<div style="position:absolute;left:72.00px;top:255.84px" class="cls_006"><span class="cls_006">If a method returns a value, particularly if it is an object, there can also be the cost of copying the object</span></div>
<div style="position:absolute;left:72.00px;top:267.96px" class="cls_006"><span class="cls_006">generated by the invoked method into the storage reserved for the return value in the invoking method. For</span></div>
<div style="position:absolute;left:72.00px;top:280.08px" class="cls_006"><span class="cls_006">a large object this can be a significant additional overhead, particularly if complicated copy constructors</span></div>
<div style="position:absolute;left:72.00px;top:292.08px" class="cls_006"><span class="cls_006">are employed to perform the task (in which case we get a double dose of call/return overhead: one for the</span></div>
<div style="position:absolute;left:72.00px;top:304.20px" class="cls_006"><span class="cls_006">method we explicitly called and one for the copy constructor used to return an object). When all</span></div>
<div style="position:absolute;left:72.00px;top:316.20px" class="cls_006"><span class="cls_006">caller/callee communication factors and system maintenance factors are taken into account, the cost of a</span></div>
<div style="position:absolute;left:72.00px;top:328.32px" class="cls_006"><span class="cls_006">method invocation is somewhere between 25 and 250 cycles. Typically the larger the invoked method, the</span></div>
<div style="position:absolute;left:72.00px;top:340.44px" class="cls_006"><span class="cls_006">larger its overhead, up to the maximum overhead cost of saving and restoring all a processor's registers,</span></div>
<div style="position:absolute;left:72.00px;top:352.44px" class="cls_006"><span class="cls_006">passing some large number of arguments, and invoking user-defined methods to effect the construction of</span></div>
<div style="position:absolute;left:72.00px;top:364.56px" class="cls_006"><span class="cls_006">a return value.</span></div>
<div style="position:absolute;left:72.00px;top:390.60px" class="cls_006"><span class="cls_006">Exception usage can significantly diminish the full potential of inlined return value optimization. Return</span></div>
<div style="position:absolute;left:72.00px;top:402.72px" class="cls_006"><span class="cls_006">value copying is logically an atomic operation performed by a copy-constructor as part of the called</span></div>
<div style="position:absolute;left:72.00px;top:414.72px" class="cls_006"><span class="cls_006">method's return. This means that logically, if an exception is thrown prior to execution of the return</span></div>
<div style="position:absolute;left:72.00px;top:426.84px" class="cls_006"><span class="cls_006">statement, the value is not returned, and the variable into which the method's value was to be placed will</span></div>
<div style="position:absolute;left:72.00px;top:438.96px" class="cls_006"><span class="cls_006">remain unchanged. This essentially necessitates the use of copy semantics for return values in the presence</span></div>
<div style="position:absolute;left:72.00px;top:450.96px" class="cls_006"><span class="cls_006">of exceptions. It also becomes a valid reason for avoiding the use of exceptions in some instances. Ideally,</span></div>
<div style="position:absolute;left:72.00px;top:463.08px" class="cls_006"><span class="cls_006">for optimization purposes, it would be handy if there were some syntactic marker that would allow return</span></div>
<div style="position:absolute;left:72.00px;top:475.08px" class="cls_006"><span class="cls_006">value optimization in the presence of exceptions. Some return value optimization with exceptions is</span></div>
<div style="position:absolute;left:72.00px;top:487.20px" class="cls_006"><span class="cls_006">already possible. For example, if the scope of the variable into which the value is being returned is within</span></div>
<div style="position:absolute;left:72.00px;top:499.32px" class="cls_006"><span class="cls_006">the same try block as the inlined method, then the return value can be optimized. Unfortunately, while this</span></div>
<div style="position:absolute;left:72.00px;top:511.32px" class="cls_006"><span class="cls_006">is relatively easily determined in most cases, it requires cross call optimization, which is expensive and</span></div>
<div style="position:absolute;left:72.00px;top:523.44px" class="cls_006"><span class="cls_006">somewhat complicated.</span></div>
<div style="position:absolute;left:72.00px;top:549.48px" class="cls_006"><span class="cls_006">An additional advantage of inlining is that it is not necessary to branch to execute the invoked method.</span></div>
<div style="position:absolute;left:72.00px;top:561.60px" class="cls_006"><span class="cls_006">Branching, even unconditional branching, can negatively impact the performance of modern processors.</span></div>
<div style="position:absolute;left:72.00px;top:573.60px" class="cls_006"><span class="cls_006">Branching frequently involves a stall in the execution pipeline because the necessary instruction is not in</span></div>
<div style="position:absolute;left:72.00px;top:585.72px" class="cls_006"><span class="cls_006">the prefetch buffer. Branches can also require the services of an arithmetic unit to determine the branch</span></div>
<div style="position:absolute;left:72.00px;top:597.84px" class="cls_006"><span class="cls_006">target, thus delaying the time until the branch address will be known. Stalling the pipeline means the</span></div>
<div style="position:absolute;left:72.00px;top:609.84px" class="cls_006"><span class="cls_006">processor will be idle for the amount of time it takes to redirect the instruction stream. This occurs twice</span></div>
<div style="position:absolute;left:72.00px;top:621.96px" class="cls_006"><span class="cls_006">per method invocation, once when the method is called and again when it returns.</span></div>
<div style="position:absolute;left:72.00px;top:648.00px" class="cls_006"><span class="cls_006">There is still one more factor that works against call performance. Compilers are getting reasonably good</span></div>
<div style="position:absolute;left:72.00px;top:660.12px" class="cls_006"><span class="cls_006">at optimizing small code windows; that is, compilers can optimize single methods pretty well, but they</span></div>
<div style="position:absolute;left:72.00px;top:672.12px" class="cls_006"><span class="cls_006">tend not to optimize across method call boundaries. This means that simple optimizations, like removing</span></div>
<div style="position:absolute;left:72.00px;top:684.24px" class="cls_006"><span class="cls_006">the first of two sequential memory writes to the same location, are not realized if there is an intervening</span></div>
<div style="position:absolute;left:72.00px;top:696.36px" class="cls_006"><span class="cls_006">call. For example:</span></div>
<div style="position:absolute;left:72.00px;top:722.04px" class="cls_020"><span class="cls_020">int x = 10;</span></div>
<div style="position:absolute;left:72.00px;top:733.32px" class="cls_020"><span class="cls_020">x = 20;</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">71</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:72420px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background086.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">This looks silly as a single code fragment. Obviously the assignment aspect of the first statement: </span><span class="cls_020">x</span><span class="cls_006"> </span><span class="cls_020">=</span><span class="cls_006"> </span><span class="cls_020">10</span><span class="cls_006">,</span></div>
<div style="position:absolute;left:72.00px;top:84.24px" class="cls_006"><span class="cls_006">can be ignored (assuming </span><span class="cls_020">x</span><span class="cls_006"> is not some volatile memory location, like a FIFO). Any good compiler would</span></div>
<div style="position:absolute;left:72.00px;top:96.96px" class="cls_006"><span class="cls_006">combine the first and second statement into a simple </span><span class="cls_020">int</span><span class="cls_006"> </span><span class="cls_020">x</span><span class="cls_006"> </span><span class="cls_020">=</span><span class="cls_006"> </span><span class="cls_020">20</span><span class="cls_006"> statement. Unfortunately this sort of code</span></div>
<div style="position:absolute;left:72.00px;top:109.32px" class="cls_006"><span class="cls_006">behavior occurs regularly, and goes undetected and unoptimized by the compiler, with a return instruction</span></div>
<div style="position:absolute;left:72.00px;top:121.44px" class="cls_006"><span class="cls_006">inserted between the consecutive assignments. For example:</span></div>
<div style="position:absolute;left:72.00px;top:147.12px" class="cls_020"><span class="cls_020">int a::b (int& i)</span></div>
<div style="position:absolute;left:72.00px;top:158.40px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:169.80px" class="cls_020"><span class="cls_020">i = 10;</span></div>
<div style="position:absolute;left:72.00px;top:192.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:215.04px" class="cls_020"><span class="cls_020">int a::c ()</span></div>
<div style="position:absolute;left:72.00px;top:226.44px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:249.12px" class="cls_020"><span class="cls_020">int k = 0;</span></div>
<div style="position:absolute;left:96.00px;top:260.40px" class="cls_020"><span class="cls_020">ret = this->b(k);</span></div>
<div style="position:absolute;left:72.00px;top:283.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:308.76px" class="cls_006"><span class="cls_006">A change in statement scope from a pair of methods in which one method calls the other to a single</span></div>
<div style="position:absolute;left:72.00px;top:320.88px" class="cls_006"><span class="cls_006">method that embodies the functionality of both, though logically uninteresting in terms of the net result, is</span></div>
<div style="position:absolute;left:72.00px;top:332.88px" class="cls_006"><span class="cls_006">crucial to a compiler's ability to optimize out inefficiencies. Thus, in some instances the most significant</span></div>
<div style="position:absolute;left:72.00px;top:345.00px" class="cls_006"><span class="cls_006">cost of method invocation is the inability to optimize code across method boundaries.</span></div>
<div style="position:absolute;left:72.00px;top:398.76px" class="cls_016"><span class="cls_016">Why Inline?</span></div>
<div style="position:absolute;left:72.00px;top:430.08px" class="cls_006"><span class="cls_006">Inlining is probably the most significant mechanical performance enhancement technique available in C++.</span></div>
<div style="position:absolute;left:72.00px;top:442.20px" class="cls_006"><span class="cls_006">The performance of relatively large systems can be transformed rapidly, without rewriting anything. While</span></div>
<div style="position:absolute;left:72.00px;top:454.20px" class="cls_006"><span class="cls_006">working on a networking framework, we took a 10,000 line subsystem and improved its performance by</span></div>
<div style="position:absolute;left:72.00px;top:466.32px" class="cls_006"><span class="cls_006">more than an order of magnitude. The last step in the transformation involved inlining the working system.</span></div>
<div style="position:absolute;left:72.00px;top:478.44px" class="cls_006"><span class="cls_006">This last step took only two days and resulted in a 40% improvement in the system's performance. It took</span></div>
<div style="position:absolute;left:72.00px;top:490.44px" class="cls_006"><span class="cls_006">two days to do the inlining because the code was not designed from its inception for inlining. Had we</span></div>
<div style="position:absolute;left:72.00px;top:502.56px" class="cls_006"><span class="cls_006">employed what we now know about inlining during the development of this system, we would have been</span></div>
<div style="position:absolute;left:72.00px;top:514.56px" class="cls_006"><span class="cls_006">able to perform the same inlining with a quick change to a makefile and a recompilation.</span></div>
<div style="position:absolute;left:72.00px;top:540.72px" class="cls_006"><span class="cls_006">This 40% improvement was not the result of careful profiling and "fast path" analysis but rather was based</span></div>
<div style="position:absolute;left:72.00px;top:552.72px" class="cls_006"><span class="cls_006">on a cursory review of the method set and a selection of the obvious candidates for inlined recompilation.</span></div>
<div style="position:absolute;left:72.00px;top:564.84px" class="cls_006"><span class="cls_006">Had more performance been required, we would have become more serious about creating a "straight-line</span></div>
<div style="position:absolute;left:72.00px;top:576.12px" class="cls_006"><span class="cls_006">fast path," which is the real goal of mechanistic performance techniques.</span><span class="cls_037"><sup>[1]</sup></span></div>
<div style="position:absolute;left:90.00px;top:602.88px" class="cls_026"><span class="cls_026"><sup>[1]</sup></span><span class="cls_027"> Sadly, the system on which we were working suffered in the extreme from every performance malady in</span></div>
<div style="position:absolute;left:90.00px;top:616.68px" class="cls_027"><span class="cls_027">this book, and it was finally shot to put it out of its misery. We, thankfully, did not design the system, but we</span></div>
<div style="position:absolute;left:90.00px;top:627.00px" class="cls_027"><span class="cls_027">did learn a tremendous amount about how not to do OO from our experience with it. The failure of large</span></div>
<div style="position:absolute;left:90.00px;top:637.44px" class="cls_027"><span class="cls_027">projects like this one have done a significant amount of damage to OO's reputation. Our contention is that</span></div>
<div style="position:absolute;left:90.00px;top:647.76px" class="cls_027"><span class="cls_027">this project did not fail because of OO, but rather it failed because performance was seen as a secondary</span></div>
<div style="position:absolute;left:90.00px;top:657.96px" class="cls_027"><span class="cls_027">design consideration. He who fails to design for performance, performs a design failure.</span></div>
<div style="position:absolute;left:72.00px;top:681.96px" class="cls_006"><span class="cls_006">A program's fast path is the portion of a program that supports the normal, error free, common usage cases</span></div>
<div style="position:absolute;left:72.00px;top:694.08px" class="cls_006"><span class="cls_006">of the program's execution. Typically less than 10% of a program's code lies on this fast path. Fast paths</span></div>
<div style="position:absolute;left:72.00px;top:706.08px" class="cls_006"><span class="cls_006">containing less than 1% of a program's code are not unusual. Code that exemplifies straight-line execution</span></div>
<div style="position:absolute;left:72.00px;top:718.20px" class="cls_006"><span class="cls_006">minimizes the amount of branching (conditional execution, looping, and calling). This characteristic is</span></div>
<div style="position:absolute;left:72.00px;top:730.20px" class="cls_006"><span class="cls_006">critical to the realization of highly optimized performance and will be discussed in </span><span class="cls_036">Chapter 16</span><span class="cls_006">. Inlining</span></div>
<div style="position:absolute;left:72.00px;top:742.32px" class="cls_006"><span class="cls_006">allows us to remove calls from the fast path. On most systems, calls are the single most expensive</span></div>
<div style="position:absolute;left:72.00px;top:754.44px" class="cls_006"><span class="cls_006">structural entity. In general, no program that relies on lots of small methods as its primary structural</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">72</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:73272px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background087.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">component has any hope of reasonable performance unless the proper subset of those methods are</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">identified and inlined.</span></div>
<div style="position:absolute;left:72.00px;top:136.80px" class="cls_016"><span class="cls_016">Inlining Details</span></div>
<div style="position:absolute;left:72.00px;top:168.12px" class="cls_006"><span class="cls_006">The concept of inlining, although relatively simple on its surface, turns out to have its complications.</span></div>
<div style="position:absolute;left:72.00px;top:180.24px" class="cls_006"><span class="cls_006">Although we believe that it is important to understand inlining and apply it properly, we also believe that</span></div>
<div style="position:absolute;left:72.00px;top:192.24px" class="cls_006"><span class="cls_006">inlining eventually will be a compile- and profile-based optimization that will be performed by</span></div>
<div style="position:absolute;left:72.00px;top:204.36px" class="cls_006"><span class="cls_006">compiler/profiler/optimizer tools for you. We also believe that the automatic tools eventually will be able</span></div>
<div style="position:absolute;left:72.00px;top:216.36px" class="cls_006"><span class="cls_006">to do a more accurate job of inlining than you will. Unfortunately, the current crop of commercially</span></div>
<div style="position:absolute;left:72.00px;top:228.48px" class="cls_006"><span class="cls_006">available compilers lack the sophistication to do anything that even approaches automatic optimized</span></div>
<div style="position:absolute;left:72.00px;top:240.60px" class="cls_006"><span class="cls_006">inlining. It therefore falls to you to learn all the subtleties associated with inlining and to deal with the</span></div>
<div style="position:absolute;left:72.00px;top:252.60px" class="cls_006"><span class="cls_006">cumbersome syntactic mechanism for achieving inlining. Hopefully in the future you will be able to forget</span></div>
<div style="position:absolute;left:72.00px;top:264.72px" class="cls_006"><span class="cls_006">all about inlining, except when you remark to those who follow you, "I remember a time when we had to</span></div>
<div style="position:absolute;left:72.00px;top:276.84px" class="cls_006"><span class="cls_006">do code path optimization by hand. Boy, those were the good old days." Hopefully, when you say this you</span></div>
<div style="position:absolute;left:72.00px;top:288.84px" class="cls_006"><span class="cls_006">will be thinking, at least with regard to inlining, "Boy, those were the bad old days." The inadvisable</span></div>
<div style="position:absolute;left:72.00px;top:300.96px" class="cls_006"><span class="cls_006">preservation of file semantics for C++ integrated development environments operates against the desired</span></div>
<div style="position:absolute;left:72.00px;top:312.96px" class="cls_006"><span class="cls_006">level of compiler sophistication.</span></div>
<div style="position:absolute;left:72.00px;top:339.12px" class="cls_006"><span class="cls_006">The reserved word "inline" is a suggestion to the compiler. It tells the compiler that for performance</span></div>
<div style="position:absolute;left:72.00px;top:351.12px" class="cls_006"><span class="cls_006">reasons it would be a good idea if the code for a method were expanded inline instead of called. The</span></div>
<div style="position:absolute;left:72.00px;top:363.24px" class="cls_006"><span class="cls_006">compiler is under no obligation to grant inlining requests. The compiler can inline or not inline as it wishes</span></div>
<div style="position:absolute;left:72.00px;top:375.24px" class="cls_006"><span class="cls_006">or is able. This means that the compiler can inline when it has not explicitly been told to do so (trivial</span></div>
<div style="position:absolute;left:72.00px;top:387.36px" class="cls_006"><span class="cls_006">method inlining sometimes occurs as a side effect of optimization) and not inline when it has explicitly</span></div>
<div style="position:absolute;left:72.00px;top:399.48px" class="cls_006"><span class="cls_006">been told to do so.</span></div>
<div style="position:absolute;left:72.00px;top:425.52px" class="cls_006"><span class="cls_006">In general, compilers still lack the sophistication to inline a typical method. For example, some compilers</span></div>
<div style="position:absolute;left:72.00px;top:437.64px" class="cls_006"><span class="cls_006">will refuse to inline a method that contains a loop, some cannot handle static variables within the inlined</span></div>
<div style="position:absolute;left:72.00px;top:449.64px" class="cls_006"><span class="cls_006">method or a method that has been declared to be virtual. On some occasions a compiler may be unable to</span></div>
<div style="position:absolute;left:72.00px;top:461.76px" class="cls_006"><span class="cls_006">resolve the mapping of a called method's variable space. In fact, some compilers will inline nothing much</span></div>
<div style="position:absolute;left:72.00px;top:473.76px" class="cls_006"><span class="cls_006">more complicated than indirect calls, accessor methods (methods that do little more than set or return the</span></div>
<div style="position:absolute;left:72.00px;top:485.88px" class="cls_006"><span class="cls_006">value of an attribute), or methods that contain a couple of lines of simple assignments, possibly with some</span></div>
<div style="position:absolute;left:72.00px;top:498.00px" class="cls_006"><span class="cls_006">associated calculations. Thus, in the end, an aggressively inlined program can easily be foiled by a</span></div>
<div style="position:absolute;left:72.00px;top:510.00px" class="cls_006"><span class="cls_006">compiler that lacks the ability to satisfy fully, or even largely, the programmer's inlining requests.</span></div>
<div style="position:absolute;left:72.00px;top:536.16px" class="cls_006"><span class="cls_006">Inlining also has some interesting side effects of which you need to be aware. Inlined method definitions</span></div>
<div style="position:absolute;left:72.00px;top:548.64px" class="cls_006"><span class="cls_006">are logically part of a class' header file, even though they frequently reside in separate</span><span class="cls_020">.inl</span><span class="cls_006"> files. The</span></div>
<div style="position:absolute;left:72.00px;top:560.64px" class="cls_006"><span class="cls_006">header and its logically included</span><span class="cls_020">.inl</span><span class="cls_006"> are then included by the</span><span class="cls_020">.c</span><span class="cls_006"> or</span><span class="cls_020">.cpp</span><span class="cls_006"> files</span><span class="cls_037"><sup>[2]</sup></span><span class="cls_006"> that use them. After a</span></div>
<div style="position:absolute;left:72.00px;top:574.32px" class="cls_006"><span class="cls_006">source file is compiled into an object file, there are not necessarily any telltale indications in the object file</span></div>
<div style="position:absolute;left:72.00px;top:586.44px" class="cls_006"><span class="cls_006">that it contains an inlined instance of some method. That is, in general, the object has fully resolved the</span></div>
<div style="position:absolute;left:72.00px;top:598.44px" class="cls_006"><span class="cls_006">inlined method and does not need to make a record of its existence (there are no linkage requirements).</span></div>
<div style="position:absolute;left:72.00px;top:610.56px" class="cls_006"><span class="cls_006">Thus, although the language officially forbids it, one source file could be compiled with one definition of</span></div>
<div style="position:absolute;left:72.00px;top:622.56px" class="cls_006"><span class="cls_006">an inlined method and another source file could be compiled with a different version of what is obstensibly</span></div>
<div style="position:absolute;left:72.00px;top:634.68px" class="cls_006"><span class="cls_006">the same method. A compiler that was able to detect this would be free to report this as an error, but we are</span></div>
<div style="position:absolute;left:72.00px;top:646.80px" class="cls_006"><span class="cls_006">unaware of any compilers that do so.</span></div>
<div style="position:absolute;left:90.00px;top:672.12px" class="cls_026"><span class="cls_026"><sup>[2]</sup></span><span class="cls_027"> From here on we will refer to C++ source files containing implementation code as ".cpp" files. If the</span></div>
<div style="position:absolute;left:90.00px;top:685.92px" class="cls_027"><span class="cls_027">programming environment with which you are familiar uses the ".c" nomenclature, then please make the</span></div>
<div style="position:absolute;left:90.00px;top:696.24px" class="cls_027"><span class="cls_027">appropriate syntactic translation.</span></div>
<div style="position:absolute;left:72.00px;top:747.84px" class="cls_016"><span class="cls_016">Inlining Virtual Methods</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">73</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:74124px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background088.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">We previously noted that some compilers will refuse to inline virtual methods. This may have seemed like</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">it should be obvious. After all, a virtual method is one for which the binding is delayed until run-time.</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">Virtual methods are generally considered to be always called indirectly via a function pointer table.</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">Although this view of virtual methods is in general accurate, it is not totally so. Take, for example, the</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">following code fragment:</span></div>
<div style="position:absolute;left:72.00px;top:144.96px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:156.24px" class="cls_020"><span class="cls_020">virtual</span></div>
<div style="position:absolute;left:72.00px;top:167.64px" class="cls_020"><span class="cls_020">int x::y (char* a)</span></div>
<div style="position:absolute;left:72.00px;top:178.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:201.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:224.28px" class="cls_020"><span class="cls_020">void z (char* b)</span></div>
<div style="position:absolute;left:72.00px;top:235.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:246.84px" class="cls_020"><span class="cls_020">x_base* x_pointer = new x(some_arguments_maybe);</span></div>
<div style="position:absolute;left:96.00px;top:258.24px" class="cls_020"><span class="cls_020">x x_instance(maybe_some_more_arguments);</span></div>
<div style="position:absolute;left:96.00px;top:269.52px" class="cls_020"><span class="cls_020">x_pointer->y(b);</span></div>
<div style="position:absolute;left:96.00px;top:280.92px" class="cls_020"><span class="cls_020">x_instance.y(b);</span></div>
<div style="position:absolute;left:72.00px;top:292.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:318.36px" class="cls_020"><span class="cls_020">y()</span><span class="cls_006"> is a virtual method, but its binding doesn't always need to be delayed until runtime. In the previous</span></div>
<div style="position:absolute;left:72.00px;top:331.20px" class="cls_006"><span class="cls_006">example, </span><span class="cls_020">y()</span><span class="cls_006"> is invoked against </span><span class="cls_020">x_pointer</span><span class="cls_006"> and </span><span class="cls_020">x_instance</span><span class="cls_006">. Delayed virtual method binding is based</span></div>
<div style="position:absolute;left:72.00px;top:343.44px" class="cls_006"><span class="cls_006">on object pointer usage. Any invocation of a virtual method by an object instance will result in a direct call</span></div>
<div style="position:absolute;left:72.00px;top:355.56px" class="cls_006"><span class="cls_006">of the virtual method instance associated with the object's type. There will be no delay in the call binding.</span></div>
<div style="position:absolute;left:72.00px;top:367.68px" class="cls_006"><span class="cls_006">Such a delay would be counter-productive: The type of the object is known at compile-time, and there is</span></div>
<div style="position:absolute;left:72.00px;top:379.68px" class="cls_006"><span class="cls_006">no need or possibility for polymorphism. The additional call overhead of run-time virtual method</span></div>
<div style="position:absolute;left:72.00px;top:391.80px" class="cls_006"><span class="cls_006">resolution should be avoided by the compiler whenever possible, and because object instances have no</span></div>
<div style="position:absolute;left:72.00px;top:403.92px" class="cls_006"><span class="cls_006">polymorphic characteristics, compilers always create direct calls of virtual methods by object instances.</span></div>
<div style="position:absolute;left:72.00px;top:429.96px" class="cls_006"><span class="cls_006">In some instances, like the previous one, the type of what might potentially be a polymorphic pointer is</span></div>
<div style="position:absolute;left:72.00px;top:441.96px" class="cls_006"><span class="cls_006">also known at compile-time and a direct invocation of a virtual method is possible. Object pointers can be</span></div>
<div style="position:absolute;left:72.00px;top:454.08px" class="cls_006"><span class="cls_006">polymorphic, but if the creation of the object associated with an object pointer is visible, and there are no</span></div>
<div style="position:absolute;left:72.00px;top:466.20px" class="cls_006"><span class="cls_006">intervening assignments to the pointer of objects with unknown actual type, then the compiler can</span></div>
<div style="position:absolute;left:72.00px;top:478.20px" class="cls_006"><span class="cls_006">determine at compile-time which of the virtual instances of a method should be invoked, and it can</span></div>
<div style="position:absolute;left:72.00px;top:490.80px" class="cls_006"><span class="cls_006">generate a direct call instead of a virtual call. In the case of </span><span class="cls_020">x_pointer</span><span class="cls_006">, it trivially determined (the</span></div>
<div style="position:absolute;left:72.00px;top:503.16px" class="cls_006"><span class="cls_006">construction of the dynamic object instance is visible, and there are no intervening assignments to</span></div>
<div style="position:absolute;left:72.00px;top:515.64px" class="cls_020"><span class="cls_020">x_pointer</span><span class="cls_006"> that might change the type of the object referenced by this base class pointer) the</span></div>
<div style="position:absolute;left:72.00px;top:528.48px" class="cls_006"><span class="cls_006">polymorphic resolution of which set of virtual </span><span class="cls_020">y()</span><span class="cls_006"> methods should be invoked. In reality a large number</span></div>
<div style="position:absolute;left:72.00px;top:540.84px" class="cls_006"><span class="cls_006">of virtual method calls are resolvable at compile-time. For example, any invocation of a virtual method</span></div>
<div style="position:absolute;left:72.00px;top:553.32px" class="cls_006"><span class="cls_006">against the </span><span class="cls_020">this</span><span class="cls_006"> pointer from within a virtual method has at least a potential compile-time resolution.</span></div>
<div style="position:absolute;left:72.00px;top:579.72px" class="cls_006"><span class="cls_006">This means that a large number of virtual method calls potentially could be inlined if the compiler were</span></div>
<div style="position:absolute;left:72.00px;top:591.72px" class="cls_006"><span class="cls_006">sophisticated enough. Thus, if a profile indicated that some virtual method was accounting for a significant</span></div>
<div style="position:absolute;left:72.00px;top:603.84px" class="cls_006"><span class="cls_006">amount of a program's execution time, it may be possible to recover at least some of the method's call</span></div>
<div style="position:absolute;left:72.00px;top:615.96px" class="cls_006"><span class="cls_006">overhead by inlining it. It also means that if the compiler can inline virtual methods and you choose to</span></div>
<div style="position:absolute;left:72.00px;top:627.96px" class="cls_006"><span class="cls_006">inline one, you are almost guaranteed to have some instances of inlined calls and some instances of virtual</span></div>
<div style="position:absolute;left:72.00px;top:640.08px" class="cls_006"><span class="cls_006">calls of the same method.</span></div>
<div style="position:absolute;left:72.00px;top:693.84px" class="cls_016"><span class="cls_016">Performance Gains from Inlining</span></div>
<div style="position:absolute;left:72.00px;top:725.16px" class="cls_006"><span class="cls_006">Consider the effect of inlining a simple access method (a method that provides access to one of an object's</span></div>
<div style="position:absolute;left:72.00px;top:737.28px" class="cls_006"><span class="cls_006">attributes):</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">74</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:74976px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background089.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">int x::get_y()</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">return y;</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:130.32px" class="cls_006"><span class="cls_006">The method itself probably requires only three or four cycles. If invoked, even this trivial method can</span></div>
<div style="position:absolute;left:72.00px;top:142.32px" class="cls_006"><span class="cls_006">generate as much as 20 cycles of overhead. If inlined the method will consume only the one or two cycles</span></div>
<div style="position:absolute;left:72.00px;top:154.44px" class="cls_006"><span class="cls_006">(two less than the original instruction count because there are no call and return instructions any more).</span></div>
<div style="position:absolute;left:72.00px;top:166.44px" class="cls_006"><span class="cls_006">Thus, inlining can provide as much as a 10x speed up. It should also be remembered that most of those 20</span></div>
<div style="position:absolute;left:72.00px;top:178.56px" class="cls_006"><span class="cls_006">cycles of saved overhead had instructions associated with them. This means that in addition to saving the</span></div>
<div style="position:absolute;left:72.00px;top:190.56px" class="cls_006"><span class="cls_006">20 cycles of overhead, we also decreased our code size by a dozen instructions per static inlined method</span></div>
<div style="position:absolute;left:72.00px;top:202.68px" class="cls_006"><span class="cls_006">invocation (number of locations in a program from which the inlined method is called).</span></div>
<div style="position:absolute;left:72.00px;top:228.72px" class="cls_006"><span class="cls_006">Consider the following program:</span></div>
<div style="position:absolute;left:72.00px;top:254.52px" class="cls_020"><span class="cls_020">#include &lt;iostream.h></span></div>
<div style="position:absolute;left:72.00px;top:277.08px" class="cls_020"><span class="cls_020">//inline</span></div>
<div style="position:absolute;left:72.00px;top:288.48px" class="cls_020"><span class="cls_020">int calc (int a, int b)</span></div>
<div style="position:absolute;left:72.00px;top:299.76px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:311.16px" class="cls_020"><span class="cls_020">return a + b;</span></div>
<div style="position:absolute;left:72.00px;top:322.44px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:345.12px" class="cls_020"><span class="cls_020">main ()</span></div>
<div style="position:absolute;left:72.00px;top:356.40px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:367.80px" class="cls_020"><span class="cls_020">int x[1000];</span></div>
<div style="position:absolute;left:96.00px;top:379.08px" class="cls_020"><span class="cls_020">int y[1000];</span></div>
<div style="position:absolute;left:96.00px;top:390.36px" class="cls_020"><span class="cls_020">int z[1000];</span></div>
<div style="position:absolute;left:96.00px;top:413.04px" class="cls_020"><span class="cls_020">for (int i = 0; i &lt; 1000; ++i) {</span></div>
<div style="position:absolute;left:119.99px;top:424.44px" class="cls_020"><span class="cls_020">for (int j = 0; j &lt; 1000; ++j) {</span></div>
<div style="position:absolute;left:143.99px;top:435.72px" class="cls_020"><span class="cls_020">for (int k = 0; k &lt; 1000; ++k) {</span></div>
<div style="position:absolute;left:167.98px;top:447.00px" class="cls_020"><span class="cls_020">z[i] = calc(y[j], x[k]);</span></div>
<div style="position:absolute;left:143.99px;top:458.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:119.99px;top:469.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:481.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:492.36px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:518.04px" class="cls_006"><span class="cls_006">This program was run twice to test the effect of inlining on execution speed. The first run, in which the</span></div>
<div style="position:absolute;left:72.00px;top:530.64px" class="cls_020"><span class="cls_020">calc</span><span class="cls_006"> was inlined, took eight seconds (this is your opportunity to see how much faster your computer is</span></div>
<div style="position:absolute;left:72.00px;top:542.88px" class="cls_006"><span class="cls_006">than mine). The second run, in which calc was outlined (not inlined) took 62 seconds. That amounts to an</span></div>
<div style="position:absolute;left:72.00px;top:555.00px" class="cls_006"><span class="cls_006">almost 8x performance improvement simply by removing the call overhead. The code size also decreased</span></div>
<div style="position:absolute;left:72.00px;top:567.12px" class="cls_006"><span class="cls_006">by 30 bytes for the inlined version, which in this instance </span><span class="cls_007">decreased</span><span class="cls_006"> program size by more than 10%. The</span></div>
<div style="position:absolute;left:72.00px;top:579.12px" class="cls_006"><span class="cls_006">result of inlining this method was to make the program significantly faster and somewhat smaller.</span></div>
<div style="position:absolute;left:72.00px;top:632.88px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:664.56px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Inlining is the replacement of a method call with the code for the method.</span></div>
<div style="position:absolute;left:90.00px;top:676.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Inlining improves performance by removing call overhead and allowing cross-call optimizations</span></div>
<div style="position:absolute;left:108.00px;top:688.92px" class="cls_006"><span class="cls_006">to take place.</span></div>
<div style="position:absolute;left:90.00px;top:701.28px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Inlining is primarily an execution-time optimization, though it can also result in smaller</span></div>
<div style="position:absolute;left:108.00px;top:713.28px" class="cls_006"><span class="cls_006">executable images as well.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">75</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:75828px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background090.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 9. Inlining—Performance Considerations</span></div>
<div style="position:absolute;left:90.00px;top:117.84px" class="cls_036"><span class="cls_036">Cross-Call Optimization</span></div>
<div style="position:absolute;left:90.00px;top:135.96px" class="cls_036"><span class="cls_036">Why Not Inline?</span></div>
<div style="position:absolute;left:90.00px;top:154.08px" class="cls_036"><span class="cls_036">Development and Compile-Time Inlining Considerations</span></div>
<div style="position:absolute;left:90.00px;top:172.20px" class="cls_036"><span class="cls_036">Profile-Based Inlining</span></div>
<div style="position:absolute;left:90.00px;top:190.32px" class="cls_036"><span class="cls_036">Inlining Rules</span></div>
<div style="position:absolute;left:90.00px;top:208.44px" class="cls_036"><span class="cls_036">Key Points</span></div>
<div style="position:absolute;left:72.00px;top:254.28px" class="cls_016"><span class="cls_016">Cross-Call Optimization</span></div>
<div style="position:absolute;left:72.00px;top:285.60px" class="cls_006"><span class="cls_006">As we have already discussed, the performance advantages of avoiding expensive method invocations is</span></div>
<div style="position:absolute;left:72.00px;top:297.72px" class="cls_006"><span class="cls_006">only half of the inlining performance story. The other half is cross-call optimizations. Cross-call</span></div>
<div style="position:absolute;left:72.00px;top:309.72px" class="cls_006"><span class="cls_006">optimizations allow the compiler to perform source and machine level optimizations to a method based on</span></div>
<div style="position:absolute;left:72.00px;top:321.84px" class="cls_006"><span class="cls_006">a more expansive contextual view of its invocation. These optimizations generally take the form of doing</span></div>
<div style="position:absolute;left:72.00px;top:333.96px" class="cls_006"><span class="cls_006">things at compile-time to avoid the necessity of doing them at run-time; for example, simple things like</span></div>
<div style="position:absolute;left:72.00px;top:345.96px" class="cls_006"><span class="cls_006">converting</span></div>
<div style="position:absolute;left:72.00px;top:371.64px" class="cls_020"><span class="cls_020">float x = 90.0;</span></div>
<div style="position:absolute;left:72.00px;top:383.04px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:227.97px;top:383.04px" class="cls_020"><span class="cls_020">// nothing that changes x's value</span></div>
<div style="position:absolute;left:72.00px;top:394.32px" class="cls_020"><span class="cls_020">float y = sin(x);</span></div>
<div style="position:absolute;left:72.00px;top:420.00px" class="cls_006"><span class="cls_006">to</span></div>
<div style="position:absolute;left:72.00px;top:445.80px" class="cls_020"><span class="cls_020">float x = 90.0;</span></div>
<div style="position:absolute;left:72.00px;top:457.08px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:72.00px;top:468.36px" class="cls_020"><span class="cls_020">float y = 1.0;</span></div>
<div style="position:absolute;left:191.98px;top:468.36px" class="cls_020"><span class="cls_020">// sin(90) = 1</span></div>
<div style="position:absolute;left:72.00px;top:494.16px" class="cls_006"><span class="cls_006">This example, perhaps unlikely within the context of a single method, can become quite commonplace</span></div>
<div style="position:absolute;left:72.00px;top:506.16px" class="cls_006"><span class="cls_006">within a caller/callee method context, in which a variable is initialized by one method and then sent into</span></div>
<div style="position:absolute;left:72.00px;top:518.28px" class="cls_006"><span class="cls_006">another method as an argument. Consider the previous example in a different context:</span></div>
<div style="position:absolute;left:72.00px;top:543.96px" class="cls_020"><span class="cls_020">enum TrigFuns {SIN, COS, TAN}</span></div>
<div style="position:absolute;left:72.00px;top:566.64px" class="cls_020"><span class="cls_020">float calc_trig (TRIG_FUNS fun, float val)</span></div>
<div style="position:absolute;left:72.00px;top:577.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:589.32px" class="cls_020"><span class="cls_020">switch (fun) {</span></div>
<div style="position:absolute;left:119.99px;top:600.60px" class="cls_020"><span class="cls_020">case SIN:</span></div>
<div style="position:absolute;left:197.98px;top:600.60px" class="cls_020"><span class="cls_020">return sin(val);</span></div>
<div style="position:absolute;left:119.99px;top:611.88px" class="cls_020"><span class="cls_020">case COS:</span></div>
<div style="position:absolute;left:197.98px;top:611.88px" class="cls_020"><span class="cls_020">return cos(val);</span></div>
<div style="position:absolute;left:119.99px;top:623.28px" class="cls_020"><span class="cls_020">case TAN:</span></div>
<div style="position:absolute;left:197.98px;top:623.28px" class="cls_020"><span class="cls_020">return tan(val);</span></div>
<div style="position:absolute;left:96.00px;top:634.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:645.96px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:668.52px" class="cls_020"><span class="cls_020">TrigFuns get_trig_fun()</span></div>
<div style="position:absolute;left:72.00px;top:679.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:691.20px" class="cls_020"><span class="cls_020">return SIN;</span></div>
<div style="position:absolute;left:72.00px;top:702.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:725.16px" class="cls_020"><span class="cls_020">float get_float()</span></div>
<div style="position:absolute;left:72.00px;top:736.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:747.84px" class="cls_020"><span class="cls_020">return 90;</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">76</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:76680px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background091.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">void calculator()</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:115.92px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:96.00px;top:127.20px" class="cls_020"><span class="cls_020">TrigFuns tf = get_trig_fun();</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">float value = get_float();</span></div>
<div style="position:absolute;left:96.00px;top:149.88px" class="cls_020"><span class="cls_020">reg0 = calc_trig(tf, value);</span></div>
<div style="position:absolute;left:96.00px;top:161.16px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:72.00px;top:172.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:198.72px" class="cls_006"><span class="cls_006">If </span><span class="cls_020">get_trig_fun</span><span class="cls_006">, </span><span class="cls_020">get_float</span><span class="cls_006"> and </span><span class="cls_020">calc_trig</span><span class="cls_006"> were all inlined, the previous code snippet would</span></div>
<div style="position:absolute;left:72.00px;top:211.44px" class="cls_006"><span class="cls_006">resolve to a simple </span><span class="cls_020">reg0</span><span class="cls_006"> </span><span class="cls_020">=</span><span class="cls_006"> </span><span class="cls_020">1.0</span><span class="cls_006">. Conversely, if not inlined, the compiler would never be able to see the</span></div>
<div style="position:absolute;left:72.00px;top:223.80px" class="cls_006"><span class="cls_006">simple optimization because none of the information necessary to carry out the optimization is available</span></div>
<div style="position:absolute;left:72.00px;top:235.92px" class="cls_006"><span class="cls_006">within a single method, and only intra-method optimizations are typically possible. This is a simple</span></div>
<div style="position:absolute;left:72.00px;top:247.92px" class="cls_006"><span class="cls_006">example of how inlining allows the compiler to perform code optimizations based on what would have</span></div>
<div style="position:absolute;left:72.00px;top:260.04px" class="cls_006"><span class="cls_006">required cross-call optimization without the impact of inlining.</span></div>
<div style="position:absolute;left:72.00px;top:286.08px" class="cls_006"><span class="cls_006">The performance gains possible from this sort of cross-call code optimization can improve performance by</span></div>
<div style="position:absolute;left:72.00px;top:298.20px" class="cls_006"><span class="cls_006">significantly more than simple call avoidance can. Conversely, the gains from call avoidance are</span></div>
<div style="position:absolute;left:72.00px;top:310.20px" class="cls_006"><span class="cls_006">guaranteed and, though not always spectacular, they are regular. Code optimizations are very compiler</span></div>
<div style="position:absolute;left:72.00px;top:322.32px" class="cls_006"><span class="cls_006">dependent, and high levels of optimization can take a long time to compile and occasionally actually break</span></div>
<div style="position:absolute;left:72.00px;top:334.44px" class="cls_006"><span class="cls_006">the code. Inlined cross-call optimization is the fabled hare and call avoidance is the associated tortoise of</span></div>
<div style="position:absolute;left:72.00px;top:346.44px" class="cls_006"><span class="cls_006">inline performance gains.</span></div>
<div style="position:absolute;left:72.00px;top:372.60px" class="cls_006"><span class="cls_006">Unfortunately, optimizers sometimes use assumptions about variable alaising and volatility that run afoul</span></div>
<div style="position:absolute;left:72.00px;top:384.60px" class="cls_006"><span class="cls_006">of some source code. Optimizations can break code that uses expected, but not guaranteed, relationships</span></div>
<div style="position:absolute;left:72.00px;top:396.72px" class="cls_006"><span class="cls_006">between objects. For example, a program that makes any assumptions about the order in which variables</span></div>
<div style="position:absolute;left:72.00px;top:408.72px" class="cls_006"><span class="cls_006">will be stored on a stack can easily be undone by a compiler that chooses to base a variable in a register</span></div>
<div style="position:absolute;left:72.00px;top:420.84px" class="cls_006"><span class="cls_006">only and not reserve any stack space for the variable. Fortunately, there are a lot of simple optimizations</span></div>
<div style="position:absolute;left:72.00px;top:432.96px" class="cls_006"><span class="cls_006">that do not require that a significant number of assumptions be made. A good text on compiler construction</span></div>
<div style="position:absolute;left:72.00px;top:444.96px" class="cls_006"><span class="cls_006">should be consulted if compiler optimizations are of significant interest to you.</span></div>
<div style="position:absolute;left:72.00px;top:471.12px" class="cls_006"><span class="cls_006">Although getting too far into the mechanics of compiler optimization is out of our scope, we can point out</span></div>
<div style="position:absolute;left:72.00px;top:483.12px" class="cls_006"><span class="cls_006">the critical role literals play in some of the most effective optimizations. The previous example in which</span></div>
<div style="position:absolute;left:72.00px;top:495.72px" class="cls_006"><span class="cls_006">the trigonometric </span><span class="cls_020">sin()</span><span class="cls_006"> function of a literal was resolved at compile time is an excellent example of the</span></div>
<div style="position:absolute;left:72.00px;top:508.08px" class="cls_006"><span class="cls_006">sort of leverage that literals provide. This optimization is easily performed if the literal and associated</span></div>
<div style="position:absolute;left:72.00px;top:520.08px" class="cls_006"><span class="cls_006">variable are defined and used in the same method. It is impossible if the literal is passed in as an argument.</span></div>
<div style="position:absolute;left:72.00px;top:546.12px" class="cls_006"><span class="cls_006">Let us have a look at another simple example:</span></div>
<div style="position:absolute;left:72.00px;top:571.92px" class="cls_020"><span class="cls_020">int i = 100;</span></div>
<div style="position:absolute;left:72.00px;top:583.20px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:149.99px;top:583.20px" class="cls_020"><span class="cls_020">// nothing that changes i's value</span></div>
<div style="position:absolute;left:72.00px;top:594.60px" class="cls_020"><span class="cls_020">if (i > 10) {</span></div>
<div style="position:absolute;left:90.00px;top:605.88px" class="cls_020"><span class="cls_020">===</span></div>
<div style="position:absolute;left:149.99px;top:605.88px" class="cls_020"><span class="cls_020">// 20 instructions</span></div>
<div style="position:absolute;left:72.00px;top:617.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:628.56px" class="cls_020"><span class="cls_020">else {</span></div>
<div style="position:absolute;left:90.00px;top:639.84px" class="cls_020"><span class="cls_020">+++</span></div>
<div style="position:absolute;left:149.99px;top:639.84px" class="cls_020"><span class="cls_020">// 50 more instructions</span></div>
<div style="position:absolute;left:72.00px;top:651.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:676.80px" class="cls_006"><span class="cls_006">This code snippet is trivially reduced to:</span></div>
<div style="position:absolute;left:72.00px;top:702.60px" class="cls_020"><span class="cls_020">int i = 100;</span></div>
<div style="position:absolute;left:72.00px;top:713.88px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:149.99px;top:713.88px" class="cls_020"><span class="cls_020">// nothing that changes i's value</span></div>
<div style="position:absolute;left:72.00px;top:725.28px" class="cls_020"><span class="cls_020">===</span></div>
<div style="position:absolute;left:149.99px;top:725.28px" class="cls_020"><span class="cls_020">// 20 instructions</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:77532px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background092.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">This reduces code size by a couple hundred bytes and removes a conditional test and branch. In this case it</span></div>
<div style="position:absolute;left:72.00px;top:83.52px" class="cls_006"><span class="cls_006">is not a huge win, but it is effective. You may remark that it is stupid to set </span><span class="cls_020">i</span><span class="cls_006"> to 100 and then turn around</span></div>
<div style="position:absolute;left:72.00px;top:96.24px" class="cls_006"><span class="cls_006">and test </span><span class="cls_020">i</span><span class="cls_006">, and you would be correct. It is stupid within the context of a single method. Conversely, it is</span></div>
<div style="position:absolute;left:72.00px;top:108.60px" class="cls_006"><span class="cls_006">also exactly the sort of thing that happens repeatedly in situations where the variable is initialized in one</span></div>
<div style="position:absolute;left:72.00px;top:120.72px" class="cls_006"><span class="cls_006">method and then passed into another method. This is a particularly commonplace occurrence in</span></div>
<div style="position:absolute;left:72.00px;top:132.72px" class="cls_006"><span class="cls_006">defensively programed routines that do range checks on input arguments.</span></div>
<div style="position:absolute;left:72.00px;top:158.88px" class="cls_006"><span class="cls_006">Consider the following method containing a case statement:</span></div>
<div style="position:absolute;left:72.00px;top:184.56px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:195.84px" class="cls_020"><span class="cls_020">bool is_hex (char c, int& value)</span></div>
<div style="position:absolute;left:72.00px;top:207.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:218.52px" class="cls_020"><span class="cls_020">switch (c) {</span></div>
<div style="position:absolute;left:119.99px;top:229.80px" class="cls_020"><span class="cls_020">case '0' value = 0; break;</span></div>
<div style="position:absolute;left:119.99px;top:241.20px" class="cls_020"><span class="cls_020">case '1' value = 1; break;</span></div>
<div style="position:absolute;left:119.99px;top:252.48px" class="cls_020"><span class="cls_020">case '2' value = 2; break;</span></div>
<div style="position:absolute;left:119.99px;top:263.88px" class="cls_020"><span class="cls_020">case '3' value = 3; break;</span></div>
<div style="position:absolute;left:119.99px;top:275.16px" class="cls_020"><span class="cls_020">case '4' value = 4; break;</span></div>
<div style="position:absolute;left:119.99px;top:286.44px" class="cls_020"><span class="cls_020">case '5' value = 5; break;</span></div>
<div style="position:absolute;left:119.99px;top:297.84px" class="cls_020"><span class="cls_020">case '6' value = 6; break;</span></div>
<div style="position:absolute;left:119.99px;top:309.12px" class="cls_020"><span class="cls_020">case '7' value = 7; break;</span></div>
<div style="position:absolute;left:119.99px;top:320.52px" class="cls_020"><span class="cls_020">case '8' value = 8; break;</span></div>
<div style="position:absolute;left:119.99px;top:331.80px" class="cls_020"><span class="cls_020">case '9' value = 9; break;</span></div>
<div style="position:absolute;left:119.99px;top:343.08px" class="cls_020"><span class="cls_020">case 'a': value = 10; break;</span></div>
<div style="position:absolute;left:119.99px;top:354.48px" class="cls_020"><span class="cls_020">case 'A': value = 10; break;</span></div>
<div style="position:absolute;left:119.99px;top:365.76px" class="cls_020"><span class="cls_020">case 'b': value = 11; break;</span></div>
<div style="position:absolute;left:119.99px;top:377.16px" class="cls_020"><span class="cls_020">case 'B': value = 11; break;</span></div>
<div style="position:absolute;left:119.99px;top:388.44px" class="cls_020"><span class="cls_020">case 'c': value = 12; break;</span></div>
<div style="position:absolute;left:119.99px;top:399.72px" class="cls_020"><span class="cls_020">case 'C': value = 12; break;</span></div>
<div style="position:absolute;left:119.99px;top:411.12px" class="cls_020"><span class="cls_020">case 'd': value = 13; break;</span></div>
<div style="position:absolute;left:119.99px;top:422.40px" class="cls_020"><span class="cls_020">case 'D': value = 13; break;</span></div>
<div style="position:absolute;left:119.99px;top:433.80px" class="cls_020"><span class="cls_020">case 'e': value = 14; break;</span></div>
<div style="position:absolute;left:119.99px;top:445.08px" class="cls_020"><span class="cls_020">case 'E': value = 14; break;</span></div>
<div style="position:absolute;left:119.99px;top:456.36px" class="cls_020"><span class="cls_020">case 'f': value = 15; break;</span></div>
<div style="position:absolute;left:119.99px;top:467.76px" class="cls_020"><span class="cls_020">case 'F': value = 15; break;</span></div>
<div style="position:absolute;left:119.99px;top:479.04px" class="cls_020"><span class="cls_020">default: return false;</span></div>
<div style="position:absolute;left:96.00px;top:490.44px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:501.72px" class="cls_020"><span class="cls_020">return true;</span></div>
<div style="position:absolute;left:72.00px;top:513.00px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:538.80px" class="cls_006"><span class="cls_006">There are jump table mechanisms that actually can make this into a relatively efficient method, and</span></div>
<div style="position:absolute;left:72.00px;top:550.80px" class="cls_006"><span class="cls_006">certainly the range checked version of the same code would be faster, but this version illustrates an</span></div>
<div style="position:absolute;left:72.00px;top:562.92px" class="cls_006"><span class="cls_006">important point. You would generally never inline a routine like this. Depending on the sophistication of</span></div>
<div style="position:absolute;left:72.00px;top:574.92px" class="cls_006"><span class="cls_006">the compiler, it has between 10 and 100 instructions, and it just looks big. Even in its smallest incarnation,</span></div>
<div style="position:absolute;left:72.00px;top:587.04px" class="cls_006"><span class="cls_006">this routine will generate some code expansion. Conversely, examine the impact of a literal input argument</span></div>
<div style="position:absolute;left:72.00px;top:599.64px" class="cls_006"><span class="cls_006">on an inlined version of </span><span class="cls_020">is_hex()</span><span class="cls_006">. A literal argument allows a compiler to reduce the method to a single</span></div>
<div style="position:absolute;left:72.00px;top:611.88px" class="cls_006"><span class="cls_006">assignment. It may seem unlikely to think about this method being called with a literal, but imagine the</span></div>
<div style="position:absolute;left:72.00px;top:624.00px" class="cls_006"><span class="cls_006">impact of double depth inlining on the following code.</span></div>
<div style="position:absolute;left:72.00px;top:649.68px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:661.08px" class="cls_020"><span class="cls_020">int parse_hex (char* cp)</span></div>
<div style="position:absolute;left:72.00px;top:672.36px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:683.64px" class="cls_020"><span class="cls_020">int ret = 0;</span></div>
<div style="position:absolute;left:96.00px;top:695.04px" class="cls_020"><span class="cls_020">int temp;</span></div>
<div style="position:absolute;left:96.00px;top:706.32px" class="cls_020"><span class="cls_020">while (is_hex(*cp, temp)) {</span></div>
<div style="position:absolute;left:119.99px;top:717.72px" class="cls_020"><span class="cls_020">ret = (ret &lt;&lt; 4) + temp;</span></div>
<div style="position:absolute;left:119.99px;top:729.00px" class="cls_020"><span class="cls_020">++cp;</span></div>
<div style="position:absolute;left:96.00px;top:740.28px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">78</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:78384px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background093.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">return ret;</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">main()</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:127.20px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">char* alpha_number = "12345678";</span></div>
<div style="position:absolute;left:96.00px;top:149.88px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:96.00px;top:161.16px" class="cls_020"><span class="cls_020">int bin_number = parse_hex(alpha_number);</span></div>
<div style="position:absolute;left:96.00px;top:172.56px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:72.00px;top:183.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:210.00px" class="cls_006"><span class="cls_006">A good compiler could compress the inlined call of </span><span class="cls_020">parse_hex()</span><span class="cls_006"> into a simple assignment of the literal</span></div>
<div style="position:absolute;left:72.00px;top:222.84px" class="cls_006"><span class="cls_006">integer </span><span class="cls_020">0x12345678</span><span class="cls_006">. This use of inlining replaces a couple of hundred run-time instructions with a single</span></div>
<div style="position:absolute;left:72.00px;top:235.20px" class="cls_006"><span class="cls_006">run-time immediate assignment. Not only this, but it also allows additional optimizations to be performed</span></div>
<div style="position:absolute;left:72.00px;top:247.68px" class="cls_006"><span class="cls_006">based on the now known value of </span><span class="cls_020">bin_number.</span></div>
<div style="position:absolute;left:72.00px;top:274.08px" class="cls_006"><span class="cls_006">A more sophisticated possibility for the optimizations between inlined methods and literals could be</span></div>
<div style="position:absolute;left:72.00px;top:286.08px" class="cls_006"><span class="cls_006">demonstrated by passing a literal into a single argument recursive method, like the old standby example</span></div>
<div style="position:absolute;left:72.00px;top:298.20px" class="cls_006"><span class="cls_006">used to teach recursion, the Fibonacci number generator. (It pains us to use so hackneyed an example,</span></div>
<div style="position:absolute;left:72.00px;top:310.20px" class="cls_006"><span class="cls_006">particularly one so inappropriate to recursive solution, despite its recursive definition. However, its</span></div>
<div style="position:absolute;left:72.00px;top:322.32px" class="cls_006"><span class="cls_006">simplicity and general familiarity make it an easy sample target, not to mention the almost unbelievable</span></div>
<div style="position:absolute;left:72.00px;top:334.44px" class="cls_006"><span class="cls_006">performance gains from compile-time resolution for literals.)</span></div>
<div style="position:absolute;left:72.00px;top:360.12px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:371.40px" class="cls_020"><span class="cls_020">int get_fib (int x)</span></div>
<div style="position:absolute;left:72.00px;top:382.80px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:394.08px" class="cls_020"><span class="cls_020">if (x &lt;= 0) {</span></div>
<div style="position:absolute;left:119.99px;top:405.36px" class="cls_020"><span class="cls_020">return 0;</span></div>
<div style="position:absolute;left:96.00px;top:416.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:428.04px" class="cls_020"><span class="cls_020">if (x == 1) {</span></div>
<div style="position:absolute;left:119.99px;top:439.44px" class="cls_020"><span class="cls_020">return 1;</span></div>
<div style="position:absolute;left:96.00px;top:450.72px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:462.00px" class="cls_020"><span class="cls_020">if (x == 2) {</span></div>
<div style="position:absolute;left:119.99px;top:473.40px" class="cls_020"><span class="cls_020">return 1;</span></div>
<div style="position:absolute;left:96.00px;top:484.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:496.08px" class="cls_020"><span class="cls_020">else {</span></div>
<div style="position:absolute;left:119.99px;top:507.36px" class="cls_020"><span class="cls_020">return get_fib(x - 1) + get_fib(x - 2);</span></div>
<div style="position:absolute;left:96.00px;top:518.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:530.04px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:556.20px" class="cls_006"><span class="cls_006">An invocation of </span><span class="cls_020">get_fib</span><span class="cls_006"> with a literal argument could be resolved at compile-time. For example:</span></div>
<div style="position:absolute;left:72.00px;top:569.04px" class="cls_020"><span class="cls_020">get_fib(10)</span><span class="cls_006">, which would otherwise result in 109 method invocations, could be replaced at compile-</span></div>
<div style="position:absolute;left:72.00px;top:581.76px" class="cls_006"><span class="cls_006">time with the literal integer </span><span class="cls_020">55</span><span class="cls_006">. Most compilers currently are unable to provide this level of sophistication</span></div>
<div style="position:absolute;left:72.00px;top:594.12px" class="cls_006"><span class="cls_006">with regard to inline method compile-time optimization, but in the longer term, this sort of optimization</span></div>
<div style="position:absolute;left:72.00px;top:606.24px" class="cls_006"><span class="cls_006">will become relatively easy to accomplish. In the very long term, this sort of optimization will cease to be</span></div>
<div style="position:absolute;left:72.00px;top:618.24px" class="cls_006"><span class="cls_006">associated with inlining at all, and it should simply become a routine, though temporally expensive, cross-</span></div>
<div style="position:absolute;left:72.00px;top:630.36px" class="cls_006"><span class="cls_006">call optimization.</span></div>
<div style="position:absolute;left:72.00px;top:656.40px" class="cls_006"><span class="cls_006">Hopefully you are starting to realize that this inlining thing is much more the sort of optimization that a</span></div>
<div style="position:absolute;left:72.00px;top:668.52px" class="cls_006"><span class="cls_006">compiler should be doing than a programmer. We agree. Much of the really interesting inlining is selective;</span></div>
<div style="position:absolute;left:72.00px;top:680.52px" class="cls_006"><span class="cls_006">that is, methods are only inlined sometimes. The interaction of literals on method inlining is a perfect</span></div>
<div style="position:absolute;left:72.00px;top:692.64px" class="cls_006"><span class="cls_006">example. If a compiler can resolve a method's significant input arguments at compile-time, then the</span></div>
<div style="position:absolute;left:72.00px;top:704.76px" class="cls_006"><span class="cls_006">compiler is in a position perhaps to make a very cost-effective optimization. Unfortunately, when such</span></div>
<div style="position:absolute;left:72.00px;top:716.76px" class="cls_006"><span class="cls_006">optimizations are not universally applicable to all instances of a method's invocation, they transcend C++'s</span></div>
<div style="position:absolute;left:72.00px;top:728.88px" class="cls_006"><span class="cls_006">basic inlining protocol. </span><span class="cls_036">Chapter 10</span><span class="cls_006"> contains a discussion of programmer-controlled selective inlining. In</span></div>
<div style="position:absolute;left:72.00px;top:741.00px" class="cls_006"><span class="cls_006">the near term these techniques can make careful hand-tuning possible, but again, in the long term, we</span></div>
<div style="position:absolute;left:72.00px;top:753.00px" class="cls_006"><span class="cls_006">expect that compilers will do this for us.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">79</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:79236px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background094.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:98.64px" class="cls_016"><span class="cls_016">Why Not Inline?</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">If inlining is so good, why don't we just inline everything? This simple question has a lot of complicated</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">answers. Let's start the answer with an inlining situation. Suppose we inline a method that, when compiled,</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">contains 550 bytes of source code. Further suppose that 50 bytes of the called method are associated with</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">call prologue and epilogue (method invocation overhead). If our hypothetical method is statically invoked</span></div>
<div style="position:absolute;left:72.00px;top:178.32px" class="cls_006"><span class="cls_006">a dozen times (called from a dozen different locations within a program), we have just increased our</span></div>
<div style="position:absolute;left:72.00px;top:190.32px" class="cls_006"><span class="cls_006">program size by 5,450 instructions ((550 instructions per inlining—50 instructions of invocation overhead)</span></div>
<div style="position:absolute;left:72.00px;top:202.44px" class="cls_006"><span class="cls_006">* 12)—550 for the otherwise called version), and we have improved the execution performance of each</span></div>
<div style="position:absolute;left:72.00px;top:214.44px" class="cls_006"><span class="cls_006">inlined execution of the method say by only 10%. (Assume that the large method has 50 cycles of call</span></div>
<div style="position:absolute;left:72.00px;top:226.56px" class="cls_006"><span class="cls_006">overhead and that the method requires 500 cycles to execute. This is pure conjecture; some methods with</span></div>
<div style="position:absolute;left:72.00px;top:238.68px" class="cls_006"><span class="cls_006">500 machine code instructions may have an average execution time of 10 cycles and others may require</span></div>
<div style="position:absolute;left:72.00px;top:250.68px" class="cls_006"><span class="cls_006">millions of cycles.) Thus we have a 10x increase in code size of this one method with only marginal per-</span></div>
<div style="position:absolute;left:72.00px;top:262.80px" class="cls_006"><span class="cls_006">invocation performance improvement. Code expansions of this magnitude, when extrapolated across all</span></div>
<div style="position:absolute;left:72.00px;top:274.80px" class="cls_006"><span class="cls_006">the inlineable methods with a program, will have huge negative secondary performance characteristics,</span></div>
<div style="position:absolute;left:72.00px;top:286.92px" class="cls_006"><span class="cls_006">like cache misses and page faults, that will dwarf any supposed primary gains. Put differently, an over-</span></div>
<div style="position:absolute;left:72.00px;top:299.04px" class="cls_006"><span class="cls_006">aggressively inlined program will execute fewer instructions, but take longer doing so. Thus, one reason</span></div>
<div style="position:absolute;left:72.00px;top:311.04px" class="cls_006"><span class="cls_006">why all methods are not inlined is that the code expansion that inlining creates may not be tolerable.</span></div>
<div style="position:absolute;left:72.00px;top:337.20px" class="cls_006"><span class="cls_006">With disk space and memory sizes growing at the rate they are, some might assume that the size of an</span></div>
<div style="position:absolute;left:72.00px;top:349.20px" class="cls_006"><span class="cls_006">executable image is no longer an issue, particularly when virtual memory management mechanisms are</span></div>
<div style="position:absolute;left:72.00px;top:361.32px" class="cls_006"><span class="cls_006">employed to facilitate the execution of programs. Code size is not just a storage issue. Multiple instances</span></div>
<div style="position:absolute;left:72.00px;top:373.32px" class="cls_006"><span class="cls_006">of a single inlined method means that each instance will have its own address and will therefore consume</span></div>
<div style="position:absolute;left:72.00px;top:385.44px" class="cls_006"><span class="cls_006">independent cache storage, thus decreasing the effective cache size and hence its capacity miss rate. For</span></div>
<div style="position:absolute;left:72.00px;top:397.56px" class="cls_006"><span class="cls_006">example, suppose an inlined method was called with regularity from four different points in a program.</span></div>
<div style="position:absolute;left:72.00px;top:409.56px" class="cls_006"><span class="cls_006">The first time the method was executed, the code cache would fault on the compulsory miss associated</span></div>
<div style="position:absolute;left:72.00px;top:421.68px" class="cls_006"><span class="cls_006">with the program's initial call (execution) of the inlined method. When the method was executed again</span></div>
<div style="position:absolute;left:72.00px;top:433.80px" class="cls_006"><span class="cls_006">from another inlined code location, the cache would miss again because the inlined code is different each</span></div>
<div style="position:absolute;left:72.00px;top:445.80px" class="cls_006"><span class="cls_006">time it is inlined, and even if it were not, the inlined instructions appear at different addresses in the</span></div>
<div style="position:absolute;left:72.00px;top:457.92px" class="cls_006"><span class="cls_006">process' code space. In our example of four frequent call points, the inlined method would consume four</span></div>
<div style="position:absolute;left:72.00px;top:469.92px" class="cls_006"><span class="cls_006">times as much cache as the same method would if outlined. It will cache fault at least four times more than</span></div>
<div style="position:absolute;left:72.00px;top:482.04px" class="cls_006"><span class="cls_006">an outlined version. We say at least four times because of the much higher likelihood that one or more</span></div>
<div style="position:absolute;left:72.00px;top:494.16px" class="cls_006"><span class="cls_006">cached instances of the method will be ejected from the cache and need to be reloaded. The single outlined</span></div>
<div style="position:absolute;left:72.00px;top:506.16px" class="cls_006"><span class="cls_006">instance would have much higher usage and thus be much less likely to be ejected. The performance</span></div>
<div style="position:absolute;left:72.00px;top:518.28px" class="cls_006"><span class="cls_006">improvement associated with call and return overhead may be overshadowed by the cache performance</span></div>
<div style="position:absolute;left:72.00px;top:530.28px" class="cls_006"><span class="cls_006">degradation of inlining, particularly when large methods are involved.</span></div>
<div style="position:absolute;left:72.00px;top:556.44px" class="cls_006"><span class="cls_006">Cache fault behavior associated with indiscriminate inlining can become highly degenerative. Suppose the</span></div>
<div style="position:absolute;left:72.00px;top:568.44px" class="cls_006"><span class="cls_006">working set for an execution stream just barely fits in a processor's cache; that is, the instruction stream</span></div>
<div style="position:absolute;left:72.00px;top:580.56px" class="cls_006"><span class="cls_006">almost never cache faults because the portion of the program's code space that is responsible for the vast</span></div>
<div style="position:absolute;left:72.00px;top:592.68px" class="cls_006"><span class="cls_006">majority of the program's execution all fits within the cache. Now suppose we double the size of the</span></div>
<div style="position:absolute;left:72.00px;top:604.68px" class="cls_006"><span class="cls_006">working set with indiscriminate inlining. The larger code path will now generate frequent faults because</span></div>
<div style="position:absolute;left:72.00px;top:616.80px" class="cls_006"><span class="cls_006">the cache is no longer big enough to hold the working set. This increase in cache faults will impact</span></div>
<div style="position:absolute;left:72.00px;top:628.80px" class="cls_006"><span class="cls_006">performance severely, consuming all the gains we might otherwise have achieved by avoiding method</span></div>
<div style="position:absolute;left:72.00px;top:640.92px" class="cls_006"><span class="cls_006">calls. So the second reason why all methods are not inlined is that the side effects of code expansion may</span></div>
<div style="position:absolute;left:72.00px;top:653.04px" class="cls_006"><span class="cls_006">not be tolerable.</span></div>
<div style="position:absolute;left:72.00px;top:679.08px" class="cls_006"><span class="cls_006">Inline code expansion can sometimes take on another degenerative characteristic. Inlining a method can</span></div>
<div style="position:absolute;left:72.00px;top:691.20px" class="cls_006"><span class="cls_006">sometimes create exponential code growth. This can occur when relatively large routines are inlined one</span></div>
<div style="position:absolute;left:72.00px;top:703.68px" class="cls_006"><span class="cls_006">within another. Take for example four methods </span><span class="cls_020">A</span><span class="cls_006">, </span><span class="cls_020">B</span><span class="cls_006">, </span><span class="cls_020">C</span><span class="cls_006">, and </span><span class="cls_020">D</span><span class="cls_006">, each of which contains 500 bytes of</span></div>
<div style="position:absolute;left:72.00px;top:716.04px" class="cls_006"><span class="cls_006">instructions.</span></div>
<div style="position:absolute;left:72.00px;top:741.72px" class="cls_020"><span class="cls_020">int D()</span></div>
<div style="position:absolute;left:72.00px;top:753.12px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">80</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:80088px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background095.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">... // 500 code bytes of functionality</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">int C()</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:127.20px" class="cls_020"><span class="cls_020">D();</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">... // 500 code bytes of functionality</span></div>
<div style="position:absolute;left:96.00px;top:149.88px" class="cls_020"><span class="cls_020">D();</span></div>
<div style="position:absolute;left:72.00px;top:161.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:183.84px" class="cls_020"><span class="cls_020">int B()</span></div>
<div style="position:absolute;left:72.00px;top:195.12px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:206.52px" class="cls_020"><span class="cls_020">C();</span></div>
<div style="position:absolute;left:96.00px;top:217.80px" class="cls_020"><span class="cls_020">... // 500 code bytes of functionality</span></div>
<div style="position:absolute;left:96.00px;top:229.20px" class="cls_020"><span class="cls_020">C();</span></div>
<div style="position:absolute;left:72.00px;top:240.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:263.16px" class="cls_020"><span class="cls_020">int A()</span></div>
<div style="position:absolute;left:72.00px;top:274.44px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:285.84px" class="cls_020"><span class="cls_020">B();</span></div>
<div style="position:absolute;left:96.00px;top:297.12px" class="cls_020"><span class="cls_020">... // 500 code bytes of functionality</span></div>
<div style="position:absolute;left:96.00px;top:308.40px" class="cls_020"><span class="cls_020">B();</span></div>
<div style="position:absolute;left:72.00px;top:319.80px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:342.48px" class="cls_020"><span class="cls_020">int main ()</span></div>
<div style="position:absolute;left:72.00px;top:353.76px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:365.04px" class="cls_020"><span class="cls_020">A(); --- A(); --- A();---. A(); --- A(); ---</span></div>
<div style="position:absolute;left:96.00px;top:376.44px" class="cls_020"><span class="cls_020">A(); --- A(); --- A(); --- A(); --- A();</span></div>
<div style="position:absolute;left:72.00px;top:387.72px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:414.00px" class="cls_020"><span class="cls_020">A</span><span class="cls_006"> invokes </span><span class="cls_020">B</span><span class="cls_006"> twice, </span><span class="cls_020">B</span><span class="cls_006"> invokes </span><span class="cls_020">C</span><span class="cls_006"> twice, </span><span class="cls_020">C</span><span class="cls_006"> invokes </span><span class="cls_020">D</span><span class="cls_006"> twice, and </span><span class="cls_020">A</span><span class="cls_006"> is invoked 10 times by </span><span class="cls_020">main</span><span class="cls_006">. Inlining </span><span class="cls_020">A</span><span class="cls_006">, </span><span class="cls_020">B</span><span class="cls_006">,</span></div>
<div style="position:absolute;left:72.00px;top:426.72px" class="cls_020"><span class="cls_020">C</span><span class="cls_006">, and </span><span class="cls_020">D</span><span class="cls_006"> will increase the size of the code associated with these four methods by more than 70K bytes, a</span></div>
<div style="position:absolute;left:72.00px;top:439.08px" class="cls_006"><span class="cls_006">37x increase in the size of the code supplying this functionality. Although the previous example was overly</span></div>
<div style="position:absolute;left:72.00px;top:451.08px" class="cls_006"><span class="cls_006">simplistic and in general not likely to occur exactly as presented, the reality of overly aggressive inlining</span></div>
<div style="position:absolute;left:72.00px;top:463.20px" class="cls_006"><span class="cls_006">can be an explosion in code size. So the third reason all methods are not inlined is that the code expansion</span></div>
<div style="position:absolute;left:72.00px;top:475.32px" class="cls_006"><span class="cls_006">will be intolerable.</span></div>
<div style="position:absolute;left:72.00px;top:501.36px" class="cls_006"><span class="cls_006">If you just looked back a couple pages and said to yourself, "Hey, those first three reasons for not inlining</span></div>
<div style="position:absolute;left:72.00px;top:513.36px" class="cls_006"><span class="cls_006">are all the same one," then you are correct. If you did not, then you are not paying attention and are</span></div>
<div style="position:absolute;left:72.00px;top:525.48px" class="cls_006"><span class="cls_006">perhaps in need of additional caffeine. Code expansion is THE main reason for not inlining everything.</span></div>
<div style="position:absolute;left:72.00px;top:537.60px" class="cls_006"><span class="cls_006">This will be even more the case as compiler quality improves and compilers are better able to resolve local</span></div>
<div style="position:absolute;left:72.00px;top:549.60px" class="cls_006"><span class="cls_006">static artifacts within inlined methods.</span></div>
<div style="position:absolute;left:72.00px;top:575.76px" class="cls_006"><span class="cls_006">There are some additional reasons for not inlining, particularly on large projects and when using</span></div>
<div style="position:absolute;left:72.00px;top:587.76px" class="cls_006"><span class="cls_006">complicated methods. An inlined method creates compilation dependencies on the implementation of a</span></div>
<div style="position:absolute;left:72.00px;top:599.88px" class="cls_006"><span class="cls_006">method, not just on its interface. Thus, a method that is expected to be changed often during a program's</span></div>
<div style="position:absolute;left:72.00px;top:611.88px" class="cls_006"><span class="cls_006">development is not a particularly good candidate. As a general rule, any inlining that decreases code size is</span></div>
<div style="position:absolute;left:72.00px;top:624.00px" class="cls_006"><span class="cls_006">a good one, and any inlining that significantly increases code size is not. A good secondary rule is that a</span></div>
<div style="position:absolute;left:72.00px;top:636.12px" class="cls_006"><span class="cls_006">method with any volatility to its implementation should not be inlined.</span></div>
<div style="position:absolute;left:72.00px;top:662.16px" class="cls_006"><span class="cls_006">Another reason for not inlining everything is that some methods cannot be inlined; for example, recursive</span></div>
<div style="position:absolute;left:72.00px;top:674.76px" class="cls_006"><span class="cls_006">methods cannot be inlined. Suppose some method </span><span class="cls_020">A</span><span class="cls_006"> called itself. Any attempt to inline </span><span class="cls_020">A</span><span class="cls_006"> would result in</span></div>
<div style="position:absolute;left:72.00px;top:687.48px" class="cls_006"><span class="cls_006">an infinite loop as the compiler continually attempted to insert </span><span class="cls_020">A</span><span class="cls_006"> into </span><span class="cls_020">A</span><span class="cls_006">. (There are actually some cases in</span></div>
<div style="position:absolute;left:72.00px;top:699.84px" class="cls_006"><span class="cls_006">which a very clever compiler could inline a function, particularly if the variable that controls the recursion</span></div>
<div style="position:absolute;left:72.00px;top:711.96px" class="cls_006"><span class="cls_006">is passed in as a literal.) Thus, recursive methods generally cannot be inlined (though later we will discuss</span></div>
<div style="position:absolute;left:72.00px;top:723.96px" class="cls_006"><span class="cls_006">some mechanisms to achieve a similar net effect). Methods that are indirectly recursive can sometimes be</span></div>
<div style="position:absolute;left:72.00px;top:736.56px" class="cls_006"><span class="cls_006">inlined. For example if </span><span class="cls_020">A</span><span class="cls_006"> calls </span><span class="cls_020">B</span><span class="cls_006"> and </span><span class="cls_020">B</span><span class="cls_006"> calls </span><span class="cls_020">A</span><span class="cls_006">, then </span><span class="cls_020">B</span><span class="cls_006">, although indirectly recursive, can be inlined.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">81</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:80940px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background096.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:98.64px" class="cls_016"><span class="cls_016">Development and Compile-Time Inlining Considerations</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">Inlined methods must logically appear in their class' headers. This is necessary to make the code bodies of</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">inlined methods available to their invokers. Unfortunately this also means that any change in the body of</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">an inlined method will necessitate the recompilation of every module that uses it—that is </span><span class="cls_007">recompilation,</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">not just relinking. For large programs this can actually increase a program's development time due to the</span></div>
<div style="position:absolute;left:72.00px;top:178.32px" class="cls_006"><span class="cls_006">amount of extra time consumed per compile.</span></div>
<div style="position:absolute;left:72.00px;top:204.36px" class="cls_006"><span class="cls_006">Debugging of inlined code is complicated by the fact that single breakpoints cannot be used to track entry</span></div>
<div style="position:absolute;left:72.00px;top:216.36px" class="cls_006"><span class="cls_006">and exit from inlined methods. There are ways of using watchpoints to accomplish the same thing, though</span></div>
<div style="position:absolute;left:72.00px;top:228.48px" class="cls_006"><span class="cls_006">doing so hampers the debugger's performance. It is also difficult to track variable names across the source</span></div>
<div style="position:absolute;left:72.00px;top:240.60px" class="cls_006"><span class="cls_006">boundaries of the invoking and invoked methods.</span></div>
<div style="position:absolute;left:72.00px;top:266.64px" class="cls_006"><span class="cls_006">Inlined methods do not generally appear in program profiles (tables that indicate a program's execution</span></div>
<div style="position:absolute;left:72.00px;top:278.76px" class="cls_006"><span class="cls_006">behavior based on sample executions). "Calls" to inlined methods are sometimes invisible to profilers.</span></div>
<div style="position:absolute;left:72.00px;top:290.76px" class="cls_006"><span class="cls_006">Once a method is inlined it must be assumed that the code is executed whenever its enclosing method is</span></div>
<div style="position:absolute;left:72.00px;top:302.88px" class="cls_006"><span class="cls_006">executed, though in some instances this it is not necessarily the case. This complicates decisions about</span></div>
<div style="position:absolute;left:72.00px;top:314.88px" class="cls_006"><span class="cls_006">extreme performance measures, like rewriting methods in assembly language.</span></div>
<div style="position:absolute;left:72.00px;top:341.04px" class="cls_006"><span class="cls_006">A properly working compiler will not generate errors as a by-product of its inlinings. Conversely,</span></div>
<div style="position:absolute;left:72.00px;top:353.04px" class="cls_006"><span class="cls_006">compilers are very sophisticated pieces of software and C++ is a very complicated language. It is unlikely</span></div>
<div style="position:absolute;left:72.00px;top:365.16px" class="cls_006"><span class="cls_006">that the ideal error-free C++ compiler will exist any time soon. This creates the possibility that inlining</span></div>
<div style="position:absolute;left:72.00px;top:377.28px" class="cls_006"><span class="cls_006">optimizations may generate errors of their own. In terms of inlining, the likelihood of this is relatively low</span></div>
<div style="position:absolute;left:72.00px;top:389.28px" class="cls_006"><span class="cls_006">because compilers are free to determine the complexity of an inlining request that they accept. On the other</span></div>
<div style="position:absolute;left:72.00px;top:401.40px" class="cls_006"><span class="cls_006">hand, errors induced by inlining are, as a rule, very difficult to find, as are most compiler-induced errors.</span></div>
<div style="position:absolute;left:72.00px;top:455.16px" class="cls_016"><span class="cls_016">Profile-Based Inlining</span></div>
<div style="position:absolute;left:72.00px;top:486.48px" class="cls_006"><span class="cls_006">There are some inlining decisions that seem trivial and some that have guaranteed positive results, and</span></div>
<div style="position:absolute;left:72.00px;top:498.60px" class="cls_006"><span class="cls_006">some recursive methods seem to cry out for better performance via call unrolling. The fact is, however,</span></div>
<div style="position:absolute;left:72.00px;top:510.60px" class="cls_006"><span class="cls_006">that we could invest a lot of effort into inlining a program, significantly increase its size and compile time,</span></div>
<div style="position:absolute;left:72.00px;top:522.72px" class="cls_006"><span class="cls_006">and see very little performance improvement, or even a performance degradation, for our trouble.</span></div>
<div style="position:absolute;left:72.00px;top:534.84px" class="cls_006"><span class="cls_006">Conversely, we could inline a couple of important methods and see a significant performance improvement.</span></div>
<div style="position:absolute;left:72.00px;top:546.84px" class="cls_006"><span class="cls_006">The difference between spinning our wheels inlining unprofitable methods and significantly improving the</span></div>
<div style="position:absolute;left:72.00px;top:558.96px" class="cls_006"><span class="cls_006">speed of our programs is the selection of the right methods for inlining. The best way of finding the right</span></div>
<div style="position:absolute;left:72.00px;top:570.96px" class="cls_006"><span class="cls_006">methods is via profiling, which is most effective when a representative data sample can be used for the</span></div>
<div style="position:absolute;left:72.00px;top:583.08px" class="cls_006"><span class="cls_006">generation of profile data.</span></div>
<div style="position:absolute;left:72.00px;top:609.12px" class="cls_006"><span class="cls_006">Profiling is a performance-testing technique that relies on a profiling tool (software suite) to instrument a</span></div>
<div style="position:absolute;left:72.00px;top:621.24px" class="cls_006"><span class="cls_006">program (insert measurement code) so that its performance can be characterized during sample executions</span></div>
<div style="position:absolute;left:72.00px;top:633.36px" class="cls_006"><span class="cls_006">of the program. The quality of the profile is directly dependent on the quality of the sample data used to</span></div>
<div style="position:absolute;left:72.00px;top:645.36px" class="cls_006"><span class="cls_006">generate it. Profilers come in many different shapes and sizes and their possible range of output is highly</span></div>
<div style="position:absolute;left:72.00px;top:657.48px" class="cls_006"><span class="cls_006">variable, but in general, all profilers will provide at least information about which methods are being</span></div>
<div style="position:absolute;left:72.00px;top:669.48px" class="cls_006"><span class="cls_006">executed and how often they are being executed. Most profilers we are familiar with will also provide an</span></div>
<div style="position:absolute;left:72.00px;top:681.60px" class="cls_006"><span class="cls_006">execution trace. Using this information, a programmer is in a position to make informed inlining decisions.</span></div>
<div style="position:absolute;left:72.00px;top:707.64px" class="cls_006"><span class="cls_006">Methods have two different sizes: dynamic and static. Static method size is the number of bytes in the</span></div>
<div style="position:absolute;left:72.00px;top:719.76px" class="cls_006"><span class="cls_006">compiled machine code for a method. This is the upper bound for the amount of additional code that will</span></div>
<div style="position:absolute;left:72.00px;top:731.88px" class="cls_006"><span class="cls_006">be added to a program each time a method is inlined. Dynamic method size is the number of instructions a</span></div>
<div style="position:absolute;left:72.00px;top:743.88px" class="cls_006"><span class="cls_006">method executes per invocation, or the amount of execution time it consumes per invocation. This will</span></div>
<div style="position:absolute;left:72.00px;top:756.00px" class="cls_006"><span class="cls_006">provide an indication of the ratio of call/return overhead to method execution time. Frequently there is a</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">82</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:81792px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background097.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">strong correlation between method size and execution time, though in some cases methods with relatively</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">low instruction counts can have unexpectedly large execution times. Methods with deeply nested loops are</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">an obvious example, but even seemingly simple methods can occasionally have poor execution efficiency</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">because of things like poor cache interaction (methods that interact with uncacheable data are good cases</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">in point).</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_006"><span class="cls_006">Static method size is an artifact of compilation; that is, it is fixed at compile-time. Dynamic method size</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">can be significantly impacted by run-time artifacts. It is dependent on the use of good sample data for</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">profile data generation. If the sample executions of a program that are used to generate profile data are</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">representative, then reasonably accurate dynamic method sizes will be generated. Conversely,</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">nonrepresentative sample data may provide erratic results. It is always possible that a profile will provide</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">no data about a method; that is, some methods are seldom if ever executed. Such methods generally will</span></div>
<div style="position:absolute;left:72.00px;top:217.68px" class="cls_006"><span class="cls_006">not appear in a profile, or they will have very low call frequencies.</span></div>
<div style="position:absolute;left:72.00px;top:243.84px" class="cls_006"><span class="cls_006">Profilers tend either to count instructions or measure time. Time is a more accurate metric, but instruction</span></div>
<div style="position:absolute;left:72.00px;top:255.84px" class="cls_006"><span class="cls_006">counts are easier to generate and they can be used to provide good data with which to make informed</span></div>
<div style="position:absolute;left:72.00px;top:267.96px" class="cls_006"><span class="cls_006">inlining decisions. The problem with performance metrics based on instruction counts are</span></div>
<div style="position:absolute;left:90.00px;top:294.24px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Even on architectures that claim single instruction execution for most instructions, the reality is</span></div>
<div style="position:absolute;left:108.00px;top:306.36px" class="cls_006"><span class="cls_006">that some instructions take longer than others. Loads and stores generally take at least twice as</span></div>
<div style="position:absolute;left:108.00px;top:318.48px" class="cls_006"><span class="cls_006">long as logic and arithmetic instructions.</span></div>
<div style="position:absolute;left:90.00px;top:330.72px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   On architectures with highly variable single-instruction execution-times, instruction counts can be</span></div>
<div style="position:absolute;left:108.00px;top:342.84px" class="cls_006"><span class="cls_006">very misleading. Some instructions may execute in a single cycle, and others may require dozens</span></div>
<div style="position:absolute;left:108.00px;top:354.96px" class="cls_006"><span class="cls_006">of cycles. Thus, ten fast instructions can consume fewer execution cycles than one slow</span></div>
<div style="position:absolute;left:108.00px;top:366.96px" class="cls_006"><span class="cls_006">instruction.</span></div>
<div style="position:absolute;left:90.00px;top:379.32px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Instruction counts completely ignore the impact of lower-level architectural structures on</span></div>
<div style="position:absolute;left:108.00px;top:391.32px" class="cls_006"><span class="cls_006">performance. This includes things like cache efficiency, branching effects on pipelines, register</span></div>
<div style="position:absolute;left:108.00px;top:403.44px" class="cls_006"><span class="cls_006">versus memory utilization, and memory access latencies.</span></div>
<div style="position:absolute;left:72.00px;top:429.48px" class="cls_006"><span class="cls_006">Fortunately, profilers generally will provide a scaled instruction count metric that will take into account</span></div>
<div style="position:absolute;left:72.00px;top:441.60px" class="cls_006"><span class="cls_006">variances in instruction timings, and for relatively large numbers of instructions, the variances will tend to</span></div>
<div style="position:absolute;left:72.00px;top:453.72px" class="cls_006"><span class="cls_006">average out. Unfortunately, it is frequently the case that inlining decisions are made on small instruction</span></div>
<div style="position:absolute;left:72.00px;top:465.72px" class="cls_006"><span class="cls_006">count metrics and interaction with the system's architectural details can easily overshadow raw instruction</span></div>
<div style="position:absolute;left:72.00px;top:477.84px" class="cls_006"><span class="cls_006">count metrics.</span></div>
<div style="position:absolute;left:72.00px;top:503.88px" class="cls_006"><span class="cls_006">We are aware of an example in which instruction counts were not particularly effective as a metric. A</span></div>
<div style="position:absolute;left:72.00px;top:516.00px" class="cls_006"><span class="cls_006">colleague invented a significantly faster algorithm for calculating TCP/IP checksums, but he encountered</span></div>
<div style="position:absolute;left:72.00px;top:528.00px" class="cls_006"><span class="cls_006">stiff resistance to adoption of his new technique because the profiles for the new methodology showed</span></div>
<div style="position:absolute;left:72.00px;top:540.12px" class="cls_006"><span class="cls_006">larger instruction counts than the previous method. It was only when the other programmers abandoned</span></div>
<div style="position:absolute;left:72.00px;top:552.24px" class="cls_006"><span class="cls_006">their narrow view of performance being equal to instruction counts, and adopted a more informed view of</span></div>
<div style="position:absolute;left:72.00px;top:564.24px" class="cls_006"><span class="cls_006">performance being an elapsed time issue, that the larger, but faster, algorithm was adopted, the moral being,</span></div>
<div style="position:absolute;left:72.00px;top:576.36px" class="cls_006"><span class="cls_006">even though more than likely you will be provided with instruction count metrics, do not suppose that they</span></div>
<div style="position:absolute;left:72.00px;top:588.36px" class="cls_006"><span class="cls_006">tell the entire story.</span></div>
<div style="position:absolute;left:72.00px;top:614.52px" class="cls_006"><span class="cls_006">A simple profile will indicate the number of times a method is invoked and the percentage of total</span></div>
<div style="position:absolute;left:72.00px;top:626.52px" class="cls_006"><span class="cls_006">execution time each method consumed. Generally this information is enough to do a reasonably good job</span></div>
<div style="position:absolute;left:72.00px;top:638.64px" class="cls_006"><span class="cls_006">of choosing the profiling candidates. Methods with large dynamic size will seldom return much of a</span></div>
<div style="position:absolute;left:72.00px;top:650.76px" class="cls_006"><span class="cls_006">performance improvement if inlined, even if they have high invocation rates. The ratio of its call/return</span></div>
<div style="position:absolute;left:72.00px;top:662.76px" class="cls_006"><span class="cls_006">overhead to its general execution time will be very low, and the small improvement in performance will be</span></div>
<div style="position:absolute;left:72.00px;top:674.88px" class="cls_006"><span class="cls_006">generally unnoticeable. On the other hand, a method with a small dynamic size and a large invocation rate</span></div>
<div style="position:absolute;left:72.00px;top:686.88px" class="cls_006"><span class="cls_006">will produce significant performance gains if inlined. Typically small dynamic size and small static size</span></div>
<div style="position:absolute;left:72.00px;top:699.00px" class="cls_006"><span class="cls_006">will be highly correlated; however sometimes a small dynamic size will be associated with a method with a</span></div>
<div style="position:absolute;left:72.00px;top:711.12px" class="cls_006"><span class="cls_006">large static size. Inlining such methods will result in code expansion, and caution is advised. Sometimes</span></div>
<div style="position:absolute;left:72.00px;top:723.12px" class="cls_006"><span class="cls_006">such methods can be rewritten to extract the core functionality into an inlined routine. This technique is</span></div>
<div style="position:absolute;left:72.00px;top:735.24px" class="cls_006"><span class="cls_006">presented later.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">83</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:82644px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background098.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_036"><span class="cls_036">Table 9.1</span><span class="cls_006"> provides a reasonable set of inlining guidelines.</span></div>
<div style="position:absolute;left:72.00px;top:96.96px" class="cls_006"><span class="cls_006">A basic program profile will indicate which methods have high execution rates, but they generally do not</span></div>
<div style="position:absolute;left:72.00px;top:109.08px" class="cls_006"><span class="cls_006">give you invocation point frequencies; that is, if a method is called 1,000 times, and it has 20 static</span></div>
<div style="position:absolute;left:72.00px;top:121.20px" class="cls_006"><span class="cls_006">invocations in the code, a basic profile will probably not tell what percentage of each call was associated</span></div>
<div style="position:absolute;left:72.00px;top:133.20px" class="cls_006"><span class="cls_006">with each call point. Inlining decisions about medium size methods with high dynamic and static call</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_006"><span class="cls_006">frequencies could benefit significantly from this information. If only a small fraction of a method's static</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">occurrences account for the bulk of its dynamic execution, then it may be cost-effective to selectively</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">inline (a mechanism for inlining only some of a method's invocations, discussed in the next chapter) its</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">high-usage cases. If code expansion is not an issue, then general inlining of such methods may be</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">acceptable. Remember, the secondary cache and paging effects of inlining are by-products of code</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">expansion.</span></div>
<div style="position:absolute;left:202.08px;top:234.12px" class="cls_021"><span class="cls_021">Table 9.1. The Inlining Decision Matrix</span></div>
<div style="position:absolute;left:321.36px;top:249.24px" class="cls_031"><span class="cls_031">Static Size</span></div>
<div style="position:absolute;left:72.00px;top:264.36px" class="cls_031"><span class="cls_031">Dynamic</span></div>
<div style="position:absolute;left:172.20px;top:264.36px" class="cls_031"><span class="cls_031">Large (more than 20 lines</span></div>
<div style="position:absolute;left:302.88px;top:264.36px" class="cls_031"><span class="cls_031">Medium (between 5 and 20</span></div>
<div style="position:absolute;left:439.20px;top:264.36px" class="cls_031"><span class="cls_031">Small (less than</span></div>
<div style="position:absolute;left:72.00px;top:276.36px" class="cls_031"><span class="cls_031">Frequency</span></div>
<div style="position:absolute;left:172.20px;top:276.36px" class="cls_031"><span class="cls_031">of code)</span></div>
<div style="position:absolute;left:302.88px;top:276.36px" class="cls_031"><span class="cls_031">lines of code)</span></div>
<div style="position:absolute;left:439.20px;top:276.36px" class="cls_031"><span class="cls_031">5 lines of code)</span></div>
<div style="position:absolute;left:72.00px;top:291.48px" class="cls_032"><span class="cls_032">Low (the bottom</span></div>
<div style="position:absolute;left:172.20px;top:291.48px" class="cls_032"><span class="cls_032">Do not inline</span></div>
<div style="position:absolute;left:302.83px;top:291.48px" class="cls_032"><span class="cls_032">Do not inline</span></div>
<div style="position:absolute;left:439.11px;top:291.48px" class="cls_032"><span class="cls_032">Inline if you have</span></div>
<div style="position:absolute;left:72.00px;top:303.48px" class="cls_032"><span class="cls_032">80% of call</span></div>
<div style="position:absolute;left:439.20px;top:303.48px" class="cls_032"><span class="cls_032">the time and</span></div>
<div style="position:absolute;left:72.00px;top:315.60px" class="cls_032"><span class="cls_032">frequency)</span></div>
<div style="position:absolute;left:439.20px;top:315.60px" class="cls_032"><span class="cls_032">patience</span></div>
<div style="position:absolute;left:72.00px;top:330.72px" class="cls_032"><span class="cls_032">Medium (the top 5-</span></div>
<div style="position:absolute;left:172.20px;top:330.72px" class="cls_032"><span class="cls_032">Do not inline</span></div>
<div style="position:absolute;left:302.79px;top:330.72px" class="cls_032"><span class="cls_032">Consider rewriting the</span></div>
<div style="position:absolute;left:439.20px;top:330.72px" class="cls_032"><span class="cls_032">Always inline</span></div>
<div style="position:absolute;left:72.00px;top:342.72px" class="cls_032"><span class="cls_032">20% of call</span></div>
<div style="position:absolute;left:302.88px;top:342.72px" class="cls_032"><span class="cls_032">method to expose its fast</span></div>
<div style="position:absolute;left:72.00px;top:354.84px" class="cls_032"><span class="cls_032">frequency)</span></div>
<div style="position:absolute;left:302.88px;top:354.84px" class="cls_032"><span class="cls_032">path and then inline</span></div>
<div style="position:absolute;left:72.00px;top:369.96px" class="cls_032"><span class="cls_032">High (the top 5% of</span></div>
<div style="position:absolute;left:172.20px;top:369.96px" class="cls_032"><span class="cls_032">Consider rewriting the</span></div>
<div style="position:absolute;left:302.88px;top:369.96px" class="cls_032"><span class="cls_032">Selectively inline the high</span></div>
<div style="position:absolute;left:439.20px;top:369.96px" class="cls_032"><span class="cls_032">Always inline</span></div>
<div style="position:absolute;left:72.00px;top:381.96px" class="cls_032"><span class="cls_032">call frequency)</span></div>
<div style="position:absolute;left:172.20px;top:381.96px" class="cls_032"><span class="cls_032">method to expose its fast</span></div>
<div style="position:absolute;left:302.88px;top:381.96px" class="cls_032"><span class="cls_032">frequency static invocation</span></div>
<div style="position:absolute;left:172.20px;top:394.08px" class="cls_032"><span class="cls_032">path and then inline</span></div>
<div style="position:absolute;left:302.88px;top:394.08px" class="cls_032"><span class="cls_032">points</span></div>
<div style="position:absolute;left:72.00px;top:422.28px" class="cls_006"><span class="cls_006">Programs tend to have fast paths, as do many large methods. Sometimes methods can be rewritten to</span></div>
<div style="position:absolute;left:72.00px;top:434.28px" class="cls_006"><span class="cls_006">expose the important, expected behavior of a method; the extraneous, error correcting portions of the</span></div>
<div style="position:absolute;left:72.00px;top:446.40px" class="cls_006"><span class="cls_006">method can be removed to another method. Take the following method, for example:</span></div>
<div style="position:absolute;left:72.00px;top:472.08px" class="cls_020"><span class="cls_020">int x::y (int a, int b)</span></div>
<div style="position:absolute;left:72.00px;top:483.36px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:494.76px" class="cls_020"><span class="cls_020">if (/* sanity check on input values for a and b*/) {</span></div>
<div style="position:absolute;left:119.99px;top:506.04px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:179.98px;top:506.04px" class="cls_020"><span class="cls_020">// inline error handling (30 lines)</span></div>
<div style="position:absolute;left:96.00px;top:517.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:528.72px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:173.98px;top:528.72px" class="cls_020"><span class="cls_020">// Real work (5 lines)</span></div>
<div style="position:absolute;left:72.00px;top:540.00px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:566.28px" class="cls_006"><span class="cls_006">Method </span><span class="cls_020">x::y</span><span class="cls_006"> has roughly 40 statements, making it a relatively large method. If the method has high</span></div>
<div style="position:absolute;left:72.00px;top:578.52px" class="cls_006"><span class="cls_006">invocation frequency and a significant number of invocation points, on the surface it may seem that</span></div>
<div style="position:absolute;left:72.00px;top:591.12px" class="cls_006"><span class="cls_006">inlining </span><span class="cls_020">x::y</span><span class="cls_006"> will not be particularly effective. It could have a code image size in excess of 1K, and if it is</span></div>
<div style="position:absolute;left:72.00px;top:603.36px" class="cls_006"><span class="cls_006">not a leaf node its inlining could cause some of the combinatorial code size explosion we already talked</span></div>
<div style="position:absolute;left:72.00px;top:615.96px" class="cls_006"><span class="cls_006">about. Conversely, there is another method hidden inside </span><span class="cls_020">x::y</span><span class="cls_006"> that could be very effectively inlined.</span></div>
<div style="position:absolute;left:72.00px;top:628.80px" class="cls_006"><span class="cls_006">Consider</span><span class="cls_020"> x::y</span><span class="cls_006"> after it is partitioned into the following two methods:</span></div>
<div style="position:absolute;left:72.00px;top:654.72px" class="cls_020"><span class="cls_020">void x::handle_input_error (int& a, int& b)</span></div>
<div style="position:absolute;left:72.00px;top:666.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:677.40px" class="cls_020"><span class="cls_020">// error handling (30 lines)</span></div>
<div style="position:absolute;left:72.00px;top:688.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:711.36px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:722.64px" class="cls_020"><span class="cls_020">int x::new_y (int a, int b)</span></div>
<div style="position:absolute;left:72.00px;top:734.04px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:745.32px" class="cls_020"><span class="cls_020">if (/* sanity check on input values for a and b*/) {</span></div>
<div style="position:absolute;left:119.99px;top:756.72px" class="cls_020"><span class="cls_020">handle_input_error(a, b);</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">84</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:83496px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background099.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:203.98px;top:81.84px" class="cls_020"><span class="cls_020">// real work of the method (5 lines)</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:119.40px" class="cls_006"><span class="cls_006">The size of </span><span class="cls_020">new_y()</span><span class="cls_006"> has been reduced to ten lines. Still not small, but much more affordable as an inlined</span></div>
<div style="position:absolute;left:72.00px;top:131.76px" class="cls_006"><span class="cls_006">method. This is only effective if erroneous input arguments are infrequent. An indication that this type of</span></div>
<div style="position:absolute;left:72.00px;top:143.76px" class="cls_006"><span class="cls_006">rewriting for inlining may be applicable will tend to manifest itself as a method with a small dynamic size</span></div>
<div style="position:absolute;left:72.00px;top:155.88px" class="cls_006"><span class="cls_006">but a large static size. Rewriting methods of this type can offer a significant performance boost without</span></div>
<div style="position:absolute;left:72.00px;top:167.88px" class="cls_006"><span class="cls_006">significantly increasing code size.</span></div>
<div style="position:absolute;left:72.00px;top:221.76px" class="cls_016"><span class="cls_016">Inlining Rules</span></div>
<div style="position:absolute;left:72.00px;top:253.08px" class="cls_006"><span class="cls_006">There are a few relatively simple rules that we can use to make inlining decisions. Singletons and trivials</span></div>
<div style="position:absolute;left:72.00px;top:265.08px" class="cls_006"><span class="cls_006">are always code size, and performance wins. Trivials can be inlined without regard to their frequency of</span></div>
<div style="position:absolute;left:72.00px;top:277.20px" class="cls_006"><span class="cls_006">use, and singletons are inlined exactly because of their usage frequency. Frequently these "no brainer"</span></div>
<div style="position:absolute;left:72.00px;top:289.32px" class="cls_006"><span class="cls_006">inlinings are enough. When they are not, profiling should indicate the most likely additional candidates.</span></div>
<div style="position:absolute;left:72.00px;top:301.32px" class="cls_006"><span class="cls_006">The next chapter presents additional mechanisms for profitably inlining nontrivial methods.</span></div>
<div style="position:absolute;left:72.00px;top:327.60px" class="cls_023"><span class="cls_023">Singletons</span></div>
<div style="position:absolute;left:72.00px;top:356.40px" class="cls_006"><span class="cls_006">A singleton method is a method that has only one point of invocation within a program. This does not</span></div>
<div style="position:absolute;left:72.00px;top:368.40px" class="cls_006"><span class="cls_006">mean that it is invoked only once when a program is executed. A singleton can exist within a loop and be</span></div>
<div style="position:absolute;left:72.00px;top:380.52px" class="cls_006"><span class="cls_006">called millions of times, but as long as a method has only one invocation point in the program, it is a</span></div>
<div style="position:absolute;left:72.00px;top:392.64px" class="cls_006"><span class="cls_006">singleton. Singletons are naturals for inlining. The fact that they have only one call point means that</span></div>
<div style="position:absolute;left:72.00px;top:404.64px" class="cls_006"><span class="cls_006">without regard to singleton size or call frequency, the resultant code will be smaller and faster after</span></div>
<div style="position:absolute;left:72.00px;top:416.76px" class="cls_006"><span class="cls_006">singleton inlining than before. The amount of improvement may be marginal, though, and not warranted</span></div>
<div style="position:absolute;left:72.00px;top:428.76px" class="cls_006"><span class="cls_006">by the effort involved in doing the inlining yourself.</span></div>
<div style="position:absolute;left:72.00px;top:454.92px" class="cls_006"><span class="cls_006">Frequently, singletons are not easily recognized as such. Often a method's singleton nature is temporary</span></div>
<div style="position:absolute;left:72.00px;top:466.92px" class="cls_006"><span class="cls_006">and/or circumstantial. Other times, singleton stature is an artifact of design. The latter type should always</span></div>
<div style="position:absolute;left:72.00px;top:479.04px" class="cls_006"><span class="cls_006">be explicitly inlined. The former type can be inlined, but its singleton status will then require monitoring to</span></div>
<div style="position:absolute;left:72.00px;top:491.16px" class="cls_006"><span class="cls_006">avoid negative consequences.</span></div>
<div style="position:absolute;left:72.00px;top:517.20px" class="cls_006"><span class="cls_006">It would be nice if compilers automatically would recognize and inline all singletons for you.</span></div>
<div style="position:absolute;left:72.00px;top:529.20px" class="cls_006"><span class="cls_006">Unfortunately, doing so would require a global analysis of a program's call tree. Global call tree generation</span></div>
<div style="position:absolute;left:72.00px;top:541.32px" class="cls_006"><span class="cls_006">is relatively straightforward, but it can be somewhat expensive if a program contains a large number of</span></div>
<div style="position:absolute;left:72.00px;top:553.44px" class="cls_006"><span class="cls_006">separately compiled modules. It is certainly not the type of analysis that is performed during code</span></div>
<div style="position:absolute;left:72.00px;top:565.44px" class="cls_006"><span class="cls_006">development or debug, but it would be a useful post-production optimization. It should be noted that this</span></div>
<div style="position:absolute;left:72.00px;top:577.56px" class="cls_006"><span class="cls_006">type of analysis for a large program can be very processor intensive—bring something to read while you</span></div>
<div style="position:absolute;left:72.00px;top:589.68px" class="cls_006"><span class="cls_006">wait (sadly, Tolstoy may be appropriate).</span></div>
<div style="position:absolute;left:72.00px;top:615.72px" class="cls_006"><span class="cls_006">As previously noted, the inlining of complex methods is frequently disallowed by the compiler. This</span></div>
<div style="position:absolute;left:72.00px;top:627.72px" class="cls_006"><span class="cls_006">makes routine inlining of singletons more of a theoretical benefit than a real one. A sophisticated compiler</span></div>
<div style="position:absolute;left:72.00px;top:639.84px" class="cls_006"><span class="cls_006">that could inline all singletons would always provide some benefit, but given the still relatively</span></div>
<div style="position:absolute;left:72.00px;top:651.96px" class="cls_006"><span class="cls_006">unsophisticated state of most compilers, singleton inlining as a standard feature is probably still a long way</span></div>
<div style="position:absolute;left:72.00px;top:663.96px" class="cls_006"><span class="cls_006">off.</span></div>
<div style="position:absolute;left:72.00px;top:690.24px" class="cls_023"><span class="cls_023">Trivials</span></div>
<div style="position:absolute;left:72.00px;top:719.04px" class="cls_006"><span class="cls_006">Trivials are small methods with generally less than four simple source level statements that compile into</span></div>
<div style="position:absolute;left:72.00px;top:731.04px" class="cls_006"><span class="cls_006">ten or fewer assembly language instructions. These methods are so small that they do not provide any</span></div>
<div style="position:absolute;left:72.00px;top:743.16px" class="cls_006"><span class="cls_006">possibility for significant code expansion. The smaller trivials will actually decrease overall code size, and</span></div>
<div style="position:absolute;left:72.00px;top:755.28px" class="cls_006"><span class="cls_006">the larger ones will possibly expand it by a fraction. The overall effect of global trivial inlining is to leave</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">85</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:84348px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background100.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">code size unaffected. Trivials tend to occur frequently in C++. Accessor methods, indirect calls, and simple</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">operator overloads tend to be small, often one-line methods, but methods that are used frequently. Inlining</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">these methods significantly diminishes the performance penalties associated with maintaining the proper</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">level of object encapsulation.</span></div>
<div style="position:absolute;left:72.00px;top:133.20px" class="cls_006"><span class="cls_006">Some compilers automatically will inline those trivial methods that are visible within the compilation</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_006"><span class="cls_006">context. This means that methods will be inlined within a separately compiled module if the compiler</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">recognizes it as trivial, but that calls of trivial methods that cross module boundaries will not be inlined.</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">This automatic inlining is a very handy feature, one that would be extended profitably to a global</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">compiler-based inlining of trivial methods. The compiler is in the best position to gauge the actual cost of a</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">call and to see the instruction size of a method. This would allow a compiler always to inline code, size,</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">neutral, or smaller methods. A more sophisticated compiler-based inlining decision could be based on a</span></div>
<div style="position:absolute;left:72.00px;top:217.68px" class="cls_006"><span class="cls_006">programmer-supplied metrics of acceptable code expansion, or based on an indication of the relative</span></div>
<div style="position:absolute;left:72.00px;top:229.80px" class="cls_006"><span class="cls_006">importance of code size and performance. This capability could be incorporated easily into an automatic</span></div>
<div style="position:absolute;left:72.00px;top:241.92px" class="cls_006"><span class="cls_006">singleton inlining pass (concomitantly making it possible to add unabridged Victor Hugo tomes to your</span></div>
<div style="position:absolute;left:72.00px;top:253.92px" class="cls_006"><span class="cls_006">reading list).</span></div>
<div style="position:absolute;left:72.00px;top:280.08px" class="cls_006"><span class="cls_006">Care needs to be taken when inlining trivials to ensure that inlined trivials stay trivial. If the scope of what</span></div>
<div style="position:absolute;left:72.00px;top:292.08px" class="cls_006"><span class="cls_006">was an inlined trivial method grows, the writer needs to be prepared to demote the method. This is</span></div>
<div style="position:absolute;left:72.00px;top:304.20px" class="cls_006"><span class="cls_006">particularly true if the method is not a leaf method (leaf methods contain no method calls, they execute and</span></div>
<div style="position:absolute;left:72.00px;top:316.20px" class="cls_006"><span class="cls_006">then return). Unexpected code explosions can result from inlining nonleaf (internal) methods. The code</span></div>
<div style="position:absolute;left:72.00px;top:328.32px" class="cls_006"><span class="cls_006">expansion for leaf methods is easily determined by counting the number of static calls to the method in a</span></div>
<div style="position:absolute;left:72.00px;top:340.44px" class="cls_006"><span class="cls_006">program and multiplying that times the number of instructions in the method minus the number of</span></div>
<div style="position:absolute;left:72.00px;top:352.44px" class="cls_006"><span class="cls_006">instructions necessary to invoke the method. When inlining a nonleaf method, any code expansion created</span></div>
<div style="position:absolute;left:72.00px;top:364.56px" class="cls_006"><span class="cls_006">by leaf expansion becomes multiplied.</span></div>
<div style="position:absolute;left:72.00px;top:418.32px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:449.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Literal arguments and inlining, when combined, provide significant opportunities for a compiler to</span></div>
<div style="position:absolute;left:108.00px;top:462.00px" class="cls_006"><span class="cls_006">provide significant performance improvements.</span></div>
<div style="position:absolute;left:90.00px;top:474.36px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Inlining may backfire, and overly aggressive inlining will almost certainly do so. Inlining can</span></div>
<div style="position:absolute;left:108.00px;top:486.36px" class="cls_006"><span class="cls_006">increase code size. Large code size suffers a higher rate of cache misses and page faults than</span></div>
<div style="position:absolute;left:108.00px;top:498.48px" class="cls_006"><span class="cls_006">smaller code.</span></div>
<div style="position:absolute;left:90.00px;top:510.84px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Nontrivial inlining decisions should be based on sample execution profiles, not gut feelings.</span></div>
<div style="position:absolute;left:90.00px;top:523.08px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Consider rewriting high frequency methods with large static size and small dynamic size to extract</span></div>
<div style="position:absolute;left:108.00px;top:535.20px" class="cls_006"><span class="cls_006">their significant dynamic characteristic, and then inline the dynamic component.</span></div>
<div style="position:absolute;left:90.00px;top:547.56px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Trivial and singleton methods can always be inlined.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">86</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:85200px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background101.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 10. Inlining Tricks</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">There are a number of "tricks" that can make inlining more effective. This chapter is dedicated to these</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">tricks. These mechanisms are increasingly available as compiler options and optimizations. Check to see</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">what your compiler will do for you before investing any significant effort in doing them yourself.</span></div>
<div style="position:absolute;left:72.00px;top:195.84px" class="cls_016"><span class="cls_016">Conditional Inlining</span></div>
<div style="position:absolute;left:72.00px;top:227.16px" class="cls_006"><span class="cls_006">The compilation, debugging, and profiling negatives associated with inlining strongly encourage the delay</span></div>
<div style="position:absolute;left:72.00px;top:239.28px" class="cls_006"><span class="cls_006">of inlining decisions until late in the development cycle, generally after the bulk of the debugging has been</span></div>
<div style="position:absolute;left:72.00px;top:251.28px" class="cls_006"><span class="cls_006">performed. Ideally, inlining decisions will be based on the results of profiling. Most compilers can use</span></div>
<div style="position:absolute;left:72.00px;top:263.40px" class="cls_006"><span class="cls_006">compile-line switches to prevent inlining, but in the event yours does not, this is a simple way of building</span></div>
<div style="position:absolute;left:72.00px;top:275.40px" class="cls_006"><span class="cls_006">your own compile-line switch.</span></div>
<div style="position:absolute;left:72.00px;top:301.56px" class="cls_006"><span class="cls_006">Sadly, profiling requires a moderate amount of effort on the part of the programmer. It is not the sort of</span></div>
<div style="position:absolute;left:72.00px;top:313.56px" class="cls_006"><span class="cls_006">thing where anyone wants to be moving methods back and forth between an inlined state for performance</span></div>
<div style="position:absolute;left:72.00px;top:325.68px" class="cls_006"><span class="cls_006">and an outlined state for normal testing. Luckily the preprocessor can be employed to provide an easy</span></div>
<div style="position:absolute;left:72.00px;top:337.80px" class="cls_006"><span class="cls_006">migration of methods from inlined to outlined. The basic idea is to use a compile-line argument to pass a</span></div>
<div style="position:absolute;left:72.00px;top:350.28px" class="cls_006"><span class="cls_006">macro definition into the compiler. The input argument is used to define a macro called </span><span class="cls_020">INLINE</span><span class="cls_006">, or it is</span></div>
<div style="position:absolute;left:72.00px;top:363.12px" class="cls_006"><span class="cls_006">omitted to leave </span><span class="cls_020">INLINE</span><span class="cls_006"> undefined. This technique depends on the separation of the definitions of all</span></div>
<div style="position:absolute;left:72.00px;top:375.96px" class="cls_006"><span class="cls_006">potentially inlined methods from outlined methods. Outlined methods are included in the standard</span><span class="cls_020">.c</span><span class="cls_006"> file,</span></div>
<div style="position:absolute;left:72.00px;top:388.68px" class="cls_006"><span class="cls_006">and potentially inlined methods are placed in a</span><span class="cls_020">.inl</span><span class="cls_006"> file. If you want to inline the methods in the </span><span class="cls_020">.inl</span><span class="cls_006"> file,</span></div>
<div style="position:absolute;left:72.00px;top:401.52px" class="cls_006"><span class="cls_006">then the </span><span class="cls_020">-D</span><span class="cls_006"> option can be used in the compile statement to define </span><span class="cls_020">INLINE</span><span class="cls_006">. Following is an example of</span></div>
<div style="position:absolute;left:72.00px;top:413.88px" class="cls_006"><span class="cls_006">how to use this compile-time inlining switch.</span></div>
<div style="position:absolute;left:72.00px;top:440.40px" class="cls_006"><span class="cls_006">File: </span><span class="cls_020">x.h:</span></div>
<div style="position:absolute;left:72.00px;top:466.32px" class="cls_020"><span class="cls_020">#if !defined(_X_H_)</span></div>
<div style="position:absolute;left:72.00px;top:477.72px" class="cls_020"><span class="cls_020">#define _X_H_</span></div>
<div style="position:absolute;left:72.00px;top:500.40px" class="cls_020"><span class="cls_020">class X {</span></div>
<div style="position:absolute;left:96.00px;top:522.96px" class="cls_020"><span class="cls_020">int y (int a</span></div>
<div style="position:absolute;left:179.98px;top:522.96px" class="cls_020"><span class="cls_020">);</span></div>
<div style="position:absolute;left:72.00px;top:545.64px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:568.32px" class="cls_020"><span class="cls_020">#if defined(INLINE)</span></div>
<div style="position:absolute;left:72.00px;top:579.60px" class="cls_020"><span class="cls_020">#include x.inl</span></div>
<div style="position:absolute;left:72.00px;top:591.00px" class="cls_020"><span class="cls_020">#endif</span></div>
<div style="position:absolute;left:72.00px;top:602.28px" class="cls_020"><span class="cls_020">#endif // _X_H_</span></div>
<div style="position:absolute;left:72.00px;top:628.56px" class="cls_006"><span class="cls_006">File: </span><span class="cls_020">x.inl:</span></div>
<div style="position:absolute;left:72.00px;top:654.48px" class="cls_020"><span class="cls_020">#if !defined(INLINE)</span></div>
<div style="position:absolute;left:72.00px;top:665.76px" class="cls_020"><span class="cls_020">#define inline</span></div>
<div style="position:absolute;left:72.00px;top:677.16px" class="cls_020"><span class="cls_020">#endif</span></div>
<div style="position:absolute;left:72.00px;top:699.72px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:711.12px" class="cls_020"><span class="cls_020">int X::y (int a)</span></div>
<div style="position:absolute;left:72.00px;top:722.40px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:745.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:86052px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background102.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">File: </span><span class="cls_020">x.c:</span></div>
<div style="position:absolute;left:72.00px;top:97.32px" class="cls_020"><span class="cls_020">#if !defined(INLINE)</span></div>
<div style="position:absolute;left:72.00px;top:108.72px" class="cls_020"><span class="cls_020">#include x.inl</span></div>
<div style="position:absolute;left:72.00px;top:120.00px" class="cls_020"><span class="cls_020">#endif</span></div>
<div style="position:absolute;left:72.00px;top:146.28px" class="cls_006"><span class="cls_006">The</span><span class="cls_020">.h</span><span class="cls_006"> file is used in its customary fashion. When </span><span class="cls_020">INLINE</span><span class="cls_006"> is defined, the</span><span class="cls_020">.h</span><span class="cls_006"> file will include the</span><span class="cls_020">.inl</span><span class="cls_006"> file</span></div>
<div style="position:absolute;left:72.00px;top:159.00px" class="cls_006"><span class="cls_006">and the </span><span class="cls_020">inline</span><span class="cls_006"> directive that precedes each method will be unaffected. When </span><span class="cls_020">INLINE</span><span class="cls_006"> is not defined,</span></div>
<div style="position:absolute;left:72.00px;top:171.84px" class="cls_006"><span class="cls_006">the</span><span class="cls_020">.h</span><span class="cls_006"> file will not include the inlined methods, but rather these methods will be included in the</span><span class="cls_020">.c</span><span class="cls_006"> file, and</span></div>
<div style="position:absolute;left:72.00px;top:184.56px" class="cls_006"><span class="cls_006">the </span><span class="cls_020">inline</span><span class="cls_006"> directive will be stripped from the front of each method. This mechanism provides easy</span></div>
<div style="position:absolute;left:72.00px;top:196.92px" class="cls_006"><span class="cls_006">mobility of the inlined methods from inlined to outlined status. This technique is an all-or-nothing</span></div>
<div style="position:absolute;left:72.00px;top:209.04px" class="cls_006"><span class="cls_006">approach. Care still needs to be exercised in creating the inlined/outlined partitions.</span></div>
<div style="position:absolute;left:72.00px;top:262.80px" class="cls_016"><span class="cls_016">Selective Inlining</span></div>
<div style="position:absolute;left:72.00px;top:294.12px" class="cls_006"><span class="cls_006">One of the most egregious deficiencies in C++ is the syntax and flexibility of its inlining mechanism.</span></div>
<div style="position:absolute;left:72.00px;top:306.24px" class="cls_006"><span class="cls_006">Although generally useful, it is painfully unsophisticated. There is no mechanism for selective inlining;</span></div>
<div style="position:absolute;left:72.00px;top:318.24px" class="cls_006"><span class="cls_006">that is, inlining a method in some places and not inlining it in other places. This makes inlining decisions</span></div>
<div style="position:absolute;left:72.00px;top:330.36px" class="cls_006"><span class="cls_006">an all or nothing choice, ignoring the reality of fast path optimization. For example, suppose a program's</span></div>
<div style="position:absolute;left:72.00px;top:342.48px" class="cls_006"><span class="cls_006">fast path (the typical execution sequence) contains two static invocations of a method that has an additional</span></div>
<div style="position:absolute;left:72.00px;top:354.48px" class="cls_006"><span class="cls_006">20 static invocations outside the fast path. There is no simple mechanism for inlining the method in its two</span></div>
<div style="position:absolute;left:72.00px;top:366.60px" class="cls_006"><span class="cls_006">critical call locations and relying on the normal call mechanism for the remaining ones. We will show you</span></div>
<div style="position:absolute;left:72.00px;top:378.60px" class="cls_006"><span class="cls_006">how to do it—it is fairly simple and very effective. Unfortunately, it requires a certain level of discipline,</span></div>
<div style="position:absolute;left:72.00px;top:390.72px" class="cls_006"><span class="cls_006">and it is hard to strongly recommend the extensive use of this mechanism.</span></div>
<div style="position:absolute;left:72.00px;top:416.76px" class="cls_006"><span class="cls_006">The simplest way to selectively inline a method is to make a copy of the outlined version of the method</span></div>
<div style="position:absolute;left:72.00px;top:429.36px" class="cls_006"><span class="cls_006">and place it in the associated</span><span class="cls_020">.h</span><span class="cls_006"> or</span><span class="cls_020">.inl</span><span class="cls_006"> file. Then change the name of the copied version of the method to</span></div>
<div style="position:absolute;left:72.00px;top:442.20px" class="cls_020"><span class="cls_020">inline__whatever_the_original_method_name_was</span><span class="cls_006">, add a prototype for the method in the</span></div>
<div style="position:absolute;left:72.00px;top:454.92px" class="cls_006"><span class="cls_006">associated</span><span class="cls_020">.h</span><span class="cls_006"> file, and then prefix the instances of the method names you want to conditionally inline with</span></div>
<div style="position:absolute;left:72.00px;top:467.76px" class="cls_006"><span class="cls_006">the string </span><span class="cls_020">inline_</span><span class="cls_006">. This will give you two versions of the method, one that is called as normal and one</span></div>
<div style="position:absolute;left:72.00px;top:480.60px" class="cls_006"><span class="cls_006">that is inlined when the original method name is prefixed by </span><span class="cls_020">inline_</span><span class="cls_006">. This mechanism is clumsy, but</span></div>
<div style="position:absolute;left:72.00px;top:492.84px" class="cls_006"><span class="cls_006">effective. It has the obvious drawback that it requires two versions of the same method to be maintained</span></div>
<div style="position:absolute;left:72.00px;top:505.44px" class="cls_006"><span class="cls_006">independently. This can be solved by copying another instance of the method to be inlined into the</span><span class="cls_020">.inl</span></div>
<div style="position:absolute;left:72.00px;top:518.28px" class="cls_006"><span class="cls_006">file and changing its name to </span><span class="cls_020">_whatever_it_was_before</span><span class="cls_006">, making it an inlined method, and then</span></div>
<div style="position:absolute;left:72.00px;top:531.12px" class="cls_006"><span class="cls_006">replacing the code body of the original version in the</span><span class="cls_020">.c</span><span class="cls_006"> file and the</span></div>
<div style="position:absolute;left:72.00px;top:543.84px" class="cls_020"><span class="cls_020">inline__whatever_the_original_method_name_was</span><span class="cls_006"> with a call to the now inlined version of</span></div>
<div style="position:absolute;left:72.00px;top:556.68px" class="cls_006"><span class="cls_006">the method named </span><span class="cls_020">_whatever_it_was_before</span><span class="cls_006">. An example will hopefully make this all clear.</span></div>
<div style="position:absolute;left:72.00px;top:582.96px" class="cls_006"><span class="cls_006">Suppose we want to selectively inline the following method:</span></div>
<div style="position:absolute;left:72.00px;top:608.76px" class="cls_020"><span class="cls_020">int x::y (int a)</span></div>
<div style="position:absolute;left:72.00px;top:620.04px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:642.72px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:668.88px" class="cls_006"><span class="cls_006">and it is located in a file called </span><span class="cls_020">x.c</span><span class="cls_006">. It would be selectively inlined by adding the following code to the</span></div>
<div style="position:absolute;left:72.00px;top:681.24px" class="cls_006"><span class="cls_006">indicated files.</span></div>
<div style="position:absolute;left:72.00px;top:707.76px" class="cls_006"><span class="cls_006">File: </span><span class="cls_020">x.h:</span></div>
<div style="position:absolute;left:72.00px;top:733.68px" class="cls_020"><span class="cls_020">class x {</span></div>
<div style="position:absolute;left:72.00px;top:756.36px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:131.99px;top:756.36px" class="cls_020"><span class="cls_020">//assuming the original method "y" had public visibility</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">88</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:86904px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background103.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">int inline_y (int a);</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">int y (int a);</span></div>
<div style="position:absolute;left:203.98px;top:93.24px" class="cls_020"><span class="cls_020">// this should already have been here</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">---</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:138.48px" class="cls_020"><span class="cls_020">#include "x.inl"</span></div>
<div style="position:absolute;left:203.98px;top:138.48px" class="cls_020"><span class="cls_020">// this may already have been here also</span></div>
<div style="position:absolute;left:72.00px;top:164.76px" class="cls_006"><span class="cls_006">File: </span><span class="cls_020">x.inl</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:190.68px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:201.96px" class="cls_020"><span class="cls_020">int x::inline_y</span></div>
<div style="position:absolute;left:173.98px;top:201.96px" class="cls_020"><span class="cls_020">(int a)</span></div>
<div style="position:absolute;left:72.00px;top:213.36px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:203.98px;top:224.64px" class="cls_020"><span class="cls_020">// original implementation of y</span></div>
<div style="position:absolute;left:72.00px;top:235.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:262.20px" class="cls_006"><span class="cls_006">File: </span><span class="cls_020">x.c</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:288.12px" class="cls_020"><span class="cls_020">int x::y</span></div>
<div style="position:absolute;left:131.99px;top:288.12px" class="cls_020"><span class="cls_020">(int a)</span></div>
<div style="position:absolute;left:72.00px;top:299.40px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:310.80px" class="cls_020"><span class="cls_020">return inline_y(a);</span></div>
<div style="position:absolute;left:72.00px;top:322.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:348.36px" class="cls_006"><span class="cls_006">This gives us two versions of </span><span class="cls_020">y</span><span class="cls_006">; one that is inlined and named </span><span class="cls_020">inline_y</span><span class="cls_006"> and one that is outlined, named</span></div>
<div style="position:absolute;left:72.00px;top:361.08px" class="cls_006"><span class="cls_006">simply </span><span class="cls_020">y</span><span class="cls_006">. We also have a single shared definition of </span><span class="cls_020">x::y</span><span class="cls_006">'s body, the one in </span><span class="cls_020">inline_y</span><span class="cls_006">'s definition. This</span></div>
<div style="position:absolute;left:72.00px;top:373.44px" class="cls_006"><span class="cls_006">has the added advantage that the single method body also results in a single instance of any static variables</span></div>
<div style="position:absolute;left:72.00px;top:385.44px" class="cls_006"><span class="cls_006">within the method.</span></div>
<div style="position:absolute;left:72.00px;top:439.20px" class="cls_016"><span class="cls_016">Recursive Inlining</span></div>
<div style="position:absolute;left:72.00px;top:470.64px" class="cls_006"><span class="cls_006">As already indicated, directly recursive methods cannot be inlined. This can be very problematic for the</span></div>
<div style="position:absolute;left:72.00px;top:482.64px" class="cls_006"><span class="cls_006">performance of a number of relatively simple data structures that rely on recursion for insertion, deletion,</span></div>
<div style="position:absolute;left:72.00px;top:494.76px" class="cls_006"><span class="cls_006">and searching. These recursive methods typically are directly recursive and fairly small. Performance will</span></div>
<div style="position:absolute;left:72.00px;top:506.76px" class="cls_006"><span class="cls_006">suffer greatly if we are forced to execute such methods without the benefits of inlining or some other form</span></div>
<div style="position:absolute;left:72.00px;top:518.88px" class="cls_006"><span class="cls_006">of call collapsing. What follows are mechanisms for iterative call collapsing and recursive call unrolling.</span></div>
<div style="position:absolute;left:72.00px;top:544.92px" class="cls_006"><span class="cls_006">Some recursive methods are tail recursive. Tail recursion is evidenced by a method that recursively</span></div>
<div style="position:absolute;left:72.00px;top:557.04px" class="cls_006"><span class="cls_006">descends until its base case is reached. At that point some action is taken and the method terminates,</span></div>
<div style="position:absolute;left:72.00px;top:569.16px" class="cls_006"><span class="cls_006">possibly returning a value. The significant characteristic of the return sequence associated with tail</span></div>
<div style="position:absolute;left:72.00px;top:581.16px" class="cls_006"><span class="cls_006">recursion is that no action is taken after the base case is resolved, except possibly for the return of a value</span></div>
<div style="position:absolute;left:72.00px;top:593.28px" class="cls_006"><span class="cls_006">that is identified by the base case resolution. The typical binary tree search is a good example of a tail</span></div>
<div style="position:absolute;left:72.00px;top:605.28px" class="cls_006"><span class="cls_006">recursive method:</span></div>
<div style="position:absolute;left:72.00px;top:631.08px" class="cls_020"><span class="cls_020">binary_tree* binary_tree::find (int key) {</span></div>
<div style="position:absolute;left:96.00px;top:642.36px" class="cls_020"><span class="cls_020">if (key == id) {</span></div>
<div style="position:absolute;left:119.99px;top:653.64px" class="cls_020"><span class="cls_020">return this,</span></div>
<div style="position:absolute;left:96.00px;top:665.04px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:676.32px" class="cls_020"><span class="cls_020">else if (key > id) {</span></div>
<div style="position:absolute;left:119.99px;top:687.72px" class="cls_020"><span class="cls_020">if (right) return right.find(key);</span></div>
<div style="position:absolute;left:96.00px;top:699.00px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:710.28px" class="cls_020"><span class="cls_020">else {</span></div>
<div style="position:absolute;left:119.99px;top:721.68px" class="cls_020"><span class="cls_020">if (left)  return left.find(key);</span></div>
<div style="position:absolute;left:96.00px;top:732.96px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:755.64px" class="cls_020"><span class="cls_020">return 0;</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">89</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:87756px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background104.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:96.24px" class="cls_006"><span class="cls_006">As we can see, no action, other than returning a pointer to the indicated object, is taken after the base case</span></div>
<div style="position:absolute;left:72.00px;top:108.36px" class="cls_006"><span class="cls_006">is satisfied. Thus, the context of the recursively generated call stack is unimportant. In fact, if the compiler</span></div>
<div style="position:absolute;left:72.00px;top:120.84px" class="cls_006"><span class="cls_006">simply reserved a variable to hold </span><span class="cls_020">this</span><span class="cls_006">, the method could be executed without generating a new method</span></div>
<div style="position:absolute;left:72.00px;top:133.20px" class="cls_006"><span class="cls_006">context. Consider an alternative implementation:</span></div>
<div style="position:absolute;left:72.00px;top:158.88px" class="cls_020"><span class="cls_020">binary_tree* binary_tree::find (int key) {</span></div>
<div style="position:absolute;left:96.00px;top:170.28px" class="cls_020"><span class="cls_020">binary_tree *temp = this;</span></div>
<div style="position:absolute;left:96.00px;top:181.56px" class="cls_020"><span class="cls_020">while (temp) {</span></div>
<div style="position:absolute;left:119.99px;top:192.96px" class="cls_020"><span class="cls_020">if (key == temp->id) {</span></div>
<div style="position:absolute;left:143.99px;top:204.24px" class="cls_020"><span class="cls_020">return this,</span></div>
<div style="position:absolute;left:119.99px;top:215.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:119.99px;top:226.92px" class="cls_020"><span class="cls_020">else if (key > id) {</span></div>
<div style="position:absolute;left:143.99px;top:238.20px" class="cls_020"><span class="cls_020">temp = right;</span></div>
<div style="position:absolute;left:119.99px;top:249.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:119.99px;top:260.88px" class="cls_020"><span class="cls_020">else {</span></div>
<div style="position:absolute;left:143.99px;top:272.16px" class="cls_020"><span class="cls_020">temp = left;</span></div>
<div style="position:absolute;left:119.99px;top:283.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:294.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:317.52px" class="cls_020"><span class="cls_020">return 0;</span></div>
<div style="position:absolute;left:72.00px;top:328.80px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:354.60px" class="cls_006"><span class="cls_006">This alternate implementation demonstrates how a tail recursive method can be transformed into an</span></div>
<div style="position:absolute;left:72.00px;top:366.60px" class="cls_006"><span class="cls_006">iterative one. A good compiler will recognize tail recursion and convert it from a recursive method to an</span></div>
<div style="position:absolute;left:72.00px;top:378.72px" class="cls_006"><span class="cls_006">iterative one. This sort of compiler optimization makes any further attempts to improve the performance of</span></div>
<div style="position:absolute;left:72.00px;top:390.72px" class="cls_006"><span class="cls_006">the method with inlining not particularly interesting. As a general rule, particularly if performance is</span></div>
<div style="position:absolute;left:72.00px;top:402.84px" class="cls_006"><span class="cls_006">critical, care should be taken to use iterative solutions instead of recursive ones whenever such solutions</span></div>
<div style="position:absolute;left:72.00px;top:414.84px" class="cls_006"><span class="cls_006">are reasonably straightforward.</span></div>
<div style="position:absolute;left:72.00px;top:441.00px" class="cls_006"><span class="cls_006">When iterative solutions are not straightforward and performance is critical, there are some relatively</span></div>
<div style="position:absolute;left:72.00px;top:453.00px" class="cls_006"><span class="cls_006">straightforward mechanisms for unrolling recursive method. Suppose we are interested in improving the</span></div>
<div style="position:absolute;left:72.00px;top:465.60px" class="cls_006"><span class="cls_006">performance of a nontail recursive method, such as a method that generates an inorder listing of the </span><span class="cls_020">id</span></div>
<div style="position:absolute;left:72.00px;top:477.96px" class="cls_006"><span class="cls_006">fields in a binary tree:</span></div>
<div style="position:absolute;left:72.00px;top:503.64px" class="cls_020"><span class="cls_020">void binary_tree::key_out ()</span></div>
<div style="position:absolute;left:72.00px;top:514.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:526.32px" class="cls_020"><span class="cls_020">if (left)  left->key_out();</span></div>
<div style="position:absolute;left:96.00px;top:537.60px" class="cls_020"><span class="cls_020">cout &lt;&lt; id &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:549.00px" class="cls_020"><span class="cls_020">if (right) right->key_out();</span></div>
<div style="position:absolute;left:72.00px;top:560.28px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:586.44px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">key_out</span><span class="cls_006"> method could trivially be unrolled once with inlining:</span></div>
<div style="position:absolute;left:72.00px;top:612.36px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:623.76px" class="cls_020"><span class="cls_020">void binary_tree::UNROLLED_key_out ()</span></div>
<div style="position:absolute;left:72.00px;top:635.04px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:646.44px" class="cls_020"><span class="cls_020">if (left)  left->key_out();</span></div>
<div style="position:absolute;left:96.00px;top:657.72px" class="cls_020"><span class="cls_020">cout &lt;&lt; id &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:669.00px" class="cls_020"><span class="cls_020">if (right) right->key_out();</span></div>
<div style="position:absolute;left:72.00px;top:680.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:703.08px" class="cls_020"><span class="cls_020">void binary_tree::key_out ()</span></div>
<div style="position:absolute;left:72.00px;top:714.36px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:725.64px" class="cls_020"><span class="cls_020">if (left)  left->UNROLLED_key_out();</span></div>
<div style="position:absolute;left:96.00px;top:737.04px" class="cls_020"><span class="cls_020">cout &lt;&lt; id &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:748.32px" class="cls_020"><span class="cls_020">if (right) right->UNROLLED_key_out();</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">90</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:88608px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background105.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:96.72px" class="cls_006"><span class="cls_006">The programmer invokes the </span><span class="cls_020">key_out</span><span class="cls_006"> method, which in turn invokes the </span><span class="cls_020">UNROLLED_key_out</span><span class="cls_006"> method.</span></div>
<div style="position:absolute;left:72.00px;top:109.56px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">UNROLLED_key_out</span><span class="cls_006"> then indirectly recursively invokes the </span><span class="cls_020">key_out</span><span class="cls_006"> method. The unrolled version</span></div>
<div style="position:absolute;left:72.00px;top:121.80px" class="cls_006"><span class="cls_006">can be inlined within the standard version, which results in the standard version having a couple of</span></div>
<div style="position:absolute;left:72.00px;top:133.92px" class="cls_006"><span class="cls_006">versions of itself embedded within itself. The result is roughly twice as big as the original version, but also</span></div>
<div style="position:absolute;left:72.00px;top:146.04px" class="cls_006"><span class="cls_006">two to three times faster. This use of inlining results in an easier-to-follow version of something the</span></div>
<div style="position:absolute;left:72.00px;top:158.04px" class="cls_006"><span class="cls_006">programmer could have written him- or herself:</span></div>
<div style="position:absolute;left:72.00px;top:183.84px" class="cls_020"><span class="cls_020">void binary_tree::key_out ()</span></div>
<div style="position:absolute;left:72.00px;top:195.12px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:206.40px" class="cls_020"><span class="cls_020">if (left) {</span></div>
<div style="position:absolute;left:119.99px;top:217.80px" class="cls_020"><span class="cls_020">if (left->left)  left->left->key_out();</span></div>
<div style="position:absolute;left:119.99px;top:229.08px" class="cls_020"><span class="cls_020">cout &lt;&lt; left->id &lt;&lt; endl;</span></div>
<div style="position:absolute;left:119.99px;top:240.48px" class="cls_020"><span class="cls_020">if (left->right) left->right->key_out();</span></div>
<div style="position:absolute;left:96.00px;top:251.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:263.04px" class="cls_020"><span class="cls_020">cout &lt;&lt; id &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:274.44px" class="cls_020"><span class="cls_020">if (right) {</span></div>
<div style="position:absolute;left:119.99px;top:285.72px" class="cls_020"><span class="cls_020">if (right->left) right->left->key_out();</span></div>
<div style="position:absolute;left:119.99px;top:297.12px" class="cls_020"><span class="cls_020">cout &lt;&lt; right->id &lt;&lt; cout;</span></div>
<div style="position:absolute;left:119.99px;top:308.40px" class="cls_020"><span class="cls_020">if (right ->right) right->right->key_out();</span></div>
<div style="position:absolute;left:96.00px;top:319.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:331.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:356.76px" class="cls_006"><span class="cls_006">Single stage unrolling provides the biggest "bang for the buck," but additional unrolling can be employed</span></div>
<div style="position:absolute;left:72.00px;top:369.36px" class="cls_006"><span class="cls_006">if necessary. Following is a four-iteration version of the </span><span class="cls_020">key_out</span><span class="cls_006"> method:</span></div>
<div style="position:absolute;left:72.00px;top:395.28px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:406.56px" class="cls_020"><span class="cls_020">void binary_tree::UNROLLED3_key_out ()</span></div>
<div style="position:absolute;left:72.00px;top:417.96px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:429.24px" class="cls_020"><span class="cls_020">if (left) left->key_out();</span></div>
<div style="position:absolute;left:96.00px;top:440.64px" class="cls_020"><span class="cls_020">cout &lt;&lt; id &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:451.92px" class="cls_020"><span class="cls_020">if (right) right->key_out();</span></div>
<div style="position:absolute;left:72.00px;top:463.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:485.88px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:497.28px" class="cls_020"><span class="cls_020">void binary_tree::UNROLLED2_key_out ()</span></div>
<div style="position:absolute;left:72.00px;top:508.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:519.84px" class="cls_020"><span class="cls_020">if (left)  left->UNROLLED3_key_out();</span></div>
<div style="position:absolute;left:96.00px;top:531.24px" class="cls_020"><span class="cls_020">cout &lt;&lt; id &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:542.52px" class="cls_020"><span class="cls_020">if (right) right->UNROLLED3_key_out();</span></div>
<div style="position:absolute;left:72.00px;top:553.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:576.48px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:587.88px" class="cls_020"><span class="cls_020">void binary_tree::UNROLLED1_key_out ()</span></div>
<div style="position:absolute;left:72.00px;top:599.16px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:610.56px" class="cls_020"><span class="cls_020">if (left)  left->UNROLLRD2_key_out();</span></div>
<div style="position:absolute;left:96.00px;top:621.84px" class="cls_020"><span class="cls_020">cout &lt;&lt; id &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:633.12px" class="cls_020"><span class="cls_020">if (right) right->UNROLLED2_key_out();</span></div>
<div style="position:absolute;left:72.00px;top:644.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:667.20px" class="cls_020"><span class="cls_020">void binary_tree::key_out ()</span></div>
<div style="position:absolute;left:72.00px;top:678.48px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:689.76px" class="cls_020"><span class="cls_020">if (left)  left->UNROLLED1_key_out();</span></div>
<div style="position:absolute;left:96.00px;top:701.16px" class="cls_020"><span class="cls_020">cout &lt;&lt; id &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:712.44px" class="cls_020"><span class="cls_020">if (right) right->UNROLLED1_key_out();</span></div>
<div style="position:absolute;left:72.00px;top:723.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">91</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:89460px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background106.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">This level of unrolling can provide a significant performance improvement, but four versions of what are</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">essentially the same method makes maintenance of the unrolled recursion error-prone. Use of old style C</span></div>
<div style="position:absolute;left:72.00px;top:95.52px" class="cls_020"><span class="cls_020">#define</span><span class="cls_006"> macro expansion can unify the unrolled methods, but it is ugly, and it requires that significant</span></div>
<div style="position:absolute;left:72.00px;top:108.36px" class="cls_006"><span class="cls_006">care be taken for maintenance. Following is the macro version of the </span><span class="cls_020">key_out</span><span class="cls_006"> method.</span></div>
<div style="position:absolute;left:72.00px;top:134.28px" class="cls_020"><span class="cls_020">#define</span></div>
<div style="position:absolute;left:131.99px;top:134.28px" class="cls_020"><span class="cls_020">KEY_OUT_MACRO(inline_arg, my_label, call_label)</span></div>
<div style="position:absolute;left:461.93px;top:134.28px" class="cls_020"><span class="cls_020">\</span></div>
<div style="position:absolute;left:461.93px;top:145.68px" class="cls_020"><span class="cls_020">\</span></div>
<div style="position:absolute;left:72.00px;top:156.96px" class="cls_020"><span class="cls_020">inline_arg</span></div>
<div style="position:absolute;left:461.93px;top:156.96px" class="cls_020"><span class="cls_020">\</span></div>
<div style="position:absolute;left:72.00px;top:168.36px" class="cls_020"><span class="cls_020">void binary_tree::UNROLLED##my_label##_key_out ()</span></div>
<div style="position:absolute;left:461.93px;top:168.36px" class="cls_020"><span class="cls_020">\</span></div>
<div style="position:absolute;left:72.00px;top:179.64px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:461.93px;top:179.64px" class="cls_020"><span class="cls_020">\</span></div>
<div style="position:absolute;left:96.00px;top:190.92px" class="cls_020"><span class="cls_020">if (left) left->UNROLLED##call_label##_key_out();</span></div>
<div style="position:absolute;left:461.93px;top:190.92px" class="cls_020"><span class="cls_020">\</span></div>
<div style="position:absolute;left:96.00px;top:202.32px" class="cls_020"><span class="cls_020">cout &lt;&lt; id &lt;&lt; endl;</span></div>
<div style="position:absolute;left:461.93px;top:202.32px" class="cls_020"><span class="cls_020">\</span></div>
<div style="position:absolute;left:96.00px;top:213.60px" class="cls_020"><span class="cls_020">if (right) right->UNROLLED##call_label##_key_out();</span></div>
<div style="position:absolute;left:461.93px;top:213.60px" class="cls_020"><span class="cls_020">\</span></div>
<div style="position:absolute;left:72.00px;top:225.00px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:247.56px" class="cls_020"><span class="cls_020">KEY_OUT_MACRO(inline, 3, 0)</span></div>
<div style="position:absolute;left:72.00px;top:258.96px" class="cls_020"><span class="cls_020">KEY_OUT_MACRO(inline, 2, 3)</span></div>
<div style="position:absolute;left:72.00px;top:270.24px" class="cls_020"><span class="cls_020">KEY_OUT_MACRO(inline, 1, 2)</span></div>
<div style="position:absolute;left:72.00px;top:281.64px" class="cls_020"><span class="cls_020">KEY_OUT_MACRO(\\t</span></div>
<div style="position:absolute;left:191.98px;top:281.64px" class="cls_020"><span class="cls_020">, 0, 1)</span></div>
<div style="position:absolute;left:72.00px;top:304.20px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:315.60px" class="cls_020"><span class="cls_020">void x::key_out()</span></div>
<div style="position:absolute;left:72.00px;top:326.88px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:338.28px" class="cls_020"><span class="cls_020">UNROLLED_key_out();</span></div>
<div style="position:absolute;left:72.00px;top:349.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:375.72px" class="cls_006"><span class="cls_006">Remember: An entry must still be made for </span><span class="cls_020">key_out()</span><span class="cls_006"> in the </span><span class="cls_020">binary_tree</span><span class="cls_006"> header file.</span></div>
<div style="position:absolute;left:72.00px;top:402.00px" class="cls_006"><span class="cls_006">This macro mechanism allows additional levels of unrolling without much additional effort. Though you</span></div>
<div style="position:absolute;left:72.00px;top:414.12px" class="cls_006"><span class="cls_006">should remember that although the code now looks much smaller in terms of the amount of space it</span></div>
<div style="position:absolute;left:72.00px;top:426.24px" class="cls_006"><span class="cls_006">absorbs in the source listing, after the C++ preprocessor expands the macros, and the compiler completes</span></div>
<div style="position:absolute;left:72.00px;top:438.24px" class="cls_006"><span class="cls_006">its inlining, there will be just as much code expansion as was true in the earlier case. We have a hard time</span></div>
<div style="position:absolute;left:72.00px;top:450.36px" class="cls_006"><span class="cls_006">strongly recommending a mechanism that is as fragile as this sort of macro expansion is, but its benefits</span></div>
<div style="position:absolute;left:72.00px;top:462.36px" class="cls_006"><span class="cls_006">(only one copy of the recursive method) generally outweigh its drawbacks when such extreme measures</span></div>
<div style="position:absolute;left:72.00px;top:474.48px" class="cls_006"><span class="cls_006">are necessary.</span></div>
<div style="position:absolute;left:72.00px;top:500.52px" class="cls_006"><span class="cls_006">The additional performance improvement that four levels of unrolling provide over just two levels of</span></div>
<div style="position:absolute;left:72.00px;top:512.64px" class="cls_006"><span class="cls_006">unrolling is just slightly less than those gained from the first level of unrolling. Eight levels of unrolling</span></div>
<div style="position:absolute;left:72.00px;top:524.76px" class="cls_006"><span class="cls_006">will provide an additional two to three times the performance that four provided. However, it should be</span></div>
<div style="position:absolute;left:72.00px;top:536.76px" class="cls_006"><span class="cls_006">remembered that extreme levels of unrolling can also result in extreme code expansion. The four-copy</span></div>
<div style="position:absolute;left:72.00px;top:548.88px" class="cls_006"><span class="cls_006">version is four times larger than the original. An eight-copy version is 64 times larger. This is a significant</span></div>
<div style="position:absolute;left:72.00px;top:560.88px" class="cls_006"><span class="cls_006">expansion, but in some cases the performance advantages may make even this sort of extreme code</span></div>
<div style="position:absolute;left:72.00px;top:573.00px" class="cls_006"><span class="cls_006">expansion worthwhile.</span></div>
<div style="position:absolute;left:72.00px;top:626.76px" class="cls_016"><span class="cls_016">Inlining with Static Local Variables</span></div>
<div style="position:absolute;left:72.00px;top:658.08px" class="cls_006"><span class="cls_006">Local static variables can be very problematic for compiler-based inline resolution. Some compilers will</span></div>
<div style="position:absolute;left:72.00px;top:670.20px" class="cls_006"><span class="cls_006">refuse to inline any method that contains a static variable declaration. Some compilers will allow statics to</span></div>
<div style="position:absolute;left:72.00px;top:682.32px" class="cls_006"><span class="cls_006">be inlined, but then incorrectly create multiple instances of the inlined variable at run-time. There probably</span></div>
<div style="position:absolute;left:72.00px;top:694.32px" class="cls_006"><span class="cls_006">are, no doubt, even some compilers that provide the worst of both worlds: they do not inline methods with</span></div>
<div style="position:absolute;left:72.00px;top:706.44px" class="cls_006"><span class="cls_006">static variables, but they do create an independent instance of the method within each separately compiled</span></div>
<div style="position:absolute;left:72.00px;top:718.56px" class="cls_006"><span class="cls_006">module. Certainly some of this difficulty is the result of a change in the way C++ handles inlined methods.</span></div>
<div style="position:absolute;left:72.00px;top:730.56px" class="cls_006"><span class="cls_006">The current language specification requires external linkage of inlined methods and will therefore force a</span></div>
<div style="position:absolute;left:72.00px;top:742.68px" class="cls_006"><span class="cls_006">single instance of any local static variables. Unfortunately, not all compilers are up to specification in this</span></div>
<div style="position:absolute;left:72.00px;top:754.68px" class="cls_006"><span class="cls_006">regard. Check your compiler. A compiler that has not yet been updated will have the following problem.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">92</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:90312px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background107.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">The problem with inlining methods that contain static variables is resolving the uniqueness of the static</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">variable and ensuring that it gets initialized. Inlined methods are defined in header files. Inlining such a</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">method requires that all modules that use the header file share a single instance of the static variable.</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">Logically, static local variables are really just global variables with restricted scope. This means that the</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">linker should be intelligent enough to detect the usage of any such static variables, create the variables,</span></div>
<div style="position:absolute;left:72.00px;top:131.28px" class="cls_006"><span class="cls_006">reserve space within the global data space, create initialization code for the variable (or otherwise ensure</span></div>
<div style="position:absolute;left:72.00px;top:143.40px" class="cls_006"><span class="cls_006">its initialization), and link all inlined references to the static variable to the newly created single instance of</span></div>
<div style="position:absolute;left:72.00px;top:155.40px" class="cls_006"><span class="cls_006">it within the global data area. Although conceptually this is not overly difficult, within the realm of</span></div>
<div style="position:absolute;left:72.00px;top:167.52px" class="cls_006"><span class="cls_006">separately compiled modules, resolving the location of the shared static has eluded some compiler writers.</span></div>
<div style="position:absolute;left:72.00px;top:179.64px" class="cls_006"><span class="cls_006">This will certainly be a short-term problem, but in the interim you need to be aware of the difficulties</span></div>
<div style="position:absolute;left:72.00px;top:191.64px" class="cls_006"><span class="cls_006">associated with the use of static variables encapsulated within a method.</span></div>
<div style="position:absolute;left:72.00px;top:217.68px" class="cls_006"><span class="cls_006">It is relatively simple to determine whether your compiler can handle inlining of statics properly.</span></div>
<div style="position:absolute;left:72.00px;top:229.80px" class="cls_006"><span class="cls_006">Following is a small program that does just that.</span></div>
<div style="position:absolute;left:72.00px;top:254.88px" class="cls_020"><span class="cls_020">z.h:</span></div>
<div style="position:absolute;left:72.00px;top:280.80px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:292.20px" class="cls_020"><span class="cls_020">int test ()</span></div>
<div style="position:absolute;left:72.00px;top:303.48px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:314.88px" class="cls_020"><span class="cls_020">static int i = 0;</span></div>
<div style="position:absolute;left:96.00px;top:337.44px" class="cls_020"><span class="cls_020">return ++i;</span></div>
<div style="position:absolute;left:72.00px;top:348.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:373.44px" class="cls_020"><span class="cls_020">y.cpp:</span></div>
<div style="position:absolute;left:72.00px;top:399.48px" class="cls_020"><span class="cls_020">#include "z.h"</span></div>
<div style="position:absolute;left:72.00px;top:410.76px" class="cls_020"><span class="cls_020">void test_a ()</span></div>
<div style="position:absolute;left:72.00px;top:422.16px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:433.44px" class="cls_020"><span class="cls_020">int i = test();</span></div>
<div style="position:absolute;left:96.00px;top:444.84px" class="cls_020"><span class="cls_020">cout &lt;&lt; i;</span></div>
<div style="position:absolute;left:72.00px;top:456.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:480.72px" class="cls_020"><span class="cls_020">x.cpp:</span></div>
<div style="position:absolute;left:72.00px;top:506.76px" class="cls_020"><span class="cls_020">#include "z.h"</span></div>
<div style="position:absolute;left:72.00px;top:518.04px" class="cls_020"><span class="cls_020">void test_b ()</span></div>
<div style="position:absolute;left:72.00px;top:529.44px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:540.72px" class="cls_020"><span class="cls_020">int i = test();</span></div>
<div style="position:absolute;left:96.00px;top:552.12px" class="cls_020"><span class="cls_020">cout &lt;&lt; i;</span></div>
<div style="position:absolute;left:72.00px;top:563.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:588.12px" class="cls_020"><span class="cls_020">main.cpp:</span></div>
<div style="position:absolute;left:72.00px;top:614.04px" class="cls_020"><span class="cls_020">int main() {</span></div>
<div style="position:absolute;left:96.00px;top:625.44px" class="cls_020"><span class="cls_020">test_a();</span></div>
<div style="position:absolute;left:96.00px;top:636.72px" class="cls_020"><span class="cls_020">test_b();</span></div>
<div style="position:absolute;left:96.00px;top:648.00px" class="cls_020"><span class="cls_020">cout &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:659.40px" class="cls_020"><span class="cls_020">return 0;</span></div>
<div style="position:absolute;left:72.00px;top:670.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:696.96px" class="cls_006"><span class="cls_006">If your compiler creates the proper code, then separate compilation of the three</span><span class="cls_020">.cpp</span><span class="cls_006"> files subsequent</span></div>
<div style="position:absolute;left:72.00px;top:709.68px" class="cls_006"><span class="cls_006">linking should result in an executable that outputs </span><span class="cls_020">12</span><span class="cls_006">. If you get </span><span class="cls_020">11</span><span class="cls_006"> your compiler has problems with</span></div>
<div style="position:absolute;left:72.00px;top:722.04px" class="cls_006"><span class="cls_006">inlining methods with static variables. You also need to pay attention to compiler warnings that indicate</span></div>
<div style="position:absolute;left:72.00px;top:734.52px" class="cls_006"><span class="cls_006">that the </span><span class="cls_020">test</span><span class="cls_006"> method was not inlined at all.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">93</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:91164px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background108.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">If performance dictates that a method containing a static be inlined, and if your compiler cannot properly</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">resolve this structure, there is an easy work-around. The same net behavior can be achieved by creating a</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">static class attribute (static member variable). This creates a single instance of a variable with limited scope.</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">Unfortunately this mechanism expands the visibility of the static significantly, but with the proper level of</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">documentation this should not generally be a problem.</span></div>
<div style="position:absolute;left:72.00px;top:173.04px" class="cls_016"><span class="cls_016">Architectural Caveat: Multiple Register Sets</span></div>
<div style="position:absolute;left:72.00px;top:204.36px" class="cls_006"><span class="cls_006">Not all architectures have the same call/return performance. Some machines, like the SPARC architecture,</span></div>
<div style="position:absolute;left:72.00px;top:216.36px" class="cls_006"><span class="cls_006">exhibit almost no call/return performance penalties within a limited range of call depth. These architectures</span></div>
<div style="position:absolute;left:72.00px;top:228.48px" class="cls_006"><span class="cls_006">have the ability to do very fast allocations of new register frames on calls. This obviates the need to store</span></div>
<div style="position:absolute;left:72.00px;top:240.60px" class="cls_006"><span class="cls_006">old register contents on calls. Methods return by simply making the previously allocated register set the</span></div>
<div style="position:absolute;left:72.00px;top:252.60px" class="cls_006"><span class="cls_006">current register set, thus making register restoration on returns unnecessary. These architectures can pass</span></div>
<div style="position:absolute;left:72.00px;top:264.72px" class="cls_006"><span class="cls_006">arguments in the registers (a group of registers are shared by caller and callee), thus making it largely</span></div>
<div style="position:absolute;left:72.00px;top:276.84px" class="cls_006"><span class="cls_006">unnecessary to push variables on the system's memory stack prior to a call.</span></div>
<div style="position:absolute;left:72.00px;top:302.88px" class="cls_006"><span class="cls_006">The ability to allocate one new register set per call also significantly decreases pressure on the register</span></div>
<div style="position:absolute;left:72.00px;top:314.88px" class="cls_006"><span class="cls_006">allocation mechanism in the compiler. The abundance of registers makes it easy to allocate frequently used</span></div>
<div style="position:absolute;left:72.00px;top:327.00px" class="cls_006"><span class="cls_006">atomic variables to registers, where they can be accessed with the lowest cost, both in terms of code size</span></div>
<div style="position:absolute;left:72.00px;top:339.12px" class="cls_006"><span class="cls_006">and execution efficiency.</span></div>
<div style="position:absolute;left:72.00px;top:365.16px" class="cls_006"><span class="cls_006">With register storage and retrieval no longer an issue, and variable mapping costs across the call lessened,</span></div>
<div style="position:absolute;left:72.00px;top:377.28px" class="cls_006"><span class="cls_006">only the effect of a call on the pipeline, and the inability to optimize across the call boundary, provide any</span></div>
<div style="position:absolute;left:72.00px;top:389.28px" class="cls_006"><span class="cls_006">serious hope for a significant benefit from inlining. When the improved cache characteristics of not</span></div>
<div style="position:absolute;left:72.00px;top:401.40px" class="cls_006"><span class="cls_006">inlining are taken into effect, along with the reduction of pressure on the register allocator, inlining's</span></div>
<div style="position:absolute;left:72.00px;top:413.40px" class="cls_006"><span class="cls_006">performance effectiveness on methods that are not trivials becomes increasingly questionable.</span></div>
<div style="position:absolute;left:72.00px;top:439.56px" class="cls_006"><span class="cls_006">Unfortunately, the effectiveness of these multiple register set architectures is significantly diminished as</span></div>
<div style="position:absolute;left:72.00px;top:451.56px" class="cls_006"><span class="cls_006">call depth increases. If a program's call depth exceeds the number of physical register sets in the processor,</span></div>
<div style="position:absolute;left:72.00px;top:463.68px" class="cls_006"><span class="cls_006">then these architectures start to experience extreme call costs, typically much worse than those associated</span></div>
<div style="position:absolute;left:72.00px;top:475.80px" class="cls_006"><span class="cls_006">with a typical single register set architecture. This is because register set overflow requires that entire</span></div>
<div style="position:absolute;left:72.00px;top:487.80px" class="cls_006"><span class="cls_006">register sets be stored to memory and eventually restored from memory. This means that while the direct</span></div>
<div style="position:absolute;left:72.00px;top:499.92px" class="cls_006"><span class="cls_006">effects of inlining are negligible, the indirect effect of inlining on call depth could provide a significant</span></div>
<div style="position:absolute;left:72.00px;top:511.92px" class="cls_006"><span class="cls_006">performance boost.</span></div>
<div style="position:absolute;left:72.00px;top:538.08px" class="cls_006"><span class="cls_006">This provides the inliner with a dilemma: inlining on nontrivial methods is, in the general case, not nearly</span></div>
<div style="position:absolute;left:72.00px;top:550.08px" class="cls_006"><span class="cls_006">as effective. Even in what seem to be obvious wins for inlining, these multiple register sets architectures</span></div>
<div style="position:absolute;left:72.00px;top:562.20px" class="cls_006"><span class="cls_006">can make inlining countereffective. On the other hand, inlining does decrease overall call depth and thus</span></div>
<div style="position:absolute;left:72.00px;top:574.32px" class="cls_006"><span class="cls_006">decreases the likelihood that register set overflow will occur. There are no good definitive answers. In the</span></div>
<div style="position:absolute;left:72.00px;top:586.32px" class="cls_006"><span class="cls_006">general case inlining on such machines will not hurt performance, but it may not do much to improve it</span></div>
<div style="position:absolute;left:72.00px;top:598.44px" class="cls_006"><span class="cls_006">either. Our suggestion is that without run-time metric evidence to directly support an inlining decision,</span></div>
<div style="position:absolute;left:72.00px;top:610.44px" class="cls_006"><span class="cls_006">inlining of nontrivial methods should be avoided.</span></div>
<div style="position:absolute;left:72.00px;top:664.32px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:695.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Inlining can improve performance. The goal is to find a program's fast path and inline it, though</span></div>
<div style="position:absolute;left:108.00px;top:707.88px" class="cls_006"><span class="cls_006">inlining this path may not be trivial.</span></div>
<div style="position:absolute;left:90.00px;top:720.24px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Conditional inlining prevents inlining from occuring. This decreases compile-time and simplifies</span></div>
<div style="position:absolute;left:108.00px;top:732.36px" class="cls_006"><span class="cls_006">debug during the earlier phases of development.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">94</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:92016px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background109.jpg" width=595 height=842></div>
<div style="position:absolute;left:90.00px;top:71.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Selective inlining is a technique that inlines methods only in some places. It can offset some of the</span></div>
<div style="position:absolute;left:108.00px;top:83.28px" class="cls_006"><span class="cls_006">code size explosion potential of inlining a method by inlining method calls only on performance-</span></div>
<div style="position:absolute;left:108.00px;top:95.28px" class="cls_006"><span class="cls_006">critical paths.</span></div>
<div style="position:absolute;left:90.00px;top:107.64px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Recursive inlining is an ugly but effective technique for improving the performance of recursive</span></div>
<div style="position:absolute;left:108.00px;top:119.76px" class="cls_006"><span class="cls_006">methods.</span></div>
<div style="position:absolute;left:90.00px;top:132.00px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Care needs to be taken with local static variables.</span></div>
<div style="position:absolute;left:90.00px;top:144.36px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Inlining is aimed at call elimination. Be sure of the real cost of calls on your system before using</span></div>
<div style="position:absolute;left:108.00px;top:156.48px" class="cls_006"><span class="cls_006">inlining.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">95</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:92868px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background110.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 11. Standard Template Library</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">The Standard Template Library (STL) is a powerful combination of containers and generic algorithms.</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">From a performance perspective, a few questions immediately come to mind:</span></div>
<div style="position:absolute;left:90.00px;top:156.24px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The STL comes bundled with performance guarantees of the asymptotic complexity of the various</span></div>
<div style="position:absolute;left:108.00px;top:168.36px" class="cls_006"><span class="cls_006">containers and algorithms. What does it really mean?</span></div>
<div style="position:absolute;left:90.00px;top:180.72px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The STL consists of many containers. Faced with a given computational task, what containers</span></div>
<div style="position:absolute;left:108.00px;top:192.72px" class="cls_006"><span class="cls_006">should I use? Are some better than others for a given scenario?</span></div>
<div style="position:absolute;left:90.00px;top:205.08px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   How good is the performance of the STL? Can I do better by rolling my own home-grown</span></div>
<div style="position:absolute;left:108.00px;top:217.20px" class="cls_006"><span class="cls_006">containers and algorithms?</span></div>
<div style="position:absolute;left:72.00px;top:243.24px" class="cls_006"><span class="cls_006">We will address these and other related issues in this chapter.</span></div>
<div style="position:absolute;left:72.00px;top:269.28px" class="cls_006"><span class="cls_006">Even though we often refer to "the STL performance," it should be noted that the STL has various distinct</span></div>
<div style="position:absolute;left:72.00px;top:281.40px" class="cls_006"><span class="cls_006">implementations with varying degrees of performance. The measurements provided in this chapter are a</span></div>
<div style="position:absolute;left:72.00px;top:293.52px" class="cls_006"><span class="cls_006">reflection of one popular implementation. The observations we make, however, should apply to STL</span></div>
<div style="position:absolute;left:72.00px;top:305.52px" class="cls_006"><span class="cls_006">implementations in general.</span></div>
<div style="position:absolute;left:72.00px;top:359.28px" class="cls_016"><span class="cls_016">Asymptotic Complexity</span></div>
<div style="position:absolute;left:72.00px;top:390.60px" class="cls_006"><span class="cls_006">The asymptotic complexity of an algorithm is an approximation of algorithm performance. It is a mapping</span></div>
<div style="position:absolute;left:72.00px;top:402.72px" class="cls_006"><span class="cls_006">from the set of algorithms to a special set of performance levels. If you sum up the elements of a vector of</span></div>
<div style="position:absolute;left:72.00px;top:414.84px" class="cls_006"><span class="cls_006">N integers, you have to inspect each integer once, and only once, so the complexity is of the order of N,</span></div>
<div style="position:absolute;left:72.00px;top:426.84px" class="cls_006"><span class="cls_006">and we call it O(N). Suppose, on the other hand, that you are building a vector of N elements and for some</span></div>
<div style="position:absolute;left:72.00px;top:438.96px" class="cls_006"><span class="cls_006">reason you chose to insert them in the front of the vector. Every element insertion at the front of a vector</span></div>
<div style="position:absolute;left:72.00px;top:451.08px" class="cls_006"><span class="cls_006">forces the shift of all existing elements by 1. This results in (1+2+3+...+N) overall shifts of vector elements,</span></div>
<div style="position:absolute;left:72.00px;top:463.08px" class="cls_006"><span class="cls_006">which is (N/2)(N+1) shifts. Even though we have (N*N/2)+(N/2) shifts we still say the complexity of this</span></div>
<div style="position:absolute;left:72.00px;top:475.20px" class="cls_006"><span class="cls_006">algorithm is O(N*N). This is because the set of asymptotic performance levels ignores constant multipliers</span></div>
<div style="position:absolute;left:72.00px;top:487.20px" class="cls_006"><span class="cls_006">and low-order factors. Consequently, the complexity of N*N and 7N*N is the same: it is O(N*N). For this</span></div>
<div style="position:absolute;left:72.00px;top:499.32px" class="cls_006"><span class="cls_006">reason, asymptotic complexity is a crude approximation. Although perfect for applied mathematicians</span></div>
<div style="position:absolute;left:72.00px;top:511.44px" class="cls_006"><span class="cls_006">researching the complexity of algorithms, it is not enough for us programmers. We still care about the</span></div>
<div style="position:absolute;left:72.00px;top:523.44px" class="cls_006"><span class="cls_006">constant multipliers. For us, a 2N algorithm is not the same as a 4N algorithm. The former is 100% faster</span></div>
<div style="position:absolute;left:72.00px;top:535.56px" class="cls_006"><span class="cls_006">than the latter.</span></div>
<div style="position:absolute;left:72.00px;top:561.60px" class="cls_006"><span class="cls_006">The STL guarantees of the asymptotic complexity of its algorithms is a good start. It tells us that the</span></div>
<div style="position:absolute;left:72.00px;top:573.72px" class="cls_006"><span class="cls_006">algorithms used are the best of their breed [</span><span class="cls_036">MS96</span><span class="cls_006">]. However, we still must explore the constant multipliers</span></div>
<div style="position:absolute;left:72.00px;top:585.72px" class="cls_006"><span class="cls_006">and low-order factors that are ignored by the mathematicians. We will not cover all operations on all</span></div>
<div style="position:absolute;left:72.00px;top:597.84px" class="cls_006"><span class="cls_006">containers, but instead will discuss some frequent operations on popular containers, starting with insertion.</span></div>
<div style="position:absolute;left:72.00px;top:651.60px" class="cls_016"><span class="cls_016">Insertion</span></div>
<div style="position:absolute;left:72.00px;top:682.92px" class="cls_006"><span class="cls_006">If your performance-critical path contains code to insert a large number of elements into a container, what</span></div>
<div style="position:absolute;left:72.00px;top:695.04px" class="cls_006"><span class="cls_006">container should you use? To gain some insight into that question we will give some containers a workout</span></div>
<div style="position:absolute;left:72.00px;top:707.16px" class="cls_006"><span class="cls_006">and discuss the results. The insertion exercise will insert a million random elements into an array, vector,</span></div>
<div style="position:absolute;left:72.00px;top:719.16px" class="cls_006"><span class="cls_006">list, and multiset. Each insertion test takes three parameters:</span></div>
<div style="position:absolute;left:90.00px;top:745.44px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A pointer to the target container under test</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">96</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:93720px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background111.jpg" width=595 height=842></div>
<div style="position:absolute;left:90.00px;top:71.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A pointer to a data array of elements to be inserted</span></div>
<div style="position:absolute;left:90.00px;top:83.52px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The size of the data array</span></div>
<div style="position:absolute;left:72.00px;top:109.56px" class="cls_006"><span class="cls_006">The insertion tests for the various containers are given here:</span></div>
<div style="position:absolute;left:72.00px;top:135.24px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:146.64px" class="cls_020"><span class="cls_020">void arrayInsert (T *a, T *collection, int size)</span></div>
<div style="position:absolute;left:72.00px;top:157.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:169.32px" class="cls_020"><span class="cls_020">for (int k =0; k &lt; size; k++) {</span></div>
<div style="position:absolute;left:119.99px;top:180.60px" class="cls_020"><span class="cls_020">a[k] = collection[k];</span></div>
<div style="position:absolute;left:96.00px;top:191.88px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:203.28px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:225.96px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:237.24px" class="cls_020"><span class="cls_020">void vectorInsert (vector&lt;T> *v, T *collection, int size)</span></div>
<div style="position:absolute;left:72.00px;top:248.52px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:259.92px" class="cls_020"><span class="cls_020">for (int k =0; k &lt; size; k++) {</span></div>
<div style="position:absolute;left:119.99px;top:271.20px" class="cls_020"><span class="cls_020">v->push_back(collection[k]);</span></div>
<div style="position:absolute;left:96.00px;top:282.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:293.88px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:316.56px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:327.84px" class="cls_020"><span class="cls_020">void listInsert (list&lt;T> *l, T *collection, int size)</span></div>
<div style="position:absolute;left:72.00px;top:339.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:350.52px" class="cls_020"><span class="cls_020">for (int k =0; k &lt; size; k++) {</span></div>
<div style="position:absolute;left:119.99px;top:361.80px" class="cls_020"><span class="cls_020">l->push_back(collection[k]);</span></div>
<div style="position:absolute;left:96.00px;top:373.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:384.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:407.16px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:418.44px" class="cls_020"><span class="cls_020">void multisetInsert (multiset&lt;T> *s, T *collection, int size)</span></div>
<div style="position:absolute;left:72.00px;top:429.84px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:441.12px" class="cls_020"><span class="cls_020">for (int k =0; k &lt; size; k++) {</span></div>
<div style="position:absolute;left:119.99px;top:452.52px" class="cls_020"><span class="cls_020">s->insert(collection[k]);</span></div>
<div style="position:absolute;left:96.00px;top:463.80px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:475.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:501.36px" class="cls_006"><span class="cls_006">The various insertion tests are given an array (</span><span class="cls_020">collection</span><span class="cls_006">) of random elements as input. Those random</span></div>
<div style="position:absolute;left:72.00px;top:513.60px" class="cls_006"><span class="cls_006">elements are then inserted into the container under test. In the case of integer data, we generated it using</span></div>
<div style="position:absolute;left:72.00px;top:526.20px" class="cls_006"><span class="cls_006">the STL's </span><span class="cls_020">generate()</span><span class="cls_006"> function:</span></div>
<div style="position:absolute;left:72.00px;top:552.12px" class="cls_020"><span class="cls_020">int *genIntData(int size)</span></div>
<div style="position:absolute;left:72.00px;top:563.52px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:574.80px" class="cls_020"><span class="cls_020">int *data = new int[size];</span></div>
<div style="position:absolute;left:96.00px;top:597.48px" class="cls_020"><span class="cls_020">// generate randon integers and place them in array data</span></div>
<div style="position:absolute;left:96.00px;top:608.76px" class="cls_020"><span class="cls_020">generate(&data[0], &data[size], rand);</span></div>
<div style="position:absolute;left:96.00px;top:631.44px" class="cls_020"><span class="cls_020">return data;</span></div>
<div style="position:absolute;left:72.00px;top:642.72px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:668.52px" class="cls_006"><span class="cls_006">We used these tests to insert a million random integers into each container. The execution speed in</span></div>
<div style="position:absolute;left:72.00px;top:680.52px" class="cls_006"><span class="cls_006">milliseconds is shown in </span><span class="cls_036">Figure 11.1</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:219.48px;top:706.68px" class="cls_021"><span class="cls_021">Figure 11.1. Speed of insertion.</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:94572px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background112.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:301.68px" class="cls_006"><span class="cls_006">In this scenario, the array beat the other containers by a wide margin. The array had one significant</span></div>
<div style="position:absolute;left:72.00px;top:313.80px" class="cls_006"><span class="cls_006">advantage over the other containers: It was large enough, from the start, to contain all million data</span></div>
<div style="position:absolute;left:72.00px;top:325.80px" class="cls_006"><span class="cls_006">elements. The vector, on the other hand, did not have an a priori knowledge of how big the collection is</span></div>
<div style="position:absolute;left:72.00px;top:337.92px" class="cls_006"><span class="cls_006">going to be. Neither did the list and multiset containers. To make matters worse, the list and multiset had</span></div>
<div style="position:absolute;left:72.00px;top:349.92px" class="cls_006"><span class="cls_006">other overhead to contend with. For each data value, the list needed to allocate a list element to hold the</span></div>
<div style="position:absolute;left:72.00px;top:362.04px" class="cls_006"><span class="cls_006">data in addition to setting pointers to the list elements before and after. The multiset container maintains its</span></div>
<div style="position:absolute;left:72.00px;top:374.16px" class="cls_006"><span class="cls_006">collection in sorted order at all times. For that reason, it finished last in this particular test. We must point</span></div>
<div style="position:absolute;left:72.00px;top:386.16px" class="cls_006"><span class="cls_006">out that this particular test we ran does not mean that an array is generally better than the other containers.</span></div>
<div style="position:absolute;left:72.00px;top:398.28px" class="cls_006"><span class="cls_006">Each container has particular scenarios in which it will outperform the others. If one container were better</span></div>
<div style="position:absolute;left:72.00px;top:410.28px" class="cls_006"><span class="cls_006">than all others in all scenarios, the others would not exist. For example, if you need a collection whose</span></div>
<div style="position:absolute;left:72.00px;top:422.40px" class="cls_006"><span class="cls_006">lookup speed is most important, a multiset container would beat the array, vector, and list containers.</span></div>
<div style="position:absolute;left:72.00px;top:448.44px" class="cls_006"><span class="cls_006">The array and vector containers are both sequence containers that occupy a contiguous block of memory.</span></div>
<div style="position:absolute;left:72.00px;top:460.56px" class="cls_006"><span class="cls_006">The vector container is more helpful when you cannot determine in advance how big the collection would</span></div>
<div style="position:absolute;left:72.00px;top:472.68px" class="cls_006"><span class="cls_006">be. The vector would grow dynamically and free the programmer from collection-size considerations. To</span></div>
<div style="position:absolute;left:72.00px;top:484.68px" class="cls_006"><span class="cls_006">better understand the performance difference between a vector and an array, we must first distinguish</span></div>
<div style="position:absolute;left:72.00px;top:496.80px" class="cls_006"><span class="cls_006">vector size from vector capacity. The size of a vector is the number of elements it currently holds. The</span></div>
<div style="position:absolute;left:72.00px;top:508.80px" class="cls_006"><span class="cls_006">capacity is the maximum number of elements the vector can hold before it must allocate additional</span></div>
<div style="position:absolute;left:72.00px;top:520.92px" class="cls_006"><span class="cls_006">memory to accommodate its growth. When you insert the first element into a vector, typical STL</span></div>
<div style="position:absolute;left:72.00px;top:533.04px" class="cls_006"><span class="cls_006">implementations will allocate a large block of memory to set the vector capacity beyond its initial size</span></div>
<div style="position:absolute;left:72.00px;top:545.04px" class="cls_006"><span class="cls_006">(which is 1). Subsequent insertions will increase the vector size, and capacity remains the same. If the</span></div>
<div style="position:absolute;left:72.00px;top:557.16px" class="cls_006"><span class="cls_006">collection continues to grow, eventually vector size will reach its capacity. The next insertion will force the</span></div>
<div style="position:absolute;left:72.00px;top:569.28px" class="cls_006"><span class="cls_006">vector implementation to expand its capacity. It must take the following steps [</span><span class="cls_036">Lip91</span><span class="cls_006">]:</span></div>
<div style="position:absolute;left:90.00px;top:595.56px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Allocate a larger memory block to make room for additional elements.</span></div>
<div style="position:absolute;left:90.00px;top:607.92px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Copy the existing collection elements to the newly allocated memory. The copy constructor is</span></div>
<div style="position:absolute;left:108.00px;top:619.92px" class="cls_006"><span class="cls_006">invoked for each element in the old collection.</span></div>
<div style="position:absolute;left:90.00px;top:632.28px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Destroy the old collection and free its memory. A destructor would be invoked for each element of</span></div>
<div style="position:absolute;left:108.00px;top:644.40px" class="cls_006"><span class="cls_006">the old collection copy.</span></div>
<div style="position:absolute;left:72.00px;top:670.44px" class="cls_006"><span class="cls_006">These steps could be expensive. For that reason, we would like to minimize the frequency in which a</span></div>
<div style="position:absolute;left:72.00px;top:682.44px" class="cls_006"><span class="cls_006">vector size exceeds its capacity. Allocating and freeing memory is bad enough, but invoking the copy</span></div>
<div style="position:absolute;left:72.00px;top:694.56px" class="cls_006"><span class="cls_006">constructor and destructor for each element of the old collection could get particularly expensive. This</span></div>
<div style="position:absolute;left:72.00px;top:706.68px" class="cls_006"><span class="cls_006">would be the case when the vector elements involve nontrivial constructor and destructor methods. For</span></div>
<div style="position:absolute;left:72.00px;top:719.16px" class="cls_006"><span class="cls_006">example, let's replace our integer collection with a collection of </span><span class="cls_020">BigInt</span><span class="cls_006"> objects.</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">98</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:95424px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background113.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">BigInt</span><span class="cls_006"> class is borrowed from Tom Cargil's "C++ Programming Style" [</span><span class="cls_036">Car92</span><span class="cls_006">]. The </span><span class="cls_020">BigInt</span><span class="cls_006"> class</span></div>
<div style="position:absolute;left:72.00px;top:83.76px" class="cls_006"><span class="cls_006">represents positive integers as binary coded decimals. For example, the number 123 is internally</span></div>
<div style="position:absolute;left:72.00px;top:95.76px" class="cls_006"><span class="cls_006">represented by a 3-byte character array, each byte representing one digit. It allows you to create and</span></div>
<div style="position:absolute;left:72.00px;top:108.36px" class="cls_006"><span class="cls_006">manipulate </span><span class="cls_020">BigInt</span><span class="cls_006"> objects as in</span></div>
<div style="position:absolute;left:72.00px;top:134.28px" class="cls_020"><span class="cls_020">BigInt a = 123;</span></div>
<div style="position:absolute;left:72.00px;top:145.68px" class="cls_020"><span class="cls_020">BigInt b = "456";</span></div>
<div style="position:absolute;left:72.00px;top:156.96px" class="cls_020"><span class="cls_020">BigInt c = a + b;</span></div>
<div style="position:absolute;left:72.00px;top:183.24px" class="cls_006"><span class="cls_006">A subset of the </span><span class="cls_020">BigInt</span><span class="cls_006"> definition is as follows:</span></div>
<div style="position:absolute;left:72.00px;top:209.16px" class="cls_020"><span class="cls_020">class BigInt {</span></div>
<div style="position:absolute;left:72.00px;top:220.44px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:231.72px" class="cls_020"><span class="cls_020">BigInt (const char *);</span></div>
<div style="position:absolute;left:96.00px;top:243.12px" class="cls_020"><span class="cls_020">BigInt (unsigned = 0);</span></div>
<div style="position:absolute;left:96.00px;top:254.40px" class="cls_020"><span class="cls_020">BigInt (const BigInt&);</span></div>
<div style="position:absolute;left:96.00px;top:265.80px" class="cls_020"><span class="cls_020">~BigInt ();</span></div>
<div style="position:absolute;left:72.00px;top:288.36px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:299.76px" class="cls_020"><span class="cls_020">char</span></div>
<div style="position:absolute;left:143.99px;top:299.76px" class="cls_020"><span class="cls_020">*digits;</span></div>
<div style="position:absolute;left:96.00px;top:311.04px" class="cls_020"><span class="cls_020">unsigned ndigits;</span></div>
<div style="position:absolute;left:96.00px;top:322.44px" class="cls_020"><span class="cls_020">unsigned size;</span></div>
<div style="position:absolute;left:263.97px;top:322.44px" class="cls_020"><span class="cls_020">// size of allocated string</span></div>
<div style="position:absolute;left:72.00px;top:345.00px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:371.28px" class="cls_006"><span class="cls_006">In the course of our discussion we are going to utilize only a subset of the </span><span class="cls_020">BigInt</span><span class="cls_006"> implementation. That</span></div>
<div style="position:absolute;left:72.00px;top:383.52px" class="cls_006"><span class="cls_006">subset consists of constructors and a destructor, presented here:</span></div>
<div style="position:absolute;left:72.00px;top:409.20px" class="cls_020"><span class="cls_020">BigInt::BigInt (unsigned u)</span></div>
<div style="position:absolute;left:323.95px;top:409.20px" class="cls_020"><span class="cls_020">// Constructor</span></div>
<div style="position:absolute;left:72.00px;top:420.60px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:431.88px" class="cls_020"><span class="cls_020">unsigned v = u;</span></div>
<div style="position:absolute;left:96.00px;top:454.56px" class="cls_020"><span class="cls_020">for (ndigits = 1; (v/=10) > 0; ++ndigits) {</span></div>
<div style="position:absolute;left:119.99px;top:465.84px" class="cls_020"><span class="cls_020">;</span></div>
<div style="position:absolute;left:299.96px;top:465.84px" class="cls_020"><span class="cls_020">// Count the number</span></div>
<div style="position:absolute;left:96.00px;top:477.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:299.96px;top:477.24px" class="cls_020"><span class="cls_020">// of digits in u</span></div>
<div style="position:absolute;left:96.00px;top:499.92px" class="cls_020"><span class="cls_020">digits = new char[size=ndigits];</span></div>
<div style="position:absolute;left:96.00px;top:522.48px" class="cls_020"><span class="cls_020">for ( unsigned i = 0; i &lt; ndigits; ++i) {</span></div>
<div style="position:absolute;left:119.99px;top:533.88px" class="cls_020"><span class="cls_020">digits[i] = u%10;</span></div>
<div style="position:absolute;left:323.95px;top:533.88px" class="cls_020"><span class="cls_020">// Peel off the</span></div>
<div style="position:absolute;left:119.99px;top:545.16px" class="cls_020"><span class="cls_020">u /= 10;</span></div>
<div style="position:absolute;left:323.95px;top:545.16px" class="cls_020"><span class="cls_020">// digits of u</span></div>
<div style="position:absolute;left:96.00px;top:556.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:567.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:590.52px" class="cls_020"><span class="cls_020">BigInt::BigInt(const BigInt& copyFrom)</span></div>
<div style="position:absolute;left:323.95px;top:590.52px" class="cls_020"><span class="cls_020">// Copy constructor</span></div>
<div style="position:absolute;left:72.00px;top:601.80px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:613.20px" class="cls_020"><span class="cls_020">size = ndigits = copyFrom.ndigits;</span></div>
<div style="position:absolute;left:96.00px;top:624.48px" class="cls_020"><span class="cls_020">digits = new char[size];</span></div>
<div style="position:absolute;left:96.00px;top:647.16px" class="cls_020"><span class="cls_020">for ( unsigned i = 0; i &lt; ndigits; ++i) {</span></div>
<div style="position:absolute;left:119.99px;top:658.44px" class="cls_020"><span class="cls_020">digits[i] = copyFrom.digits[i];</span></div>
<div style="position:absolute;left:96.00px;top:669.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:681.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:703.80px" class="cls_020"><span class="cls_020">BigInt::~BigInt()</span></div>
<div style="position:absolute;left:323.95px;top:703.80px" class="cls_020"><span class="cls_020">// Destructor</span></div>
<div style="position:absolute;left:72.00px;top:715.08px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:726.48px" class="cls_020"><span class="cls_020">delete [] digits;</span></div>
<div style="position:absolute;left:72.00px;top:737.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:291.60px;top:791.64px" class="cls_003"><span class="cls_003">99</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:96276px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background114.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">To measure the effects of vector capacity growth on performance, we repeated the vector insertion test but</span></div>
<div style="position:absolute;left:72.00px;top:83.52px" class="cls_006"><span class="cls_006">replaced the integer elements with </span><span class="cls_020">BigInt</span><span class="cls_006"> objects. </span><span class="cls_036">Figure 11.2</span><span class="cls_006"> compares the insertion time of a million</span></div>
<div style="position:absolute;left:72.00px;top:96.24px" class="cls_006"><span class="cls_006">integers to that of a million </span><span class="cls_020">BigInt</span><span class="cls_006"> objects.</span></div>
<div style="position:absolute;left:208.68px;top:122.76px" class="cls_021"><span class="cls_021">Figure 11.2. Object insertion speed.</span></div>
<div style="position:absolute;left:72.00px;top:398.16px" class="cls_006"><span class="cls_006">The dramatic difference in performance is a reflection of the difference between the cost of copying and</span></div>
<div style="position:absolute;left:72.00px;top:410.76px" class="cls_006"><span class="cls_006">destroying plain integers and that of </span><span class="cls_020">BigInt</span><span class="cls_006"> objects. If you find yourself in a situation where the object's</span></div>
<div style="position:absolute;left:72.00px;top:423.00px" class="cls_006"><span class="cls_006">copy constructor and destructor are fairly expensive, and vector capacity growth is very likely, you could</span></div>
<div style="position:absolute;left:72.00px;top:435.12px" class="cls_006"><span class="cls_006">still circumvent the cost by storing pointers instead of objects. Pointers to objects do not have associated</span></div>
<div style="position:absolute;left:72.00px;top:447.24px" class="cls_006"><span class="cls_006">constructors and destructor. The cost of copying a pointer is essentially identical to an integer copy. The</span></div>
<div style="position:absolute;left:72.00px;top:459.72px" class="cls_006"><span class="cls_006">vector insertion time of a million </span><span class="cls_020">BigInt</span><span class="cls_006"> pointers was practically the same as the integer case and is</span></div>
<div style="position:absolute;left:72.00px;top:472.08px" class="cls_006"><span class="cls_006">given in </span><span class="cls_036">Figure 11.3</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:171.12px;top:498.24px" class="cls_021"><span class="cls_021">Figure 11.3. Comparing object to pointer insertion.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">100</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:97128px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background115.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">The list container does not hold its elements in contiguous memory and consequently does not have to</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">contend with capacity issues and their associated performance overhead. As a result, the list container does</span></div>
<div style="position:absolute;left:72.00px;top:95.52px" class="cls_006"><span class="cls_006">better than a vector on the </span><span class="cls_020">BigInt</span><span class="cls_006"> insertion test (</span><span class="cls_036">Figure 11.4</span><span class="cls_006">).</span></div>
<div style="position:absolute;left:181.20px;top:122.04px" class="cls_021"><span class="cls_021">Figure 11.4. Comparing list to vector insertion.</span></div>
<div style="position:absolute;left:72.00px;top:394.44px" class="cls_036"><span class="cls_036">Figure 11.4</span><span class="cls_006"> brings up another important point: Each container has its strengths and weaknesses. Although</span></div>
<div style="position:absolute;left:72.00px;top:406.56px" class="cls_006"><span class="cls_006">the vector is superior to the list on insertion of a million integers, the list outperforms the vector on a</span></div>
<div style="position:absolute;left:72.00px;top:419.04px" class="cls_006"><span class="cls_006">similar test involving </span><span class="cls_020">BigInt</span><span class="cls_006"> objects.</span></div>
<div style="position:absolute;left:72.00px;top:445.44px" class="cls_006"><span class="cls_006">There's one more alternative solution to the performance difficulty posed by vector capacity growth. In</span></div>
<div style="position:absolute;left:72.00px;top:457.44px" class="cls_006"><span class="cls_006">many situations, you can estimate the vector capacity that is likely to be sufficient in a particular scenario.</span></div>
<div style="position:absolute;left:72.00px;top:469.56px" class="cls_006"><span class="cls_006">In the case where you can make this intelligent guess, you can go ahead and reserve the necessary capacity</span></div>
<div style="position:absolute;left:72.00px;top:482.16px" class="cls_006"><span class="cls_006">ahead of time. The vector </span><span class="cls_020">reserve(n)</span><span class="cls_006"> method guarantees that the vector capacity is equal to or greater</span></div>
<div style="position:absolute;left:72.00px;top:494.88px" class="cls_006"><span class="cls_006">than </span><span class="cls_020">n</span><span class="cls_006"> elements. It required a one-line change in our test code:</span></div>
<div style="position:absolute;left:72.00px;top:520.92px" class="cls_020"><span class="cls_020">vector&lt;BigInt> *v = new vector&lt;BigInt>;</span></div>
<div style="position:absolute;left:72.00px;top:532.20px" class="cls_020"><span class="cls_020">v->reserve(size);</span></div>
<div style="position:absolute;left:72.00px;top:543.48px" class="cls_020"><span class="cls_020">vectorInsert(v,dataBigInt,size);</span></div>
<div style="position:absolute;left:72.00px;top:569.28px" class="cls_006"><span class="cls_006">The reservation of the required capacity has boosted performance by more than a factor of two. </span><span class="cls_036">Figure 11.5</span></div>
<div style="position:absolute;left:72.00px;top:581.76px" class="cls_006"><span class="cls_006">exhibits the execution time of a million </span><span class="cls_020">BigInt</span><span class="cls_006"> insertions with and without reserved capacity.</span></div>
<div style="position:absolute;left:129.84px;top:608.16px" class="cls_021"><span class="cls_021">Figure 11.5. Vector insertion with and without capacity reservation.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">101</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:97980px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background116.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:309.96px" class="cls_006"><span class="cls_006">So far, we have inserted the elements to the back of the array, vector, and list. The array container</span></div>
<div style="position:absolute;left:72.00px;top:321.96px" class="cls_006"><span class="cls_006">performed best in the scenario where the collection size was known in advance. When collection size was</span></div>
<div style="position:absolute;left:72.00px;top:334.08px" class="cls_006"><span class="cls_006">unknown, the vector outperformed the list container for integer insertion. What if we need to add elements</span></div>
<div style="position:absolute;left:72.00px;top:346.20px" class="cls_006"><span class="cls_006">in the middle or in front of the collection? That may turn the performance story upside down. Next, we</span></div>
<div style="position:absolute;left:72.00px;top:358.20px" class="cls_006"><span class="cls_006">compare the performance of the vector and list containers faced with the task of inserting elements to the</span></div>
<div style="position:absolute;left:72.00px;top:370.32px" class="cls_006"><span class="cls_006">front of the container. We used the following two functions:</span></div>
<div style="position:absolute;left:72.00px;top:396.00px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:407.28px" class="cls_020"><span class="cls_020">void vectorInsertFront (vector&lt;T> *v, T *collection, int size)</span></div>
<div style="position:absolute;left:72.00px;top:418.68px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:429.96px" class="cls_020"><span class="cls_020">for (int k =0; k &lt; size; k++) {</span></div>
<div style="position:absolute;left:119.99px;top:441.36px" class="cls_020"><span class="cls_020">v->insert(v->begin(),collection[k]);</span></div>
<div style="position:absolute;left:96.00px;top:452.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:463.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:475.32px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:486.60px" class="cls_020"><span class="cls_020">void listInsertFront (list&lt;T> *l, T *collection, int size)</span></div>
<div style="position:absolute;left:72.00px;top:498.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:509.28px" class="cls_020"><span class="cls_020">for (int k =0; k &lt; size; k++) {</span></div>
<div style="position:absolute;left:119.99px;top:520.56px" class="cls_020"><span class="cls_020">l->push_front(collection[k]);</span></div>
<div style="position:absolute;left:96.00px;top:531.96px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:543.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:569.04px" class="cls_006"><span class="cls_006">The performance of the vector container on front insertions was terrible. It was so bad that we had to limit</span></div>
<div style="position:absolute;left:72.00px;top:581.04px" class="cls_006"><span class="cls_006">the collection size to 10,000. Each insertion at the front of the vector forced a shift of all existing elements</span></div>
<div style="position:absolute;left:72.00px;top:593.16px" class="cls_006"><span class="cls_006">to make room for the new one. The complexity of such an implementation is O(N*N) where N is the</span></div>
<div style="position:absolute;left:72.00px;top:605.16px" class="cls_006"><span class="cls_006">collection size. In other words, making the collection ten times bigger would result in execution time that</span></div>
<div style="position:absolute;left:72.00px;top:617.28px" class="cls_006"><span class="cls_006">is 100 times longer. We did not have that much time so we limited the test to 10,000 elements. The list</span></div>
<div style="position:absolute;left:72.00px;top:629.28px" class="cls_006"><span class="cls_006">container, on the other hand, takes constant time to insert an element at the front, regardless of collection</span></div>
<div style="position:absolute;left:72.00px;top:641.40px" class="cls_006"><span class="cls_006">size. The dramatic difference in execution time is shown in </span><span class="cls_036">Figure 11.6</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:214.32px;top:667.56px" class="cls_021"><span class="cls_021">Figure 11.6. Inserting at the front.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">102</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:98832px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background117.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:310.68px" class="cls_006"><span class="cls_006">This last test highlights another one of the performance benefits of the STL: The STL design discourages</span></div>
<div style="position:absolute;left:72.00px;top:322.80px" class="cls_006"><span class="cls_006">you from doing really silly things like choosing a vector container when you need to insert elements at the</span></div>
<div style="position:absolute;left:72.00px;top:335.28px" class="cls_006"><span class="cls_006">front. For that reason the STL does not provide a </span><span class="cls_020">push_front()</span><span class="cls_006"> method for the vector container. If you</span></div>
<div style="position:absolute;left:72.00px;top:347.64px" class="cls_006"><span class="cls_006">really insist on doing something so inefficient, you'll have to do it yourself as we did in the</span></div>
<div style="position:absolute;left:72.00px;top:360.12px" class="cls_020"><span class="cls_020">vectorInsertFront()</span><span class="cls_006"> code.</span></div>
<div style="position:absolute;left:72.00px;top:414.24px" class="cls_016"><span class="cls_016">Deletion</span></div>
<div style="position:absolute;left:72.00px;top:445.56px" class="cls_006"><span class="cls_006">The deletion performance story is in many ways analogous to insertion. Many of the statements made with</span></div>
<div style="position:absolute;left:72.00px;top:456.84px" class="cls_006"><span class="cls_006">regard to insertion efficiency apply equally as well to deletion.</span><span class="cls_037"><sup>[1]</sup></span><span class="cls_006"> For example:</span></div>
<div style="position:absolute;left:90.00px;top:483.60px" class="cls_026"><span class="cls_026"><sup>[1]</sup></span><span class="cls_027"> You can find those and many more performance guarantees in [</span><span class="cls_038">MS96</span><span class="cls_027">]. It contains complexity guarantees</span></div>
<div style="position:absolute;left:90.00px;top:497.28px" class="cls_027"><span class="cls_027">for all containers and generic algorithms.</span></div>
<div style="position:absolute;left:90.00px;top:521.52px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A vector excels at insertion (deletion) of elements at the back. This is a constant-time operation as</span></div>
<div style="position:absolute;left:108.00px;top:533.64px" class="cls_006"><span class="cls_006">it is independent of collection size.</span></div>
<div style="position:absolute;left:90.00px;top:545.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A vector is a terrible choice for element insertion (deletion) anywhere other than the back. The</span></div>
<div style="position:absolute;left:108.00px;top:558.00px" class="cls_006"><span class="cls_006">cost of such insertion (deletion) is proportional to the distance of the insertion (deletion) point and</span></div>
<div style="position:absolute;left:108.00px;top:570.12px" class="cls_006"><span class="cls_006">the last element of the vector.</span></div>
<div style="position:absolute;left:90.00px;top:582.36px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A deque is efficient (constant-time) at insertion (deletion) at the front and back of a collection. It is</span></div>
<div style="position:absolute;left:108.00px;top:594.48px" class="cls_006"><span class="cls_006">inefficient for insertions (deletions) anywhere else.</span></div>
<div style="position:absolute;left:90.00px;top:606.84px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A list is efficient (constant-time) for insertion (deletion) anywhere in the collection.</span></div>
<div style="position:absolute;left:72.00px;top:632.88px" class="cls_006"><span class="cls_006">As a sanity check, we tested the deletion of a million elements from a vector and list. For both list and</span></div>
<div style="position:absolute;left:72.00px;top:645.48px" class="cls_006"><span class="cls_006">vector, we used the </span><span class="cls_020">pop_back()</span><span class="cls_006"> method provided by the STL. </span><span class="cls_020">pop_back()</span><span class="cls_006"> deletes the last element of</span></div>
<div style="position:absolute;left:72.00px;top:657.72px" class="cls_006"><span class="cls_006">a container.</span></div>
<div style="position:absolute;left:72.00px;top:683.52px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:694.80px" class="cls_020"><span class="cls_020">void vectorDelete (vector&lt;T> *v)</span></div>
<div style="position:absolute;left:72.00px;top:706.08px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:717.48px" class="cls_020"><span class="cls_020">while (!v->empty()) {</span></div>
<div style="position:absolute;left:119.99px;top:728.76px" class="cls_020"><span class="cls_020">v->pop_back();</span></div>
<div style="position:absolute;left:96.00px;top:740.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:751.44px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">103</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:99684px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background118.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">void listDelete (list&lt;T> *l)</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:115.92px" class="cls_020"><span class="cls_020">while (!l->empty()) {</span></div>
<div style="position:absolute;left:119.99px;top:127.20px" class="cls_020"><span class="cls_020">l->pop_back();</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:149.88px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:175.44px" class="cls_006"><span class="cls_006">The execution speed is shown in </span><span class="cls_036">Figure 11.7</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:183.24px;top:201.72px" class="cls_021"><span class="cls_021">Figure 11.7. Comparing list to vector deletion.</span></div>
<div style="position:absolute;left:72.00px;top:467.40px" class="cls_006"><span class="cls_006">Just like insertion, the vector container outperforms the list when it comes to element deletion at the back</span></div>
<div style="position:absolute;left:72.00px;top:479.52px" class="cls_006"><span class="cls_006">of a collection. What about deletion at the front? If it is anything like insertion it should reverse the</span></div>
<div style="position:absolute;left:72.00px;top:491.64px" class="cls_006"><span class="cls_006">performance comparison between a vector and a list. The test code is given by:</span></div>
<div style="position:absolute;left:72.00px;top:517.32px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:528.60px" class="cls_020"><span class="cls_020">void listDeleteFront (list&lt;T> *l)</span></div>
<div style="position:absolute;left:72.00px;top:540.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:551.28px" class="cls_020"><span class="cls_020">while (!l->empty()) {</span></div>
<div style="position:absolute;left:119.99px;top:562.56px" class="cls_020"><span class="cls_020">l->pop_front();</span></div>
<div style="position:absolute;left:96.00px;top:573.96px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:585.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:607.92px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:619.20px" class="cls_020"><span class="cls_020">void vectorDeleteFront (vector&lt;T> *v)</span></div>
<div style="position:absolute;left:72.00px;top:630.60px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:641.88px" class="cls_020"><span class="cls_020">while (!v->empty()) {</span></div>
<div style="position:absolute;left:119.99px;top:653.28px" class="cls_020"><span class="cls_020">v->erase(v->begin());</span></div>
<div style="position:absolute;left:96.00px;top:664.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:675.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:701.64px" class="cls_006"><span class="cls_006">Just like insertion at the front, deleting elements at the front of a vector is inefficient. For that reason we</span></div>
<div style="position:absolute;left:72.00px;top:713.64px" class="cls_006"><span class="cls_006">had to limit this test to 10,000 elements. The execution times are shown in </span><span class="cls_036">Figure 11.8</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:191.40px;top:739.80px" class="cls_021"><span class="cls_021">Figure 11.8. Deleting elements at the front.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">104</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:100536px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background119.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:310.68px" class="cls_006"><span class="cls_006">In this test, the list outperformed the vector by a factor of 100. Notice also how the STL does not provide a</span></div>
<div style="position:absolute;left:72.00px;top:323.28px" class="cls_020"><span class="cls_020">pop_front()</span><span class="cls_006"> method for the vector container to discourage users from attempting this inefficient</span></div>
<div style="position:absolute;left:72.00px;top:335.52px" class="cls_006"><span class="cls_006">manipulation of a vector container.</span></div>
<div style="position:absolute;left:72.00px;top:361.68px" class="cls_006"><span class="cls_006">The deletion performance story told by </span><span class="cls_036">Figures 11.7</span><span class="cls_006"> and </span><span class="cls_036">11.8</span><span class="cls_006"> is analogous to the insertion performance</span></div>
<div style="position:absolute;left:72.00px;top:373.68px" class="cls_006"><span class="cls_006">revealed by </span><span class="cls_036">Figures 11.1</span><span class="cls_006"> and </span><span class="cls_036">11.6</span><span class="cls_006">. It reiterates the statements we made at the beginning of this section:</span></div>
<div style="position:absolute;left:72.00px;top:385.80px" class="cls_006"><span class="cls_006">Performance observations made with regard to container insertion will also apply to deletion.</span></div>
<div style="position:absolute;left:72.00px;top:439.56px" class="cls_016"><span class="cls_016">Traversal</span></div>
<div style="position:absolute;left:72.00px;top:470.88px" class="cls_006"><span class="cls_006">We often need to traverse a container one element at a time, performing a computation on each element.</span></div>
<div style="position:absolute;left:72.00px;top:483.48px" class="cls_006"><span class="cls_006">We picked the STL's </span><span class="cls_020">accumulate()</span><span class="cls_006"> function to represent container traversal. The </span><span class="cls_020">accumulate()</span></div>
<div style="position:absolute;left:72.00px;top:495.72px" class="cls_006"><span class="cls_006">function traverses the container from beginning to end, adding all elements in the process. The containers</span></div>
<div style="position:absolute;left:72.00px;top:507.84px" class="cls_006"><span class="cls_006">under test were an array, vector, and list. Each container stored an identical collection of 10,000 random</span></div>
<div style="position:absolute;left:72.00px;top:519.96px" class="cls_006"><span class="cls_006">integers. The test code for the various containers is as follows:</span></div>
<div style="position:absolute;left:72.00px;top:545.64px" class="cls_020"><span class="cls_020">void vectorTraverse (vector&lt;int> *v, int size)</span></div>
<div style="position:absolute;left:72.00px;top:556.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:568.32px" class="cls_020"><span class="cls_020">int sum = accumulate(v->begin(), v->end(),0);</span></div>
<div style="position:absolute;left:72.00px;top:579.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:591.00px" class="cls_020"><span class="cls_020">void arrayTraverse (int *a, int size)</span></div>
<div style="position:absolute;left:72.00px;top:602.28px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:613.56px" class="cls_020"><span class="cls_020">int sum = accumulate(&a[0], &a[size],0);</span></div>
<div style="position:absolute;left:72.00px;top:624.96px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:647.64px" class="cls_020"><span class="cls_020">void listTraverse (list&lt;int> *l, int size)</span></div>
<div style="position:absolute;left:72.00px;top:658.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:670.20px" class="cls_020"><span class="cls_020">int sum = accumulate(l->begin(), l->end(),0);</span></div>
<div style="position:absolute;left:72.00px;top:692.88px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:718.68px" class="cls_006"><span class="cls_006">The test itself consisted of invoking these traversal functions 100 times each. The execution time of 100</span></div>
<div style="position:absolute;left:72.00px;top:730.68px" class="cls_006"><span class="cls_006">traversals of the various containers is shown in </span><span class="cls_036">Figure 11.9</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:200.76px;top:756.84px" class="cls_021"><span class="cls_021">Figure 11.9. Container traversal speed.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">105</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:101388px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background120.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:298.68px" class="cls_006"><span class="cls_006">With regard to container traversal, the performance of the vector and array was the same. Both</span></div>
<div style="position:absolute;left:72.00px;top:310.80px" class="cls_006"><span class="cls_006">outperformed the list container by a wide margin. The dominant factor in container traversal seemed to be</span></div>
<div style="position:absolute;left:72.00px;top:322.80px" class="cls_006"><span class="cls_006">the interaction between the container memory layout and the system's cache. Both vector and array hold</span></div>
<div style="position:absolute;left:72.00px;top:334.92px" class="cls_006"><span class="cls_006">their collections in contiguous memory. Logically adjacent elements of the collection reside physically</span></div>
<div style="position:absolute;left:72.00px;top:346.92px" class="cls_006"><span class="cls_006">next to one another in memory. When a particular element is loaded into the cache, it pulls with it a few</span></div>
<div style="position:absolute;left:72.00px;top:359.04px" class="cls_006"><span class="cls_006">more adjacent elements that will be accessed next (the exact number depends on the element size as well</span></div>
<div style="position:absolute;left:72.00px;top:371.16px" class="cls_006"><span class="cls_006">as the size of a cache line). This is ideal behavior from a caching perspective. This is not the case with a</span></div>
<div style="position:absolute;left:72.00px;top:383.16px" class="cls_006"><span class="cls_006">list container. Logically adjacent list elements are not necessarily adjacent in memory. Moreover, the list</span></div>
<div style="position:absolute;left:72.00px;top:395.28px" class="cls_006"><span class="cls_006">elements must store forward and backward pointers in addition to element value, which makes them larger</span></div>
<div style="position:absolute;left:72.00px;top:407.28px" class="cls_006"><span class="cls_006">than the corresponding vector elements. Even if some adjacent list elements were placed next to one</span></div>
<div style="position:absolute;left:72.00px;top:419.40px" class="cls_006"><span class="cls_006">another in memory, fewer of them would fit on a cache line due to their size. Consequently, traversal of a</span></div>
<div style="position:absolute;left:72.00px;top:431.52px" class="cls_006"><span class="cls_006">list container produces far more cache misses than an array or vector traversal.</span></div>
<div style="position:absolute;left:72.00px;top:485.28px" class="cls_016"><span class="cls_016">Find</span></div>
<div style="position:absolute;left:72.00px;top:516.60px" class="cls_006"><span class="cls_006">The previous discussions of insertion, deletion, and traversal provided scenarios in which each of the array,</span></div>
<div style="position:absolute;left:72.00px;top:528.72px" class="cls_006"><span class="cls_006">vector, and list containers had a chance to outperform the other containers under test. We now move on to</span></div>
<div style="position:absolute;left:72.00px;top:540.72px" class="cls_006"><span class="cls_006">yet another important operation that will allow the multiset container to shine. This is the case where we</span></div>
<div style="position:absolute;left:72.00px;top:553.32px" class="cls_006"><span class="cls_006">need to look up a specific element in a collection. The following code uses the STL's </span><span class="cls_020">find()</span><span class="cls_006"> to perform a</span></div>
<div style="position:absolute;left:72.00px;top:565.68px" class="cls_006"><span class="cls_006">lookup on the various containers:</span></div>
<div style="position:absolute;left:72.00px;top:591.36px" class="cls_020"><span class="cls_020">void arrayFind (int *a, int *collection, int size)</span></div>
<div style="position:absolute;left:72.00px;top:602.64px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:614.04px" class="cls_020"><span class="cls_020">int const value = collection[size/2];</span></div>
<div style="position:absolute;left:96.00px;top:625.32px" class="cls_020"><span class="cls_020">int *p = find(&a[0],&a[size],value);</span></div>
<div style="position:absolute;left:72.00px;top:636.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:659.28px" class="cls_020"><span class="cls_020">void vectorFind (vector&lt;int> *v, int *collection, int size)</span></div>
<div style="position:absolute;left:72.00px;top:670.68px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:681.96px" class="cls_020"><span class="cls_020">int const value = collection[size/2];</span></div>
<div style="position:absolute;left:96.00px;top:693.24px" class="cls_020"><span class="cls_020">vector&lt;int>::iterator it =</span></div>
<div style="position:absolute;left:107.99px;top:704.64px" class="cls_020"><span class="cls_020">find(v->begin(), v->end(), value);</span></div>
<div style="position:absolute;left:72.00px;top:715.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:738.60px" class="cls_020"><span class="cls_020">void listFind (list&lt;int> *l, int *collection, int size)</span></div>
<div style="position:absolute;left:72.00px;top:750.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">106</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:102240px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background121.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">int const value = collection[size/2];</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">list&lt;int>::iterator it =</span></div>
<div style="position:absolute;left:107.99px;top:93.24px" class="cls_020"><span class="cls_020">find(l->begin(), l->end(), value);</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:127.20px" class="cls_020"><span class="cls_020">// This is using the generic find() which is not the</span></div>
<div style="position:absolute;left:72.00px;top:138.48px" class="cls_020"><span class="cls_020">// best choice when searching a multiset.</span></div>
<div style="position:absolute;left:72.00px;top:149.88px" class="cls_020"><span class="cls_020">void multisetFind (multiset&lt;int> *s, int *collection, int size)</span></div>
<div style="position:absolute;left:72.00px;top:161.16px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:172.56px" class="cls_020"><span class="cls_020">int const value = collection[size/2];</span></div>
<div style="position:absolute;left:96.00px;top:183.84px" class="cls_020"><span class="cls_020">multiset&lt;int>::iterator it =</span></div>
<div style="position:absolute;left:107.99px;top:195.12px" class="cls_020"><span class="cls_020">find(s->begin(), s->end(), value);</span></div>
<div style="position:absolute;left:72.00px;top:206.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:232.20px" class="cls_006"><span class="cls_006">The performance test consisted of a hundred iterations of a container search. The execution times are</span></div>
<div style="position:absolute;left:72.00px;top:244.20px" class="cls_006"><span class="cls_006">shown in </span><span class="cls_036">Figure 11.10</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:202.68px;top:270.48px" class="cls_021"><span class="cls_021">Figure 11.10. Container search speed.</span></div>
<div style="position:absolute;left:72.00px;top:527.16px" class="cls_036"><span class="cls_036">Figure 11.10</span><span class="cls_006"> is misleading in the sense that it seems to indicate that a vector and an array are the best</span></div>
<div style="position:absolute;left:72.00px;top:539.76px" class="cls_006"><span class="cls_006">choices for lookup performance. It seems that way only because we have misused the generic </span><span class="cls_020">find()</span></div>
<div style="position:absolute;left:72.00px;top:552.48px" class="cls_006"><span class="cls_006">algorithm on the multiset container. It would be much more efficient to use the </span><span class="cls_020">find()</span><span class="cls_006"> member method</span></div>
<div style="position:absolute;left:72.00px;top:565.32px" class="cls_006"><span class="cls_006">provided by the multiset container. The member </span><span class="cls_020">find()</span><span class="cls_006"> utilizes the fact that the multiset is a sorted</span></div>
<div style="position:absolute;left:72.00px;top:578.16px" class="cls_006"><span class="cls_006">container. The generic </span><span class="cls_020">find()</span><span class="cls_006"> is oblivious to that fact because it must handle containers that are not</span></div>
<div style="position:absolute;left:72.00px;top:590.88px" class="cls_006"><span class="cls_006">sorted. Consequently, the generic </span><span class="cls_020">find()</span><span class="cls_006"> must perform a sequential search. The following version of the</span></div>
<div style="position:absolute;left:72.00px;top:603.72px" class="cls_006"><span class="cls_006">multiset search is using the member </span><span class="cls_020">find()</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:629.76px" class="cls_020"><span class="cls_020">void multisetFind (multiset&lt;int> *s, int *collection, int size)</span></div>
<div style="position:absolute;left:72.00px;top:641.04px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:652.32px" class="cls_020"><span class="cls_020">int const value = collection[size/2];</span></div>
<div style="position:absolute;left:96.00px;top:663.72px" class="cls_020"><span class="cls_020">multiset&lt;int>::iterator it =</span></div>
<div style="position:absolute;left:119.99px;top:675.00px" class="cls_020"><span class="cls_020">s->find(value);</span></div>
<div style="position:absolute;left:72.00px;top:686.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:712.56px" class="cls_006"><span class="cls_006">The member </span><span class="cls_020">find()</span><span class="cls_006"> outperformed the generic one by orders of magnitude. The generic </span><span class="cls_020">find()</span><span class="cls_006"> took</span></div>
<div style="position:absolute;left:72.00px;top:724.80px" class="cls_006"><span class="cls_006">23,000 milliseconds to perform a hundred searches through a million element multiset, whereas the</span></div>
<div style="position:absolute;left:72.00px;top:737.40px" class="cls_006"><span class="cls_006">member </span><span class="cls_020">find()</span><span class="cls_006"> performed the same test in 0.06 milliseconds. You can get a visual feel for it in </span><span class="cls_036">Figure</span></div>
<div style="position:absolute;left:72.00px;top:749.76px" class="cls_036"><span class="cls_036">11.11</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:103092px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background122.jpg" width=595 height=842></div>
<div style="position:absolute;left:141.36px;top:70.20px" class="cls_021"><span class="cls_021">Figure 11.11. Comparing generic </span><span class="cls_024">find()</span><span class="cls_021"> to member </span><span class="cls_024">find()</span><span class="cls_021">.</span></div>
<div style="position:absolute;left:72.00px;top:328.68px" class="cls_006"><span class="cls_006">Obviously, using the member </span><span class="cls_020">find()</span><span class="cls_006">, the multiset container blew away the rest of the competition when</span></div>
<div style="position:absolute;left:72.00px;top:341.04px" class="cls_006"><span class="cls_006">it came to element search. The fact that the multiset is a sorted collection exacted some performance</span></div>
<div style="position:absolute;left:72.00px;top:353.16px" class="cls_006"><span class="cls_006">penalty on insertion and deletion. On the other hand, being in sorted order provides the multiset container a</span></div>
<div style="position:absolute;left:72.00px;top:365.16px" class="cls_006"><span class="cls_006">large advantage when it comes to searching.</span></div>
<div style="position:absolute;left:72.00px;top:418.92px" class="cls_016"><span class="cls_016">Function Objects</span></div>
<div style="position:absolute;left:72.00px;top:450.72px" class="cls_006"><span class="cls_006">By default, the </span><span class="cls_020">accumulate()</span><span class="cls_006"> function applies </span><span class="cls_020">operator+</span><span class="cls_006"> to all the elements residing in a container</span></div>
<div style="position:absolute;left:72.00px;top:463.08px" class="cls_006"><span class="cls_006">and returns the cumulative result of adding all the elements. In the case of an integer collection, if the</span></div>
<div style="position:absolute;left:72.00px;top:475.68px" class="cls_006"><span class="cls_006">initial value provided to </span><span class="cls_020">accumulate()</span><span class="cls_006"> is 0, the result would be the sum of the collection. The</span></div>
<div style="position:absolute;left:72.00px;top:488.52px" class="cls_020"><span class="cls_020">accumulate()</span><span class="cls_006"> algorithm is by no means limited to object addition. It is capable of applying any</span></div>
<div style="position:absolute;left:72.00px;top:500.76px" class="cls_006"><span class="cls_006">operation to the container elements (given that the operation is supported by the elements) and returning</span></div>
<div style="position:absolute;left:72.00px;top:512.88px" class="cls_006"><span class="cls_006">the cumulative result [</span><span class="cls_036">MS96</span><span class="cls_006">]:</span></div>
<div style="position:absolute;left:72.00px;top:538.56px" class="cls_020"><span class="cls_020">template &lt;class InputIterator, class T></span></div>
<div style="position:absolute;left:72.00px;top:549.96px" class="cls_020"><span class="cls_020">T accumulate(InputIterator first,</span></div>
<div style="position:absolute;left:149.99px;top:561.24px" class="cls_020"><span class="cls_020">InputIterator beyondLast,</span></div>
<div style="position:absolute;left:149.99px;top:572.52px" class="cls_020"><span class="cls_020">T initialValue)</span></div>
<div style="position:absolute;left:72.00px;top:583.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:595.20px" class="cls_020"><span class="cls_020">while (first != beyondLast) {</span></div>
<div style="position:absolute;left:119.99px;top:606.60px" class="cls_020"><span class="cls_020">initialValue = initialValue + *first++;</span></div>
<div style="position:absolute;left:96.00px;top:617.88px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:629.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:654.96px" class="cls_006"><span class="cls_006">In C programming, parameterizing such an operation normally would be achieved by passing a function</span></div>
<div style="position:absolute;left:72.00px;top:666.96px" class="cls_006"><span class="cls_006">pointer. The STL can do the same, but in addition, it provides us with a more efficient alternative in the</span></div>
<div style="position:absolute;left:72.00px;top:679.08px" class="cls_006"><span class="cls_006">form of function objects.</span></div>
<div style="position:absolute;left:72.00px;top:705.12px" class="cls_006"><span class="cls_006">Suppose that instead of a sum, we would like to compute the product of a set of integers. One option we</span></div>
<div style="position:absolute;left:72.00px;top:717.24px" class="cls_006"><span class="cls_006">have is to define a function that returns the product of two integers and passes it as an argument to</span></div>
<div style="position:absolute;left:72.00px;top:729.72px" class="cls_020"><span class="cls_020">accumulate()</span><span class="cls_006"> [</span><span class="cls_036">MS96</span><span class="cls_006">]:</span></div>
<div style="position:absolute;left:72.00px;top:755.76px" class="cls_020"><span class="cls_020">int mult(int x, int y) {return x*y;}</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">108</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:103944px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background123.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">int a[10] = {1, 2, 3, 5, 7, 11, 13, 17, 19, 23};</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">int product = accumulate (&a[0],</span></div>
<div style="position:absolute;left:221.97px;top:104.52px" class="cls_020"><span class="cls_020">&a[10],</span></div>
<div style="position:absolute;left:221.97px;top:115.92px" class="cls_020"><span class="cls_020">1,</span></div>
<div style="position:absolute;left:221.97px;top:127.20px" class="cls_020"><span class="cls_020">mult); // Function pointer</span></div>
<div style="position:absolute;left:72.00px;top:153.36px" class="cls_006"><span class="cls_006">The second option is to pass a function object as an argument to </span><span class="cls_020">accumulate()</span><span class="cls_006">. A function object is an</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">instance of a class that overloads </span><span class="cls_020">operator()</span><span class="cls_006">. For example:</span></div>
<div style="position:absolute;left:72.00px;top:192.12px" class="cls_020"><span class="cls_020">class Mult {</span></div>
<div style="position:absolute;left:72.00px;top:203.52px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:214.80px" class="cls_020"><span class="cls_020">int operator() (int x, int y) const {return x*y;}</span></div>
<div style="position:absolute;left:72.00px;top:226.08px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:248.76px" class="cls_020"><span class="cls_020">int a[10] = {1, 2, 3, 5, 7, 11, 13, 17, 19, 23};</span></div>
<div style="position:absolute;left:72.00px;top:260.16px" class="cls_020"><span class="cls_020">int product = accumulate (&a[0],</span></div>
<div style="position:absolute;left:221.97px;top:271.44px" class="cls_020"><span class="cls_020">&a[10],</span></div>
<div style="position:absolute;left:221.97px;top:282.72px" class="cls_020"><span class="cls_020">1,</span></div>
<div style="position:absolute;left:221.97px;top:294.12px" class="cls_020"><span class="cls_020">Mult()); // Constructor for a</span></div>
<div style="position:absolute;left:275.96px;top:305.40px" class="cls_020"><span class="cls_020">// function object</span></div>
<div style="position:absolute;left:72.00px;top:331.68px" class="cls_006"><span class="cls_006">We really didn't have to reinvent the multiplication wheel as the STL already provides a </span><span class="cls_020">times</span><span class="cls_006"> template</span></div>
<div style="position:absolute;left:72.00px;top:343.92px" class="cls_006"><span class="cls_006">class.</span></div>
<div style="position:absolute;left:72.00px;top:369.96px" class="cls_006"><span class="cls_006">The following would be equivalent [</span><span class="cls_036">MS96</span><span class="cls_006">]:</span></div>
<div style="position:absolute;left:72.00px;top:395.76px" class="cls_020"><span class="cls_020">int product = accumulate (&a[0],</span></div>
<div style="position:absolute;left:221.97px;top:407.04px" class="cls_020"><span class="cls_020">&a[10],</span></div>
<div style="position:absolute;left:221.97px;top:418.32px" class="cls_020"><span class="cls_020">1,</span></div>
<div style="position:absolute;left:221.97px;top:429.72px" class="cls_020"><span class="cls_020">times&lt;int>()); // Constructor for a</span></div>
<div style="position:absolute;left:311.96px;top:441.00px" class="cls_020"><span class="cls_020">// function object</span></div>
<div style="position:absolute;left:72.00px;top:467.28px" class="cls_006"><span class="cls_006">We compared the relative performance of </span><span class="cls_020">accumulate()</span><span class="cls_006"> using both function pointers and function</span></div>
<div style="position:absolute;left:72.00px;top:480.00px" class="cls_006"><span class="cls_006">objects. The execution times given in </span><span class="cls_036">Figure 11.12</span><span class="cls_006"> represent one million calls to the </span><span class="cls_020">accumulate()</span></div>
<div style="position:absolute;left:72.00px;top:492.36px" class="cls_006"><span class="cls_006">versions just discussed.</span></div>
<div style="position:absolute;left:141.48px;top:518.52px" class="cls_021"><span class="cls_021">Figure 11.12. Comparing function objects to function pointers.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">109</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:104796px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background124.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">The version using the function object has significantly outperformed the one using function pointers. This</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">is in line with expectation. Function pointers cannot be resolved until run-time, which prevents them from</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">being inlined. Function objects, however, are determined at compile-time, which gives the compiler the</span></div>
<div style="position:absolute;left:72.00px;top:107.64px" class="cls_006"><span class="cls_006">freedom to inline the calls to </span><span class="cls_020">operator()</span><span class="cls_006"> and significantly increase efficiency.</span></div>
<div style="position:absolute;left:72.00px;top:161.64px" class="cls_016"><span class="cls_016">Better than STL?</span></div>
<div style="position:absolute;left:72.00px;top:192.96px" class="cls_006"><span class="cls_006">The STL is regarded by many to have excellent performance. The general trend is to discourage the</span></div>
<div style="position:absolute;left:72.00px;top:205.08px" class="cls_006"><span class="cls_006">programmer from even thinking about surpassing the STL performance with home-grown implementations.</span></div>
<div style="position:absolute;left:72.00px;top:217.20px" class="cls_006"><span class="cls_006">Although we agree with this notion, for the most part, we would still like to take a closer look at those</span></div>
<div style="position:absolute;left:72.00px;top:229.20px" class="cls_006"><span class="cls_006">conceptions. To learn more about it, we will take a few shots at exceeding the STL performance and see</span></div>
<div style="position:absolute;left:72.00px;top:241.32px" class="cls_006"><span class="cls_006">how it goes.</span></div>
<div style="position:absolute;left:72.00px;top:267.84px" class="cls_006"><span class="cls_006">We have encountered the </span><span class="cls_020">accumulate()</span><span class="cls_006"> function earlier in this chapter, using it to sum up a collection</span></div>
<div style="position:absolute;left:72.00px;top:280.20px" class="cls_006"><span class="cls_006">of integers. Let's see if we can improve upon it with a home-grown implementation:</span></div>
<div style="position:absolute;left:72.00px;top:305.88px" class="cls_020"><span class="cls_020">int myIntegerSum(int *a, int size)</span></div>
<div style="position:absolute;left:72.00px;top:317.16px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:328.56px" class="cls_020"><span class="cls_020">int sum = 0;</span></div>
<div style="position:absolute;left:96.00px;top:339.84px" class="cls_020"><span class="cls_020">int *begin = &a[0];</span></div>
<div style="position:absolute;left:96.00px;top:351.24px" class="cls_020"><span class="cls_020">int *end = &a[size];</span></div>
<div style="position:absolute;left:96.00px;top:373.80px" class="cls_020"><span class="cls_020">for (int *p=begin; p != end; p++) {</span></div>
<div style="position:absolute;left:119.99px;top:385.20px" class="cls_020"><span class="cls_020">sum += *p;</span></div>
<div style="position:absolute;left:96.00px;top:396.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:419.16px" class="cls_020"><span class="cls_020">return sum;</span></div>
<div style="position:absolute;left:72.00px;top:430.44px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:456.12px" class="cls_006"><span class="cls_006">The STL-based solution is</span></div>
<div style="position:absolute;left:72.00px;top:481.92px" class="cls_020"><span class="cls_020">int stlIntegerSum(int *a, int size)</span></div>
<div style="position:absolute;left:72.00px;top:493.20px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:504.60px" class="cls_020"><span class="cls_020">return accumulate (&a[0],&a[size],0);</span></div>
<div style="position:absolute;left:72.00px;top:515.88px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:542.04px" class="cls_006"><span class="cls_006">The results of a performance comparison test indicated that the execution speed of </span><span class="cls_020">myIntegerSum()</span></div>
<div style="position:absolute;left:72.00px;top:554.88px" class="cls_006"><span class="cls_006">was identical to that of </span><span class="cls_020">stlIntegerSum()</span><span class="cls_006">. Our attempt to surpass the STL's speed has come up short. It</span></div>
<div style="position:absolute;left:72.00px;top:567.12px" class="cls_006"><span class="cls_006">is reasonable to speculate that this scenario is typical and that, in general, exceeding the STL's performance</span></div>
<div style="position:absolute;left:72.00px;top:579.24px" class="cls_006"><span class="cls_006">would be an exception to the rule. An STL implementation has a few things going in its favor:</span></div>
<div style="position:absolute;left:90.00px;top:605.52px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   STL implementations use best-of-breed algorithms.</span></div>
<div style="position:absolute;left:90.00px;top:617.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The designers of STL implementations are, more than likely, domain experts.</span></div>
<div style="position:absolute;left:90.00px;top:630.24px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Those domain experts were entirely focused on the mission of providing a flexible, powerful, and</span></div>
<div style="position:absolute;left:108.00px;top:642.36px" class="cls_006"><span class="cls_006">efficient library. This was their primary task.</span></div>
<div style="position:absolute;left:72.00px;top:668.40px" class="cls_006"><span class="cls_006">For the rest of us, developing reusable containers and generic algorithms is a secondary goal at best. Our</span></div>
<div style="position:absolute;left:72.00px;top:680.40px" class="cls_006"><span class="cls_006">primary task is to deliver an application under a tight deadline. In most cases, we are not going to have the</span></div>
<div style="position:absolute;left:72.00px;top:692.52px" class="cls_006"><span class="cls_006">time or expertise to match those of the STL designers.</span></div>
<div style="position:absolute;left:72.00px;top:718.56px" class="cls_006"><span class="cls_006">Now that we have done our best to discourage you from trying to compete with the STL, we will shift</span></div>
<div style="position:absolute;left:72.00px;top:730.68px" class="cls_006"><span class="cls_006">gears and present some possible exceptions to the rule. For example, suppose our application often needs</span></div>
<div style="position:absolute;left:72.00px;top:742.80px" class="cls_006"><span class="cls_006">to reverse a character sequence. Suppose further that our character sequences are of fixed length, say five</span></div>
<div style="position:absolute;left:72.00px;top:754.80px" class="cls_006"><span class="cls_006">characters long. Here's a possible STL-based solution:</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">110</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:105648px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background125.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">char *s = "abcde";</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">reverse (&s[0],&s[5]);</span></div>
<div style="position:absolute;left:72.00px;top:107.52px" class="cls_006"><span class="cls_006">Alternatively we can roll our own solution, as in:</span></div>
<div style="position:absolute;left:72.00px;top:133.32px" class="cls_020"><span class="cls_020">char *s = "abcde";</span></div>
<div style="position:absolute;left:72.00px;top:144.60px" class="cls_020"><span class="cls_020">char temp;</span></div>
<div style="position:absolute;left:72.00px;top:167.28px" class="cls_020"><span class="cls_020">temp = s[4];</span></div>
<div style="position:absolute;left:203.98px;top:167.28px" class="cls_020"><span class="cls_020">// s[0] &lt;-> s[4]</span></div>
<div style="position:absolute;left:72.00px;top:178.56px" class="cls_020"><span class="cls_020">s[4] = s[0];</span></div>
<div style="position:absolute;left:72.00px;top:189.96px" class="cls_020"><span class="cls_020">s[0] = temp;</span></div>
<div style="position:absolute;left:72.00px;top:212.64px" class="cls_020"><span class="cls_020">temp = s[3];</span></div>
<div style="position:absolute;left:203.98px;top:212.64px" class="cls_020"><span class="cls_020">// s[1] &lt;-> s[3]</span></div>
<div style="position:absolute;left:72.00px;top:223.92px" class="cls_020"><span class="cls_020">s[3] = s[1];</span></div>
<div style="position:absolute;left:72.00px;top:235.20px" class="cls_020"><span class="cls_020">s[1] = temp;</span></div>
<div style="position:absolute;left:72.00px;top:261.00px" class="cls_006"><span class="cls_006">We executed a million iterations of this string reversal code and recorded the execution times shown in</span></div>
<div style="position:absolute;left:72.00px;top:273.00px" class="cls_036"><span class="cls_036">Figure 11.13</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:153.00px;top:299.16px" class="cls_021"><span class="cls_021">Figure 11.13. Comparing STL speed to home-grown code.</span></div>
<div style="position:absolute;left:72.00px;top:554.16px" class="cls_006"><span class="cls_006">Our brute-force implementation has outperformed the STL solution by a factor of four. The </span><span class="cls_020">reverse()</span></div>
<div style="position:absolute;left:72.00px;top:566.40px" class="cls_006"><span class="cls_006">solution was oblivious to the fact that the sequence length was five characters long. It would have worked</span></div>
<div style="position:absolute;left:72.00px;top:578.52px" class="cls_006"><span class="cls_006">for any sequence length and is consequently more powerful. Our brute-force approach was not nearly as</span></div>
<div style="position:absolute;left:72.00px;top:590.64px" class="cls_006"><span class="cls_006">elegant. It relied heavily on the fact that the sequence was five characters long and would not have worked</span></div>
<div style="position:absolute;left:72.00px;top:602.64px" class="cls_006"><span class="cls_006">on any other sequence length. This is a very focused solution to a very specific task.</span></div>
<div style="position:absolute;left:72.00px;top:628.80px" class="cls_006"><span class="cls_006">This example is a bit contrived, but it does make at least three good points with regard to the STL</span></div>
<div style="position:absolute;left:72.00px;top:640.80px" class="cls_006"><span class="cls_006">performance:</span></div>
<div style="position:absolute;left:90.00px;top:667.20px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   You have to bend over backwards to concoct scenarios in which a home-grown implementation</span></div>
<div style="position:absolute;left:108.00px;top:679.20px" class="cls_006"><span class="cls_006">will outperform the STL.</span></div>
<div style="position:absolute;left:90.00px;top:691.56px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Outperforming the STL is possible.</span></div>
<div style="position:absolute;left:90.00px;top:703.92px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   If you are planning to outperform an STL-based solution, you'd better know something about the</span></div>
<div style="position:absolute;left:108.00px;top:715.92px" class="cls_006"><span class="cls_006">domain that the STL doesn't. Otherwise, you'd better invest your time elsewhere.</span></div>
<div style="position:absolute;left:72.00px;top:742.08px" class="cls_006"><span class="cls_006">We can make an even stronger statement with regard to surpassing the STL performance. Our claim is that</span></div>
<div style="position:absolute;left:72.00px;top:754.08px" class="cls_006"><span class="cls_006">no matter how good the implementation is, there are always computational scenarios that expose it as</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">111</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:106500px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background126.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">suboptimal. It cannot be everything to everybody all the time. Take the list container, for example. Among</span></div>
<div style="position:absolute;left:72.00px;top:83.52px" class="cls_006"><span class="cls_006">other things, the list container supports insertion, deletion, and a </span><span class="cls_020">size()</span><span class="cls_006"> member function that returns the</span></div>
<div style="position:absolute;left:72.00px;top:96.24px" class="cls_006"><span class="cls_006">number of elements currently stored in the list. When implementing the </span><span class="cls_020">size()</span><span class="cls_006"> member function we</span></div>
<div style="position:absolute;left:72.00px;top:108.60px" class="cls_006"><span class="cls_006">basically have two design options [</span><span class="cls_036">BM97</span><span class="cls_006">]:</span></div>
<div style="position:absolute;left:90.00px;top:134.64px" class="cls_006"><span class="cls_006">1.   We can define a data member field that will keep track of the current list size. This member will</span></div>
<div style="position:absolute;left:108.00px;top:146.76px" class="cls_006"><span class="cls_006">eagerly be evaluated and updated for every list insertion or deletion operation. This mandatory</span></div>
<div style="position:absolute;left:108.00px;top:159.36px" class="cls_006"><span class="cls_006">update makes the insertion and deletion somewhat slower, but the </span><span class="cls_020">size()</span><span class="cls_006"> function is extremely</span></div>
<div style="position:absolute;left:108.00px;top:171.60px" class="cls_006"><span class="cls_006">fast (constant time).</span></div>
<div style="position:absolute;left:90.00px;top:183.72px" class="cls_006"><span class="cls_006">2.   Compute the size only when requested. Insertions and deletions will be faster as they will not</span></div>
<div style="position:absolute;left:108.00px;top:196.32px" class="cls_006"><span class="cls_006">update the current size, but the </span><span class="cls_020">size()</span><span class="cls_006"> operation will be much slower. The </span><span class="cls_020">size()</span><span class="cls_006"> computation</span></div>
<div style="position:absolute;left:108.00px;top:208.56px" class="cls_006"><span class="cls_006">will necessitate a sequential walk to count the number of elements currently on the list.</span></div>
<div style="position:absolute;left:72.00px;top:234.72px" class="cls_006"><span class="cls_006">An STL implementation has to choose between those two design options. No matter what choice is made,</span></div>
<div style="position:absolute;left:72.00px;top:246.72px" class="cls_006"><span class="cls_006">there's always a scenario where performance will suffer. A workload dominated by insertions and deletions</span></div>
<div style="position:absolute;left:72.00px;top:259.32px" class="cls_006"><span class="cls_006">would benefit from design option 1. On the other hand, a workload that performs frequent </span><span class="cls_020">size()</span></div>
<div style="position:absolute;left:72.00px;top:271.56px" class="cls_006"><span class="cls_006">operations on a large list will benefit from option 2. For that reason, the possibility of improving upon the</span></div>
<div style="position:absolute;left:72.00px;top:283.68px" class="cls_006"><span class="cls_006">STL performance is always there, in theory.</span></div>
<div style="position:absolute;left:72.00px;top:337.44px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:369.00px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The STL is an uncommon combination of abstraction, flexibility, and efficiency.</span></div>
<div style="position:absolute;left:90.00px;top:381.36px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Depending on your application, some containers are more efficient than others for a particular</span></div>
<div style="position:absolute;left:108.00px;top:393.48px" class="cls_006"><span class="cls_006">usage pattern.</span></div>
<div style="position:absolute;left:90.00px;top:405.72px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Unless you know something about the problem domain that the STL doesn't, it is unlikely that you</span></div>
<div style="position:absolute;left:108.00px;top:417.84px" class="cls_006"><span class="cls_006">will beat the performance of an STL implementation by a wide enough margin to justify the effort.</span></div>
<div style="position:absolute;left:90.00px;top:430.20px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   It is possible, however, to exceed the performance of an STL implementation in some specific</span></div>
<div style="position:absolute;left:108.00px;top:442.20px" class="cls_006"><span class="cls_006">scenarios.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">112</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:107352px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background127.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 12. Reference Counting</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">The principle of entropy applies to software just as well as it does to the physical world—all entities tend</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">to disintegrate over time. A software project may start as a small-scale prototype of clear design and</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">simple implementation. Those select few prototypes that make it to the marketplace will often undergo</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">rapid expansion. This is usually in response to an avalanche of customer requests for additional (and</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">sometimes esoteric) new features, as well as defects. New development combined with bug fixes tend to</span></div>
<div style="position:absolute;left:72.00px;top:178.32px" class="cls_006"><span class="cls_006">wreak havoc on the original crystal-clear design. Over time, the clarity of the design and implementation</span></div>
<div style="position:absolute;left:72.00px;top:190.32px" class="cls_006"><span class="cls_006">evaporates through maintenance and frequent release cycles. Software inevitably tends towards chaos. The</span></div>
<div style="position:absolute;left:72.00px;top:202.44px" class="cls_006"><span class="cls_006">only factor separating the good ones from the not-so-good ones is the rate of decay.</span></div>
<div style="position:absolute;left:72.00px;top:228.48px" class="cls_006"><span class="cls_006">One of the major difficulties with chaotic software is memory corruption. Allocated memory flows through</span></div>
<div style="position:absolute;left:72.00px;top:240.60px" class="cls_006"><span class="cls_006">the system by way of pointer passing. Pointers are being passed among modules and threads. In a chaotic</span></div>
<div style="position:absolute;left:72.00px;top:252.60px" class="cls_006"><span class="cls_006">software system this will result in two major difficulties:</span></div>
<div style="position:absolute;left:90.00px;top:279.00px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Memory leaks. This happens when memory is never freed and will, over time, bring the</span></div>
<div style="position:absolute;left:108.00px;top:291.00px" class="cls_006"><span class="cls_006">application down when its consumption of memory gets out of hand.</span></div>
<div style="position:absolute;left:90.00px;top:303.36px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Premature deletion. When ownership of a memory pointer is not clear, it may result in memory</span></div>
<div style="position:absolute;left:108.00px;top:315.48px" class="cls_006"><span class="cls_006">being accessed after it was already deleted, resulting in immediate catastrophic failure.</span></div>
<div style="position:absolute;left:72.00px;top:341.52px" class="cls_006"><span class="cls_006">Fortunately, C++ offers a solution to both problems. C++ allows you to control all points of object creation,</span></div>
<div style="position:absolute;left:72.00px;top:353.52px" class="cls_006"><span class="cls_006">destruction, copy, and assignment. You can leverage that control to develop a form of garbage collection</span></div>
<div style="position:absolute;left:72.00px;top:365.64px" class="cls_006"><span class="cls_006">called </span><span class="cls_007">reference counting</span><span class="cls_006">. The basic idea is to transfer the object destruction responsibility from the client</span></div>
<div style="position:absolute;left:72.00px;top:377.76px" class="cls_006"><span class="cls_006">code to the object itself. The object keeps track of the current number of references to it and destroys itself</span></div>
<div style="position:absolute;left:72.00px;top:389.76px" class="cls_006"><span class="cls_006">when the reference count reaches zero. In other words, the object destroys itself when nobody is using it</span></div>
<div style="position:absolute;left:72.00px;top:401.88px" class="cls_006"><span class="cls_006">any longer. With the vast majority of software defects being traced back to memory corruption, reference</span></div>
<div style="position:absolute;left:72.00px;top:414.00px" class="cls_006"><span class="cls_006">counting is a very important technique in the C++ arsenal.</span></div>
<div style="position:absolute;left:72.00px;top:440.04px" class="cls_006"><span class="cls_006">Reference counting is also touted as a performance optimization. It is claimed that reference counting can</span></div>
<div style="position:absolute;left:72.00px;top:452.04px" class="cls_006"><span class="cls_006">reduce the consumption of memory as well as CPU cycles. Consider an object containing a member</span></div>
<div style="position:absolute;left:72.00px;top:464.16px" class="cls_006"><span class="cls_006">pointing at heap storage. What happens when you copy or assign this object? The simplest implementation</span></div>
<div style="position:absolute;left:72.00px;top:476.28px" class="cls_006"><span class="cls_006">is to perform a deep copy giving each object an identical private copy of heap storage. For example, take a</span></div>
<div style="position:absolute;left:72.00px;top:488.76px" class="cls_006"><span class="cls_006">naive implementation of </span><span class="cls_020">MyString</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:514.80px" class="cls_020"><span class="cls_020">class MyString {</span></div>
<div style="position:absolute;left:72.00px;top:526.08px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:548.76px" class="cls_020"><span class="cls_020">MyString& operator=(const MyString& rhs);</span></div>
<div style="position:absolute;left:72.00px;top:571.44px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:582.72px" class="cls_020"><span class="cls_020">char *pData;</span></div>
<div style="position:absolute;left:72.00px;top:594.12px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:616.68px" class="cls_020"><span class="cls_020">MyString& MyString::operator=(const MyString& rhs)</span></div>
<div style="position:absolute;left:72.00px;top:628.08px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:639.36px" class="cls_020"><span class="cls_020">if (this == &rhs) return *this;</span></div>
<div style="position:absolute;left:96.00px;top:650.76px" class="cls_020"><span class="cls_020">delete [] pdata;</span></div>
<div style="position:absolute;left:96.00px;top:662.04px" class="cls_020"><span class="cls_020">int length = strlen(rhs.pData) + 1;</span></div>
<div style="position:absolute;left:317.96px;top:662.04px" class="cls_020"><span class="cls_020">// Include the terminating</span></div>
<div style="position:absolute;left:317.96px;top:673.32px" class="cls_020"><span class="cls_020">// null</span></div>
<div style="position:absolute;left:96.00px;top:684.72px" class="cls_020"><span class="cls_020">pdata = new char[length];</span></div>
<div style="position:absolute;left:293.96px;top:684.72px" class="cls_020"><span class="cls_020">// Make room for the new array</span></div>
<div style="position:absolute;left:96.00px;top:696.00px" class="cls_020"><span class="cls_020">memcpy(pData, rhs.pData, length];// Copy the characters from the</span></div>
<div style="position:absolute;left:293.96px;top:707.40px" class="cls_020"><span class="cls_020">// right-hand-side object</span></div>
<div style="position:absolute;left:96.00px;top:718.68px" class="cls_020"><span class="cls_020">return *this;</span></div>
<div style="position:absolute;left:72.00px;top:729.96px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:756.24px" class="cls_006"><span class="cls_006">When you assign one </span><span class="cls_020">MyString</span><span class="cls_006"> object to another, as in</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">113</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:108204px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background128.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">MyString p,s;</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">p = s = "TWO";</span></div>
<div style="position:absolute;left:72.00px;top:107.52px" class="cls_006"><span class="cls_006">you end up with the picture in </span><span class="cls_036">Figure 12.1</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:210.00px;top:133.80px" class="cls_021"><span class="cls_021">Figure 12.1. Duplicating resources.</span></div>
<div style="position:absolute;left:72.00px;top:334.92px" class="cls_006"><span class="cls_006">This seems wasteful both in terms of memory utilization as well as the CPU cycles it takes to allocate heap</span></div>
<div style="position:absolute;left:72.00px;top:347.04px" class="cls_006"><span class="cls_006">memory and copy the string content. In theory, it would be cheaper if we utilized reference counting to</span></div>
<div style="position:absolute;left:72.00px;top:359.16px" class="cls_006"><span class="cls_006">have both objects point to the same memory resource.</span></div>
<div style="position:absolute;left:72.00px;top:385.20px" class="cls_006"><span class="cls_006">There is no doubt that reference counting is always a winner in reducing memory usage. It is not clear,</span></div>
<div style="position:absolute;left:72.00px;top:397.32px" class="cls_006"><span class="cls_006">however, that it is always an execution speed winner. This is the topic of this chapter: When does reference</span></div>
<div style="position:absolute;left:72.00px;top:409.32px" class="cls_006"><span class="cls_006">counting help execution speed and under what circumstances does it actually hurt?</span></div>
<div style="position:absolute;left:72.00px;top:435.36px" class="cls_006"><span class="cls_006">An intelligent discussion of reference counting performance requires a rudimentary grasp of the</span></div>
<div style="position:absolute;left:72.00px;top:447.48px" class="cls_006"><span class="cls_006">implementation details, which we cover next.</span></div>
<div style="position:absolute;left:72.00px;top:501.24px" class="cls_016"><span class="cls_016">Implementation Details</span></div>
<div style="position:absolute;left:72.00px;top:532.56px" class="cls_006"><span class="cls_006">Implementing reference counting is a delicate, nontrivial task. The same goes for explaining it. Instead of</span></div>
<div style="position:absolute;left:72.00px;top:544.68px" class="cls_006"><span class="cls_006">re-inventing the wheel, we chose to base our performance discussion on the reference counting</span></div>
<div style="position:absolute;left:72.00px;top:556.80px" class="cls_006"><span class="cls_006">implementation developed by Meyers in item 29 of "More Effective C++" [</span><span class="cls_036">Mey96</span><span class="cls_006">], for several reasons:</span></div>
<div style="position:absolute;left:90.00px;top:583.08px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   It is an efficient implementation, given what it set out to accomplish.</span></div>
<div style="position:absolute;left:90.00px;top:595.44px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   It is explained very well in [</span><span class="cls_036">Mey96</span><span class="cls_006">]. You may refer to it for more details than we provide here.</span></div>
<div style="position:absolute;left:90.00px;top:607.68px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Many people may already be familiar with this particular implementation.</span></div>
<div style="position:absolute;left:72.00px;top:634.32px" class="cls_006"><span class="cls_006">Let's start with a </span><span class="cls_020">Widget</span><span class="cls_006"> class and evolve it into a reference-counted one. The </span><span class="cls_020">Widget</span><span class="cls_006"> class contains a</span></div>
<div style="position:absolute;left:72.00px;top:647.04px" class="cls_006"><span class="cls_006">member pointing to heap memory (Meyers uses a </span><span class="cls_020">String</span><span class="cls_006"> class in his initial demonstration of the concept):</span></div>
<div style="position:absolute;left:72.00px;top:673.08px" class="cls_020"><span class="cls_020">class Widget {</span></div>
<div style="position:absolute;left:72.00px;top:684.36px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:695.76px" class="cls_020"><span class="cls_020">Widget(int size);</span></div>
<div style="position:absolute;left:96.00px;top:707.04px" class="cls_020"><span class="cls_020">Widget(const Widget& rhs);</span></div>
<div style="position:absolute;left:96.00px;top:718.32px" class="cls_020"><span class="cls_020">~Widget();</span></div>
<div style="position:absolute;left:96.00px;top:741.00px" class="cls_020"><span class="cls_020">Widget& operator=(const Widget& rhs);</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">114</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:109056px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background129.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">void doThis();</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">int showThat() const;</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">char *somePtr;</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">The first step towards reference counting is adding a counter member to </span><span class="cls_020">Widget</span><span class="cls_006">. The counter will keep</span></div>
<div style="position:absolute;left:72.00px;top:154.80px" class="cls_006"><span class="cls_006">track of the number of references to a particular </span><span class="cls_020">Widget</span><span class="cls_006"> object:</span></div>
<div style="position:absolute;left:72.00px;top:180.84px" class="cls_020"><span class="cls_020">class Widget {</span></div>
<div style="position:absolute;left:125.99px;top:192.12px" class="cls_020"><span class="cls_020">// As before</span></div>
<div style="position:absolute;left:72.00px;top:203.52px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:214.80px" class="cls_020"><span class="cls_020">char *somePtr;</span></div>
<div style="position:absolute;left:96.00px;top:226.08px" class="cls_020"><span class="cls_020">int  refCount;</span></div>
<div style="position:absolute;left:72.00px;top:237.48px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:263.64px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">Widget</span><span class="cls_006"> object will destroy itself when its </span><span class="cls_020">refCount</span><span class="cls_006"> reaches 0. The next step introduces the</span></div>
<div style="position:absolute;left:72.00px;top:276.48px" class="cls_006"><span class="cls_006">reference-counted </span><span class="cls_020">Widget</span><span class="cls_006"> class:</span></div>
<div style="position:absolute;left:72.00px;top:302.40px" class="cls_020"><span class="cls_020">class RCWidget { // Reference-counted Widget class</span></div>
<div style="position:absolute;left:72.00px;top:313.68px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:325.08px" class="cls_020"><span class="cls_020">RCWidget(int size) : value(new Widget(size)) {}</span></div>
<div style="position:absolute;left:96.00px;top:347.76px" class="cls_020"><span class="cls_020">void doThis() { value->doThis(); }</span></div>
<div style="position:absolute;left:96.00px;top:359.04px" class="cls_020"><span class="cls_020">int showThat() const {return value->showThat();}</span></div>
<div style="position:absolute;left:72.00px;top:370.32px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:381.72px" class="cls_020"><span class="cls_020">Widget *value;</span></div>
<div style="position:absolute;left:72.00px;top:393.00px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:419.28px" class="cls_020"><span class="cls_020">RCWidget</span><span class="cls_006"> acts as a </span><span class="cls_020">Widget</span><span class="cls_006"> proxy. It exposes an identical interface and simply forwards the real work to</span></div>
<div style="position:absolute;left:72.00px;top:432.00px" class="cls_006"><span class="cls_006">the </span><span class="cls_020">Widget</span><span class="cls_006"> object to which it points. This is the basic idea, shown in </span><span class="cls_036">Figure 12.2</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:127.92px;top:457.56px" class="cls_021"><span class="cls_021">Figure 12.2. A simple design for a reference-counted </span><span class="cls_024">Widget</span><span class="cls_021"> class.</span></div>
<div style="position:absolute;left:72.00px;top:576.84px" class="cls_006"><span class="cls_006">The discussion so far was an over-simplification. Meyers' implementation is more sophisticated. He</span></div>
<div style="position:absolute;left:72.00px;top:589.44px" class="cls_006"><span class="cls_006">embedded a smart pointer (see item 28 in [</span><span class="cls_036">Mey96</span><span class="cls_006">]) in </span><span class="cls_020">RCWidget</span><span class="cls_006"> instead of a dumb pointer, which we</span></div>
<div style="position:absolute;left:72.00px;top:602.28px" class="cls_006"><span class="cls_006">showed. He also had the </span><span class="cls_020">Widget</span><span class="cls_006"> publicly derived from an </span><span class="cls_020">RCObject</span><span class="cls_006"> class, which is a base class for all</span></div>
<div style="position:absolute;left:72.00px;top:615.00px" class="cls_006"><span class="cls_006">reference-counted classes. </span><span class="cls_020">RCObject</span><span class="cls_006"> encapsulates the manipulation of the reference count variable.</span></div>
<div style="position:absolute;left:72.00px;top:627.36px" class="cls_006"><span class="cls_006">Meyers' implementation looks like </span><span class="cls_036">Figure 12.3</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:88.32px;top:653.52px" class="cls_021"><span class="cls_021">Figure 12.3. Adding inheritance and smart pointer to the reference-counting design.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">115</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:109908px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background130.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:321.96px" class="cls_006"><span class="cls_006">This was the high-level view of the reference-counting design. We now proceed to the implementation</span></div>
<div style="position:absolute;left:72.00px;top:334.44px" class="cls_006"><span class="cls_006">details. First, we replace the </span><span class="cls_020">Widget</span><span class="cls_006"> with a more concrete example that is easier to relate to. The </span><span class="cls_020">BigInt</span></div>
<div style="position:absolute;left:72.00px;top:347.28px" class="cls_006"><span class="cls_006">class is borrowed from Tom Cargil's "C++ Programming Style" [</span><span class="cls_036">Car92</span><span class="cls_006">]. The </span><span class="cls_020">BigInt</span><span class="cls_006"> class represents</span></div>
<div style="position:absolute;left:72.00px;top:359.64px" class="cls_006"><span class="cls_006">positive integers as binary-coded decimals. For example, the number 123 is internally represented by a 3-</span></div>
<div style="position:absolute;left:72.00px;top:372.12px" class="cls_006"><span class="cls_006">byte character array, each byte representing one digit. It allows you to create and manipulate </span><span class="cls_020">BigInt</span></div>
<div style="position:absolute;left:72.00px;top:384.48px" class="cls_006"><span class="cls_006">objects as in the following code.</span></div>
<div style="position:absolute;left:72.00px;top:410.16px" class="cls_020"><span class="cls_020">BigInt a = 123;</span></div>
<div style="position:absolute;left:72.00px;top:421.56px" class="cls_020"><span class="cls_020">BigInt b = "456";</span></div>
<div style="position:absolute;left:72.00px;top:432.84px" class="cls_020"><span class="cls_020">BigInt c = a + b;</span></div>
<div style="position:absolute;left:72.00px;top:459.12px" class="cls_020"><span class="cls_020">BigInt</span><span class="cls_006"> is a good candidate for a reference counting discussion since it uses heap memory to store its</span></div>
<div style="position:absolute;left:72.00px;top:471.84px" class="cls_006"><span class="cls_006">digits. The implementation of </span><span class="cls_020">BigInt</span><span class="cls_006"> follows and is almost identical to the original [</span><span class="cls_036">Car92</span><span class="cls_006">]:</span></div>
<div style="position:absolute;left:72.00px;top:497.76px" class="cls_020"><span class="cls_020">class BigInt {</span></div>
<div style="position:absolute;left:72.00px;top:509.16px" class="cls_020"><span class="cls_020">friend BigInt operator+ (const BigInt&, const BigInt&);</span></div>
<div style="position:absolute;left:72.00px;top:520.44px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:531.72px" class="cls_020"><span class="cls_020">BigInt (const char *);</span></div>
<div style="position:absolute;left:96.00px;top:543.12px" class="cls_020"><span class="cls_020">BigInt(unsigned = 0);</span></div>
<div style="position:absolute;left:96.00px;top:554.40px" class="cls_020"><span class="cls_020">BigInt (const BigInt&);</span></div>
<div style="position:absolute;left:96.00px;top:565.80px" class="cls_020"><span class="cls_020">BigInt& operator= (const BigInt&);</span></div>
<div style="position:absolute;left:96.00px;top:577.08px" class="cls_020"><span class="cls_020">BigInt& operator+= (const BigInt&);</span></div>
<div style="position:absolute;left:96.00px;top:588.36px" class="cls_020"><span class="cls_020">~BigInt();</span></div>
<div style="position:absolute;left:96.00px;top:611.04px" class="cls_020"><span class="cls_020">char *getDigits() const { return digits; }</span></div>
<div style="position:absolute;left:96.00px;top:622.44px" class="cls_020"><span class="cls_020">unsigned getNdigits() const { return ndigits; }</span></div>
<div style="position:absolute;left:72.00px;top:645.12px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:656.40px" class="cls_020"><span class="cls_020">char *digits;</span></div>
<div style="position:absolute;left:96.00px;top:667.68px" class="cls_020"><span class="cls_020">unsigned ndigits;</span></div>
<div style="position:absolute;left:96.00px;top:679.08px" class="cls_020"><span class="cls_020">unsigned size;</span></div>
<div style="position:absolute;left:323.95px;top:679.08px" class="cls_020"><span class="cls_020">// size of allocated string</span></div>
<div style="position:absolute;left:96.00px;top:690.36px" class="cls_020"><span class="cls_020">BigInt (const BigInt&, const BigInt&);// operational ctor</span></div>
<div style="position:absolute;left:96.00px;top:701.76px" class="cls_020"><span class="cls_020">char fetch(unsigned i) const;</span></div>
<div style="position:absolute;left:72.00px;top:713.04px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">116</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:110760px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background131.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">In the course of our reference counting discussion we are going to utilize only a subset of the </span><span class="cls_020">BigInt</span></div>
<div style="position:absolute;left:72.00px;top:83.76px" class="cls_006"><span class="cls_006">implementation. That subset consists of one constructor, destructor, and an assignment operator. It will</span></div>
<div style="position:absolute;left:72.00px;top:95.76px" class="cls_006"><span class="cls_006">suffice to familiarize yourself with these three.</span></div>
<div style="position:absolute;left:72.00px;top:121.56px" class="cls_020"><span class="cls_020">BigInt::BigInt (unsigned u)</span></div>
<div style="position:absolute;left:72.00px;top:132.84px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:144.12px" class="cls_020"><span class="cls_020">unsigned v = u;</span></div>
<div style="position:absolute;left:96.00px;top:166.80px" class="cls_020"><span class="cls_020">for (ndigits = 1; (v/=10) > 0; ++ndigits) {</span></div>
<div style="position:absolute;left:119.99px;top:178.20px" class="cls_020"><span class="cls_020">;</span></div>
<div style="position:absolute;left:96.00px;top:189.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:212.16px" class="cls_020"><span class="cls_020">digits = new char[size=ndigits];</span></div>
<div style="position:absolute;left:96.00px;top:234.84px" class="cls_020"><span class="cls_020">for ( unsigned i = 0; i &lt; ndigits; ++i) {</span></div>
<div style="position:absolute;left:119.99px;top:246.12px" class="cls_020"><span class="cls_020">digits[i] = u%10;</span></div>
<div style="position:absolute;left:119.99px;top:257.40px" class="cls_020"><span class="cls_020">u /= 10;</span></div>
<div style="position:absolute;left:96.00px;top:268.80px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:280.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:291.48px" class="cls_020"><span class="cls_020">BigInt::~BigInt()</span></div>
<div style="position:absolute;left:72.00px;top:302.76px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:314.04px" class="cls_020"><span class="cls_020">delete [] digits;</span></div>
<div style="position:absolute;left:72.00px;top:325.44px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:348.12px" class="cls_020"><span class="cls_020">BigInt& BigInt::operator= (const BigInt& rhs)</span></div>
<div style="position:absolute;left:72.00px;top:359.40px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:370.68px" class="cls_020"><span class="cls_020">if (this == &rhs) return *this;</span></div>
<div style="position:absolute;left:96.00px;top:382.08px" class="cls_020"><span class="cls_020">ndigits = rhs.ndigits;</span></div>
<div style="position:absolute;left:96.00px;top:393.36px" class="cls_020"><span class="cls_020">if (ndigits > size) {</span></div>
<div style="position:absolute;left:119.99px;top:404.76px" class="cls_020"><span class="cls_020">delete [] digits;</span></div>
<div style="position:absolute;left:119.99px;top:416.04px" class="cls_020"><span class="cls_020">digits = new char[size = ndigits];</span></div>
<div style="position:absolute;left:96.00px;top:427.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:450.00px" class="cls_020"><span class="cls_020">for (unsigned i = 0; i &lt; ndigits; ++i) {</span></div>
<div style="position:absolute;left:119.99px;top:461.40px" class="cls_020"><span class="cls_020">digits[i] = rhs.digits[i];</span></div>
<div style="position:absolute;left:96.00px;top:472.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:495.36px" class="cls_020"><span class="cls_020">return *this;</span></div>
<div style="position:absolute;left:72.00px;top:506.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:532.92px" class="cls_006"><span class="cls_006">The rest of the </span><span class="cls_020">BigInt</span><span class="cls_006"> implementation will not play a role in our discussion. It is given here for the sake</span></div>
<div style="position:absolute;left:72.00px;top:545.16px" class="cls_006"><span class="cls_006">of completeness:</span></div>
<div style="position:absolute;left:72.00px;top:570.84px" class="cls_020"><span class="cls_020">BigInt::BigInt (const char *s)</span></div>
<div style="position:absolute;left:72.00px;top:582.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:593.52px" class="cls_020"><span class="cls_020">if (s[0] == '\0') {</span></div>
<div style="position:absolute;left:119.99px;top:604.92px" class="cls_020"><span class="cls_020">s = "0";</span></div>
<div style="position:absolute;left:96.00px;top:616.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:638.88px" class="cls_020"><span class="cls_020">size = ndigits = strlen(s);</span></div>
<div style="position:absolute;left:96.00px;top:650.16px" class="cls_020"><span class="cls_020">digits = new char[size];</span></div>
<div style="position:absolute;left:96.00px;top:661.56px" class="cls_020"><span class="cls_020">for ( unsigned i = 0; i &lt; ndigits; ++i) {</span></div>
<div style="position:absolute;left:119.99px;top:672.84px" class="cls_020"><span class="cls_020">digits[i] = s[ndigits-1-i] - '0';</span></div>
<div style="position:absolute;left:96.00px;top:684.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:695.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:718.20px" class="cls_020"><span class="cls_020">BigInt::BigInt(const BigInt& copyFrom)</span></div>
<div style="position:absolute;left:317.96px;top:718.20px" class="cls_020"><span class="cls_020">// Copy constructor</span></div>
<div style="position:absolute;left:72.00px;top:729.48px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:740.76px" class="cls_020"><span class="cls_020">size = ndigits = copyFrom.ndigits;</span></div>
<div style="position:absolute;left:96.00px;top:752.16px" class="cls_020"><span class="cls_020">digits = new char[size];</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:111612px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background132.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">for ( unsigned i = 0; i &lt; ndigits; ++i) {</span></div>
<div style="position:absolute;left:119.99px;top:93.24px" class="cls_020"><span class="cls_020">digits[i] = copyFrom.digits[i];</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:138.48px" class="cls_020"><span class="cls_020">// Operational constructor: BigInt = left + right</span></div>
<div style="position:absolute;left:72.00px;top:149.88px" class="cls_020"><span class="cls_020">BigInt::BigInt (const BigInt& left, const BigInt& right)</span></div>
<div style="position:absolute;left:72.00px;top:161.16px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:172.56px" class="cls_020"><span class="cls_020">size = 1 + (left.ndigits > right.ndigits ?</span></div>
<div style="position:absolute;left:119.99px;top:183.84px" class="cls_020"><span class="cls_020">left.ndigits : right.ndigits);</span></div>
<div style="position:absolute;left:96.00px;top:195.12px" class="cls_020"><span class="cls_020">digits = new char[size];</span></div>
<div style="position:absolute;left:96.00px;top:206.52px" class="cls_020"><span class="cls_020">ndigits = left.ndigits;</span></div>
<div style="position:absolute;left:96.00px;top:217.80px" class="cls_020"><span class="cls_020">for (unsigned i = 0; i &lt; ndigits; ++i) {</span></div>
<div style="position:absolute;left:119.99px;top:229.20px" class="cls_020"><span class="cls_020">digits[i] = left.digits[i];</span></div>
<div style="position:absolute;left:96.00px;top:240.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:263.16px" class="cls_020"><span class="cls_020">*this += right;</span></div>
<div style="position:absolute;left:72.00px;top:274.44px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:297.12px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:308.40px" class="cls_020"><span class="cls_020">char BigInt::fetch(unsigned i) const</span></div>
<div style="position:absolute;left:72.00px;top:319.80px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:331.08px" class="cls_020"><span class="cls_020">return i &lt; ndigits ? digits[i] : 0;</span></div>
<div style="position:absolute;left:72.00px;top:342.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:365.04px" class="cls_020"><span class="cls_020">BigInt& BigInt::operator+= (const BigInt& rhs)</span></div>
<div style="position:absolute;left:72.00px;top:376.44px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:387.72px" class="cls_020"><span class="cls_020">unsigned max = 1 + (rhs.ndigits > ndigits ?</span></div>
<div style="position:absolute;left:119.99px;top:399.12px" class="cls_020"><span class="cls_020">rhs.ndigits : ndigits);</span></div>
<div style="position:absolute;left:96.00px;top:421.68px" class="cls_020"><span class="cls_020">if (size &lt; max) {</span></div>
<div style="position:absolute;left:119.99px;top:433.08px" class="cls_020"><span class="cls_020">char *d = new char[size=max];</span></div>
<div style="position:absolute;left:119.99px;top:444.36px" class="cls_020"><span class="cls_020">for (unsigned i = 0; i &lt; ndigits; ++i) {</span></div>
<div style="position:absolute;left:143.99px;top:455.76px" class="cls_020"><span class="cls_020">d[i] = digits[i];</span></div>
<div style="position:absolute;left:119.99px;top:467.04px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:119.99px;top:478.32px" class="cls_020"><span class="cls_020">delete [] digits;</span></div>
<div style="position:absolute;left:119.99px;top:489.72px" class="cls_020"><span class="cls_020">digits = d;</span></div>
<div style="position:absolute;left:96.00px;top:501.00px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:523.68px" class="cls_020"><span class="cls_020">while (ndigits &lt; max) {</span></div>
<div style="position:absolute;left:119.99px;top:534.96px" class="cls_020"><span class="cls_020">digits[ndigits++] = 0;</span></div>
<div style="position:absolute;left:96.00px;top:546.36px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:569.04px" class="cls_020"><span class="cls_020">for (unsigned i = 0; i &lt; ndigits; ++i) {</span></div>
<div style="position:absolute;left:119.99px;top:580.32px" class="cls_020"><span class="cls_020">digits[i] += rhs.fetch(i);</span></div>
<div style="position:absolute;left:119.99px;top:591.60px" class="cls_020"><span class="cls_020">if ( digits[i] >= 10) {</span></div>
<div style="position:absolute;left:137.99px;top:603.00px" class="cls_020"><span class="cls_020">digits[i] -= 10;</span></div>
<div style="position:absolute;left:137.99px;top:614.28px" class="cls_020"><span class="cls_020">digits[i+1] += 1;</span></div>
<div style="position:absolute;left:119.99px;top:625.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:636.96px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:659.63px" class="cls_020"><span class="cls_020">if (digits[ndigits-1] == 0) {</span></div>
<div style="position:absolute;left:119.99px;top:670.91px" class="cls_020"><span class="cls_020">--ndigits;</span></div>
<div style="position:absolute;left:96.00px;top:682.31px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:704.87px" class="cls_020"><span class="cls_020">return *this;</span></div>
<div style="position:absolute;left:72.00px;top:716.27px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:727.55px" class="cls_020"><span class="cls_020">ostream& operator&lt;&lt; (ostream& os, BigInt& bi)</span></div>
<div style="position:absolute;left:72.00px;top:738.95px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:750.23px" class="cls_020"><span class="cls_020">char c;</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">118</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:112464px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background133.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">const char *d = bi.getDigits();</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">for (int i = bi.getNdigits() -1; i >= 0; i--) {</span></div>
<div style="position:absolute;left:119.99px;top:115.92px" class="cls_020"><span class="cls_020">c = d[i]+'0';</span></div>
<div style="position:absolute;left:119.99px;top:127.20px" class="cls_020"><span class="cls_020">os &lt;&lt; c;</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:149.88px" class="cls_020"><span class="cls_020">os &lt;&lt; endl;</span></div>
<div style="position:absolute;left:96.00px;top:172.56px" class="cls_020"><span class="cls_020">return os;</span></div>
<div style="position:absolute;left:72.00px;top:183.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:206.52px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:217.80px" class="cls_020"><span class="cls_020">BigInt operator+ (const BigInt& left, const BigInt& right)</span></div>
<div style="position:absolute;left:72.00px;top:229.20px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:240.48px" class="cls_020"><span class="cls_020">return BigInt(left,right);</span></div>
<div style="position:absolute;left:72.00px;top:251.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:278.04px" class="cls_006"><span class="cls_006">To facilitate reference counting we need to associate a reference count with every </span><span class="cls_020">BigInt</span><span class="cls_006"> object. We can</span></div>
<div style="position:absolute;left:72.00px;top:290.76px" class="cls_006"><span class="cls_006">do that by either adding a </span><span class="cls_020">refCount</span><span class="cls_006"> member directly to </span><span class="cls_020">BigInt</span><span class="cls_006"> or inheriting it from a base class.</span></div>
<div style="position:absolute;left:72.00px;top:303.60px" class="cls_006"><span class="cls_006">Meyers chose the latter approach, and we will follow his lead. The </span><span class="cls_020">RCObject</span><span class="cls_006"> class is a base class for</span></div>
<div style="position:absolute;left:72.00px;top:315.96px" class="cls_006"><span class="cls_006">reference-counted objects and encapsulates the reference count variable and its manipulations.</span></div>
<div style="position:absolute;left:72.00px;top:341.64px" class="cls_020"><span class="cls_020">class RCObject {</span></div>
<div style="position:absolute;left:72.00px;top:352.92px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:364.32px" class="cls_020"><span class="cls_020">void addReference() { ++refCount;}</span></div>
<div style="position:absolute;left:96.00px;top:375.60px" class="cls_020"><span class="cls_020">void removeReference() {</span></div>
<div style="position:absolute;left:263.97px;top:375.60px" class="cls_020"><span class="cls_020">if (--refCount == 0) delete this;}</span></div>
<div style="position:absolute;left:96.00px;top:398.28px" class="cls_020"><span class="cls_020">void markUnshareable() { shareable = false;}</span></div>
<div style="position:absolute;left:96.00px;top:409.56px" class="cls_020"><span class="cls_020">bool isShareable() const { return shareable; }</span></div>
<div style="position:absolute;left:96.00px;top:432.24px" class="cls_020"><span class="cls_020">bool isShared() const { return refCount > 1; }</span></div>
<div style="position:absolute;left:72.00px;top:454.92px" class="cls_020"><span class="cls_020">protected:</span></div>
<div style="position:absolute;left:96.00px;top:466.20px" class="cls_020"><span class="cls_020">RCObject() : refCount(0), shareable(true) {}</span></div>
<div style="position:absolute;left:96.00px;top:477.60px" class="cls_020"><span class="cls_020">RCObject(const RCObject& rhs) : refCount(0), shareable(true) {}</span></div>
<div style="position:absolute;left:96.00px;top:488.88px" class="cls_020"><span class="cls_020">RCObject& operator=(const RCObject& rhs) {return *this;}</span></div>
<div style="position:absolute;left:96.00px;top:500.28px" class="cls_020"><span class="cls_020">virtual ~RCObject() {}</span></div>
<div style="position:absolute;left:72.00px;top:522.84px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:534.24px" class="cls_020"><span class="cls_020">int refCount;</span></div>
<div style="position:absolute;left:96.00px;top:545.52px" class="cls_020"><span class="cls_020">bool shareable;</span></div>
<div style="position:absolute;left:72.00px;top:556.92px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:583.08px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">BigInt</span><span class="cls_006"> class must now be modified to inherit from the </span><span class="cls_020">RCObject</span><span class="cls_006"> class:</span></div>
<div style="position:absolute;left:72.00px;top:609.00px" class="cls_020"><span class="cls_020">class BigInt : public RCObject {</span></div>
<div style="position:absolute;left:96.00px;top:620.28px" class="cls_020"><span class="cls_020">// Same as before</span></div>
<div style="position:absolute;left:72.00px;top:631.68px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:657.84px" class="cls_006"><span class="cls_006">We are working our way toward </span><span class="cls_020">RCBigInt</span><span class="cls_006">, which is the reference-counted implementation of </span><span class="cls_020">BigInt</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:670.68px" class="cls_006"><span class="cls_006">Somehow, it needs to point at the real </span><span class="cls_020">BigInt</span><span class="cls_006"> object. You can achieve that with a real (dumb) pointer or a</span></div>
<div style="position:absolute;left:72.00px;top:682.92px" class="cls_006"><span class="cls_006">smart pointer. Meyers elected to go with a smart pointer. (A smart pointer is an object encapsulating a</span></div>
<div style="position:absolute;left:72.00px;top:695.04px" class="cls_006"><span class="cls_006">dumb pointer by overloading the "->" and "*" operators. See [</span><span class="cls_036">Mey96</span><span class="cls_006">] item 28.) This particular smart</span></div>
<div style="position:absolute;left:72.00px;top:707.16px" class="cls_006"><span class="cls_006">pointer is responsible for the reference count bookkeeping:</span></div>
<div style="position:absolute;left:72.00px;top:732.84px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:744.12px" class="cls_020"><span class="cls_020">class RCPtr {</span></div>
<div style="position:absolute;left:72.00px;top:755.52px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">119</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:113316px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background134.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">RCPtr(T *realPtr = 0) : pointee(realPtr) { init();}</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">RCPtr(const RCPtr& rhs) : pointee(rhs.pointee) { init();}</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">~RCPtr() { if (pointee) pointee->removeReference();}</span></div>
<div style="position:absolute;left:96.00px;top:115.92px" class="cls_020"><span class="cls_020">RCPtr& operator=(const RCPtr& rhs);</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">T* operator->() const { return pointee; }</span></div>
<div style="position:absolute;left:96.00px;top:149.88px" class="cls_020"><span class="cls_020">T& operator*() const { return *pointee; }</span></div>
<div style="position:absolute;left:72.00px;top:172.56px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:183.84px" class="cls_020"><span class="cls_020">T *pointee;</span></div>
<div style="position:absolute;left:96.00px;top:195.12px" class="cls_020"><span class="cls_020">void init();</span></div>
<div style="position:absolute;left:72.00px;top:206.52px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:229.20px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:240.48px" class="cls_020"><span class="cls_020">void RCPtr&lt;T>::init()</span></div>
<div style="position:absolute;left:72.00px;top:251.76px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:263.16px" class="cls_020"><span class="cls_020">if (0 == pointee) return;</span></div>
<div style="position:absolute;left:96.00px;top:285.84px" class="cls_020"><span class="cls_020">if (false == pointee->isShareable() ) {</span></div>
<div style="position:absolute;left:119.99px;top:297.12px" class="cls_020"><span class="cls_020">pointee = new T(*pointee);</span></div>
<div style="position:absolute;left:96.00px;top:308.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:331.08px" class="cls_020"><span class="cls_020">pointee->addReference();</span></div>
<div style="position:absolute;left:72.00px;top:342.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:365.04px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:376.44px" class="cls_020"><span class="cls_020">RCPtr&lt;T>& RCPtr&lt;T>::operator=(const RCPtr& rhs)</span></div>
<div style="position:absolute;left:72.00px;top:387.72px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:399.12px" class="cls_020"><span class="cls_020">if (pointee != rhs.pointee) {</span></div>
<div style="position:absolute;left:119.99px;top:410.40px" class="cls_020"><span class="cls_020">if (pointee) pointee->removeReference();</span></div>
<div style="position:absolute;left:119.99px;top:421.68px" class="cls_020"><span class="cls_020">pointee = rhs.pointee;</span></div>
<div style="position:absolute;left:119.99px;top:433.08px" class="cls_020"><span class="cls_020">init();</span></div>
<div style="position:absolute;left:96.00px;top:444.36px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:467.04px" class="cls_020"><span class="cls_020">return *this;</span></div>
<div style="position:absolute;left:72.00px;top:478.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:504.60px" class="cls_006"><span class="cls_006">Finally, we have all the required fragments to assemble a reference counted </span><span class="cls_020">BigInt</span><span class="cls_006">, which we are calling</span></div>
<div style="position:absolute;left:72.00px;top:517.32px" class="cls_020"><span class="cls_020">RCBigInt</span><span class="cls_006">. </span><span class="cls_020">RCBigInt</span><span class="cls_006"> is pretty straightforward. The hard work has already been done in </span><span class="cls_020">RCPtr</span><span class="cls_006"> and</span></div>
<div style="position:absolute;left:72.00px;top:530.16px" class="cls_020"><span class="cls_020">RCObject</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:556.08px" class="cls_020"><span class="cls_020">class RCBigInt {</span></div>
<div style="position:absolute;left:72.00px;top:567.48px" class="cls_020"><span class="cls_020">friend RCBigInt operator+ (const RCBigInt&, const RCBigInt&);</span></div>
<div style="position:absolute;left:72.00px;top:578.76px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:590.16px" class="cls_020"><span class="cls_020">RCBigInt (const char *p) : value (new BigInt(p)) {}</span></div>
<div style="position:absolute;left:96.00px;top:601.44px" class="cls_020"><span class="cls_020">RCBigInt (unsigned u= 0) : value (new BigInt(u)) {}</span></div>
<div style="position:absolute;left:96.00px;top:612.72px" class="cls_020"><span class="cls_020">RCBigInt (const BigInt& bi) : value (new BigInt(bi)) {}</span></div>
<div style="position:absolute;left:96.00px;top:635.40px" class="cls_020"><span class="cls_020">void print() const { value->print(); }</span></div>
<div style="position:absolute;left:72.00px;top:658.08px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:669.36px" class="cls_020"><span class="cls_020">RCPtr&lt;BigInt> value;</span></div>
<div style="position:absolute;left:72.00px;top:680.76px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:703.44px" class="cls_020"><span class="cls_020">inline</span></div>
<div style="position:absolute;left:72.00px;top:714.72px" class="cls_020"><span class="cls_020">RCBigInt operator+ (const RCBigInt& left, const RCBigInt& right)</span></div>
<div style="position:absolute;left:72.00px;top:726.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:737.40px" class="cls_020"><span class="cls_020">return RCBigInt(*(left.value) + *(right.value));</span></div>
<div style="position:absolute;left:72.00px;top:748.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">120</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:114168px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background135.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">In performance testing, </span><span class="cls_020">RCBigInt</span><span class="cls_006"> should shine in workloads dominated by frequent assignments and</span></div>
<div style="position:absolute;left:72.00px;top:84.24px" class="cls_006"><span class="cls_006">copies of </span><span class="cls_020">RCBigInt</span><span class="cls_006"> objects. On the other hand, new </span><span class="cls_020">RCBigInt</span><span class="cls_006"> objects that create a first reference to a</span></div>
<div style="position:absolute;left:72.00px;top:96.96px" class="cls_006"><span class="cls_006">new </span><span class="cls_020">BigInt</span><span class="cls_006"> object have become more expensive in comparison to working with plain </span><span class="cls_020">BigInt</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:109.80px" class="cls_006"><span class="cls_006">Whenever an </span><span class="cls_020">RCBigInt</span><span class="cls_006"> object gives rise to a first </span><span class="cls_020">BigInt</span><span class="cls_006"> reference, it creates a </span><span class="cls_020">BigInt</span><span class="cls_006"> object on the</span></div>
<div style="position:absolute;left:72.00px;top:122.16px" class="cls_006"><span class="cls_006">heap and points to it. This is one cost you don't have to pay with a stack-based (local variable) plain</span></div>
<div style="position:absolute;left:72.00px;top:134.64px" class="cls_020"><span class="cls_020">BigInt</span><span class="cls_006"> object. A similar argument applies to the removal of the last </span><span class="cls_020">BigInt</span><span class="cls_006"> reference. The underlying</span></div>
<div style="position:absolute;left:72.00px;top:147.48px" class="cls_020"><span class="cls_020">BigInt</span><span class="cls_006"> object is freed back to the heap. To quantify those performance gains and losses we developed</span></div>
<div style="position:absolute;left:72.00px;top:160.32px" class="cls_006"><span class="cls_006">assignment and creation test cases and applied them to both </span><span class="cls_020">BigInt</span><span class="cls_006"> and </span><span class="cls_020">RCBigInt</span><span class="cls_006">. The first test</span></div>
<div style="position:absolute;left:72.00px;top:173.16px" class="cls_006"><span class="cls_006">measured the creation and destruction time of </span><span class="cls_020">BigInt</span><span class="cls_006"> objects:</span></div>
<div style="position:absolute;left:72.00px;top:199.08px" class="cls_020"><span class="cls_020">void testBigIntCreate(int n)</span></div>
<div style="position:absolute;left:72.00px;top:210.36px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:233.04px" class="cls_020"><span class="cls_020">GetSystemTime(&t1);</span></div>
<div style="position:absolute;left:96.00px;top:255.72px" class="cls_020"><span class="cls_020">for ( i = 0; i &lt; n; ++i) {</span></div>
<div style="position:absolute;left:119.99px;top:267.00px" class="cls_020"><span class="cls_020">BigInt a = i;</span></div>
<div style="position:absolute;left:119.99px;top:278.40px" class="cls_020"><span class="cls_020">BigInt b = i+1;</span></div>
<div style="position:absolute;left:119.99px;top:289.68px" class="cls_020"><span class="cls_020">BigInt c = i+2;</span></div>
<div style="position:absolute;left:119.99px;top:301.08px" class="cls_020"><span class="cls_020">BigInt d = i+3;</span></div>
<div style="position:absolute;left:96.00px;top:312.36px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:335.04px" class="cls_020"><span class="cls_020">GetSystemTime(&t2);</span></div>
<div style="position:absolute;left:72.00px;top:357.72px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:383.88px" class="cls_006"><span class="cls_006">The equivalent test for </span><span class="cls_020">RCBigInt</span><span class="cls_006"> construction is almost identical to the </span><span class="cls_020">BigInt</span><span class="cls_006"> test. We simply replaced</span></div>
<div style="position:absolute;left:72.00px;top:396.60px" class="cls_006"><span class="cls_006">the </span><span class="cls_020">BigInt</span><span class="cls_006"> objects with </span><span class="cls_020">RCBigInt</span><span class="cls_006"> ones. It is important to note that the following </span><span class="cls_020">RCBigInt</span><span class="cls_006"> test will be</span></div>
<div style="position:absolute;left:72.00px;top:408.96px" class="cls_006"><span class="cls_006">very busy creating first references and then destroying them:</span></div>
<div style="position:absolute;left:72.00px;top:434.64px" class="cls_020"><span class="cls_020">void testRCBigIntCreate(int n)</span></div>
<div style="position:absolute;left:72.00px;top:446.04px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:468.72px" class="cls_020"><span class="cls_020">GetSystemTime(&t1);</span></div>
<div style="position:absolute;left:96.00px;top:491.28px" class="cls_020"><span class="cls_020">for ( i = 0; i &lt; n; ++i) {</span></div>
<div style="position:absolute;left:119.99px;top:502.68px" class="cls_020"><span class="cls_020">RCBigInt a = i;</span></div>
<div style="position:absolute;left:119.99px;top:513.96px" class="cls_020"><span class="cls_020">RCBigInt b = i+1;</span></div>
<div style="position:absolute;left:119.99px;top:525.36px" class="cls_020"><span class="cls_020">RCBigInt c = i+2;</span></div>
<div style="position:absolute;left:119.99px;top:536.64px" class="cls_020"><span class="cls_020">RCBigInt d = i+3;</span></div>
<div style="position:absolute;left:96.00px;top:547.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:570.60px" class="cls_020"><span class="cls_020">GetSystemTime(&t2);</span></div>
<div style="position:absolute;left:72.00px;top:593.28px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:619.44px" class="cls_006"><span class="cls_006">Similarly, we have two corresponding assignment test cases. We show only the first one for </span><span class="cls_020">BigInt</span><span class="cls_006">. The</span></div>
<div style="position:absolute;left:72.00px;top:632.28px" class="cls_006"><span class="cls_006">one for </span><span class="cls_020">RCBigInt</span><span class="cls_006"> is almost identical:</span></div>
<div style="position:absolute;left:72.00px;top:658.20px" class="cls_020"><span class="cls_020">void testBigIntAssign(int n)</span></div>
<div style="position:absolute;left:72.00px;top:669.60px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:692.16px" class="cls_020"><span class="cls_020">BigInt a,b,c;</span></div>
<div style="position:absolute;left:96.00px;top:703.56px" class="cls_020"><span class="cls_020">BigInt d = 1;</span></div>
<div style="position:absolute;left:96.00px;top:726.24px" class="cls_020"><span class="cls_020">GetSystemTime(&t1);</span></div>
<div style="position:absolute;left:96.00px;top:748.80px" class="cls_020"><span class="cls_020">for ( i = 0; i &lt; n; ++i) {</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">121</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:115020px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background136.jpg" width=595 height=842></div>
<div style="position:absolute;left:119.99px;top:70.56px" class="cls_020"><span class="cls_020">a = b = c = d;</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">GetSystemTime(&t2);</span></div>
<div style="position:absolute;left:72.00px;top:127.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:152.88px" class="cls_006"><span class="cls_006">We measured a million iterations of the loop in each of our four test cases. The execution time (in ms) is</span></div>
<div style="position:absolute;left:72.00px;top:165.00px" class="cls_006"><span class="cls_006">given in </span><span class="cls_036">Figures 12.4</span><span class="cls_006"> and </span><span class="cls_036">12.5</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:197.04px;top:190.32px" class="cls_021"><span class="cls_021">Figure 12.4. </span><span class="cls_024">BigInt</span><span class="cls_021"> assignment speed.</span></div>
<div style="position:absolute;left:205.92px;top:461.88px" class="cls_021"><span class="cls_021">Figure 12.5. </span><span class="cls_024">BigInt</span><span class="cls_021"> creation speed.</span></div>
<div style="position:absolute;left:72.00px;top:740.64px" class="cls_006"><span class="cls_006">As expected, the assignment of </span><span class="cls_020">RCBigInt</span><span class="cls_006"> objects was very efficient, almost twice as fast as the one for</span></div>
<div style="position:absolute;left:72.00px;top:753.48px" class="cls_020"><span class="cls_020">BigInt</span><span class="cls_006"> objects. We have the reverse story on object creation and destruction. Creating and destroying</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">122</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:115872px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background137.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_020"><span class="cls_020">BigInt</span><span class="cls_006"> objects was significantly faster than doing the same to </span><span class="cls_020">RCBigInt</span><span class="cls_006"> objects. This should serve as a</span></div>
<div style="position:absolute;left:72.00px;top:83.76px" class="cls_006"><span class="cls_006">reminder that reference counting is not synonymous with performance gains. This was our first encounter</span></div>
<div style="position:absolute;left:72.00px;top:95.76px" class="cls_006"><span class="cls_006">with a scenario in which reference counting inflicted a performance penalty. On the other hand, we also</span></div>
<div style="position:absolute;left:72.00px;top:107.88px" class="cls_006"><span class="cls_006">have a scenario (the assignment test) where reference counting has boosted performance. The natural</span></div>
<div style="position:absolute;left:72.00px;top:120.00px" class="cls_006"><span class="cls_006">question here is, how do you tell one set from the other? The relationship between reference counting and</span></div>
<div style="position:absolute;left:72.00px;top:132.00px" class="cls_006"><span class="cls_006">execution speed is context-sensitive. It depends on a few factors:</span></div>
<div style="position:absolute;left:90.00px;top:158.28px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   What is the magnitude of resource consumption by the target object? If the target object uses</span></div>
<div style="position:absolute;left:108.00px;top:170.40px" class="cls_006"><span class="cls_006">gigantic amounts of memory, for example, a failure to conserve memory will push the limits on</span></div>
<div style="position:absolute;left:108.00px;top:182.52px" class="cls_006"><span class="cls_006">available memory and lead to dramatic performance loss in the form of cache misses and page-</span></div>
<div style="position:absolute;left:108.00px;top:194.52px" class="cls_006"><span class="cls_006">faults.</span></div>
<div style="position:absolute;left:90.00px;top:206.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   How expensive is it to allocate (and deallocate) the resource used by the target object? This is</span></div>
<div style="position:absolute;left:108.00px;top:219.48px" class="cls_006"><span class="cls_006">different from the previous factor. An object such as </span><span class="cls_020">BigInt</span><span class="cls_006"> will typically consume a small</span></div>
<div style="position:absolute;left:108.00px;top:231.72px" class="cls_006"><span class="cls_006">amount of storage and is unlikely to deplete available memory. However, allocating even one byte</span></div>
<div style="position:absolute;left:108.00px;top:243.84px" class="cls_006"><span class="cls_006">from the heap will cost you hundreds of instructions. The same goes for deallocating a single byte.</span></div>
<div style="position:absolute;left:90.00px;top:256.20px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   How many objects are likely to share a single instance of the target object? Sharing is increased by</span></div>
<div style="position:absolute;left:108.00px;top:268.20px" class="cls_006"><span class="cls_006">the use of the assignment operator and copy constructor.</span></div>
<div style="position:absolute;left:90.00px;top:280.56px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   How often do we create (destroy) first (last) references to the target object? Creating a brand-new</span></div>
<div style="position:absolute;left:108.00px;top:292.68px" class="cls_006"><span class="cls_006">reference-counted object using a constructor other than the copy constructor will create a first</span></div>
<div style="position:absolute;left:108.00px;top:304.68px" class="cls_006"><span class="cls_006">reference to the target object. This is expensive. It has more overhead in comparison to creating</span></div>
<div style="position:absolute;left:108.00px;top:316.80px" class="cls_006"><span class="cls_006">the target object. The same argument applies to the removal of a last reference.</span></div>
<div style="position:absolute;left:72.00px;top:342.84px" class="cls_006"><span class="cls_006">On one extreme we may have a situation in which we have many reference-counted instances sharing a</span></div>
<div style="position:absolute;left:72.00px;top:354.96px" class="cls_006"><span class="cls_006">small number of target objects (via the copy constructor and assignment operator), but creation and</span></div>
<div style="position:absolute;left:72.00px;top:366.96px" class="cls_006"><span class="cls_006">destruction of first and last references is limited. The target object is a large consumer of a limited resource,</span></div>
<div style="position:absolute;left:72.00px;top:379.08px" class="cls_006"><span class="cls_006">which in itself is expensive to acquire and unload. This would be the poster-child for a reference-counted</span></div>
<div style="position:absolute;left:72.00px;top:391.20px" class="cls_006"><span class="cls_006">performance boost. On the other extreme, you may have a scenario in which many target objects are</span></div>
<div style="position:absolute;left:72.00px;top:403.20px" class="cls_006"><span class="cls_006">created but their reference counts rarely exceed one or two (indicating little to no sharing). The target</span></div>
<div style="position:absolute;left:72.00px;top:415.32px" class="cls_006"><span class="cls_006">object is a negligible resource consumer, and the resource itself is cheap to obtain and release. In this case,</span></div>
<div style="position:absolute;left:72.00px;top:427.44px" class="cls_006"><span class="cls_006">reference counting is an execution-time loser.</span></div>
<div style="position:absolute;left:72.00px;top:453.48px" class="cls_006"><span class="cls_006">What makes the judgement call so cloudy is that most scenarios will fall between these two extremes.</span></div>
<div style="position:absolute;left:72.00px;top:465.96px" class="cls_006"><span class="cls_006">Even in our </span><span class="cls_020">BigInt</span><span class="cls_006"> example, we could tilt the scales further against reference counting by providing a</span></div>
<div style="position:absolute;left:72.00px;top:478.80px" class="cls_006"><span class="cls_006">memory pool to allocate the storage consumed by the </span><span class="cls_020">BigInt</span><span class="cls_006"> internal buffer. In that case, the cost of</span></div>
<div style="position:absolute;left:72.00px;top:491.64px" class="cls_006"><span class="cls_006">duplicating </span><span class="cls_020">BigInt</span><span class="cls_006"> objects would be significantly reduced, making the case for reference counting even</span></div>
<div style="position:absolute;left:72.00px;top:504.00px" class="cls_006"><span class="cls_006">less appealing from a performance standpoint. The next section provides another implementation variant</span></div>
<div style="position:absolute;left:72.00px;top:516.00px" class="cls_006"><span class="cls_006">that affects the performance balance between a reference-counted and a plain object.</span></div>
<div style="position:absolute;left:72.00px;top:569.76px" class="cls_016"><span class="cls_016">Preexisting Classes</span></div>
<div style="position:absolute;left:72.00px;top:601.68px" class="cls_006"><span class="cls_006">Our previous implementation of a reference-counted </span><span class="cls_020">BigInt</span><span class="cls_006"> class involved some modifications to the</span></div>
<div style="position:absolute;left:72.00px;top:614.40px" class="cls_006"><span class="cls_006">original </span><span class="cls_020">BigInt</span><span class="cls_006"> implementation. That required, of course, that we had the liberty to modify the </span><span class="cls_020">BigInt</span></div>
<div style="position:absolute;left:72.00px;top:626.76px" class="cls_006"><span class="cls_006">source code. This option is not always available. The target class could come from a library whose source</span></div>
<div style="position:absolute;left:72.00px;top:638.88px" class="cls_006"><span class="cls_006">code is not given. We can still implement reference counting for such preexisting, hands-off target classes,</span></div>
<div style="position:absolute;left:72.00px;top:650.88px" class="cls_006"><span class="cls_006">but we need to make some design changes.</span></div>
<div style="position:absolute;left:72.00px;top:677.40px" class="cls_006"><span class="cls_006">Previously, with access to the source code, we added the reference counter to </span><span class="cls_020">BigInt</span><span class="cls_006"> by making </span><span class="cls_020">BigInt</span></div>
<div style="position:absolute;left:72.00px;top:690.24px" class="cls_006"><span class="cls_006">inherit from </span><span class="cls_020">RCObject</span><span class="cls_006">. Now that we cannot touch the </span><span class="cls_020">BigInt</span><span class="cls_006"> implementation, we must introduce a</span></div>
<div style="position:absolute;left:72.00px;top:703.08px" class="cls_006"><span class="cls_006">separate class to hold the reference count and manipulate it. Meyers calls this class the </span><span class="cls_020">CountHolder</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:715.44px" class="cls_006"><span class="cls_006">The modified design is given visually in </span><span class="cls_036">Figure 12.6</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:157.80px;top:740.76px" class="cls_021"><span class="cls_021">Figure 12.6. Reference-counting a pre-existing </span><span class="cls_024">BigInt</span><span class="cls_021">.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">123</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:116724px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background138.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:422.16px" class="cls_006"><span class="cls_006">Other than divorcing the reference count from the </span><span class="cls_020">BigInt</span><span class="cls_006"> class, we also have the </span><span class="cls_020">RCPtr</span><span class="cls_006"> object</span></div>
<div style="position:absolute;left:72.00px;top:435.00px" class="cls_006"><span class="cls_006">(previously embedded in </span><span class="cls_020">RCBigInt</span><span class="cls_006">) replaced by an </span><span class="cls_020">RCIPtr</span><span class="cls_006"> object. </span><span class="cls_020">RCIPtr</span><span class="cls_006"> is a smart pointer just like</span></div>
<div style="position:absolute;left:72.00px;top:447.72px" class="cls_020"><span class="cls_020">RCPtr</span><span class="cls_006">, but it points at </span><span class="cls_020">BigInt</span><span class="cls_006"> indirectly via a pointer to </span><span class="cls_020">CountHolder</span><span class="cls_006">. </span><span class="cls_020">RCPtr</span><span class="cls_006"> used to point directly at</span></div>
<div style="position:absolute;left:72.00px;top:460.56px" class="cls_020"><span class="cls_020">BigInt</span><span class="cls_006">. From an implementation standpoint we have three issues to consider. First, the </span><span class="cls_020">BigInt</span><span class="cls_006"> class</span></div>
<div style="position:absolute;left:72.00px;top:473.40px" class="cls_006"><span class="cls_006">reverts back to its original form and no longer inherits from </span><span class="cls_020">RCObject</span><span class="cls_006">. Second, the </span><span class="cls_020">RCBigInt</span><span class="cls_006"> class now</span></div>
<div style="position:absolute;left:72.00px;top:486.12px" class="cls_006"><span class="cls_006">has an </span><span class="cls_020">RCIPtr</span><span class="cls_006"> member instead of </span><span class="cls_020">RCPtr</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:512.16px" class="cls_020"><span class="cls_020">class RCBigInt {</span></div>
<div style="position:absolute;left:239.97px;top:523.44px" class="cls_020"><span class="cls_020">// The same as before</span></div>
<div style="position:absolute;left:72.00px;top:534.84px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:546.12px" class="cls_020"><span class="cls_020">RCIPtr&lt;BigInt> value;</span></div>
<div style="position:absolute;left:239.97px;top:546.12px" class="cls_020"><span class="cls_020">// RCIPtr not RCPtr</span></div>
<div style="position:absolute;left:72.00px;top:557.40px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:583.68px" class="cls_006"><span class="cls_006">Third, we have to present an implementation of </span><span class="cls_020">RCIPtr</span><span class="cls_006">. The </span><span class="cls_020">RCIPtr</span><span class="cls_006"> implementation also introduces the</span></div>
<div style="position:absolute;left:72.00px;top:596.40px" class="cls_020"><span class="cls_020">CountHolder</span><span class="cls_006"> as a nested class:</span></div>
<div style="position:absolute;left:72.00px;top:622.44px" class="cls_020"><span class="cls_020">template &lt; class T></span></div>
<div style="position:absolute;left:72.00px;top:633.72px" class="cls_020"><span class="cls_020">class RCIPtr {</span></div>
<div style="position:absolute;left:72.00px;top:645.00px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:656.40px" class="cls_020"><span class="cls_020">RCIPtr(T *realPtr = 0);</span></div>
<div style="position:absolute;left:96.00px;top:667.68px" class="cls_020"><span class="cls_020">RCIPtr(const RCIPtr& rhs);</span></div>
<div style="position:absolute;left:96.00px;top:679.08px" class="cls_020"><span class="cls_020">~RCIPtr();</span></div>
<div style="position:absolute;left:96.00px;top:701.64px" class="cls_020"><span class="cls_020">RCIPtr& operator=(const RCIPtr& rhs);</span></div>
<div style="position:absolute;left:96.00px;top:713.04px" class="cls_020"><span class="cls_020">T* operator->() const { return counter->pointee; }</span></div>
<div style="position:absolute;left:96.00px;top:724.32px" class="cls_020"><span class="cls_020">T& operator*() const { return *(counter->pointee); }</span></div>
<div style="position:absolute;left:72.00px;top:747.00px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">124</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:117576px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background139.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">struct CountHolder : public RCObject {</span></div>
<div style="position:absolute;left:119.99px;top:81.84px" class="cls_020"><span class="cls_020">~CountHolder() { delete pointee; }</span></div>
<div style="position:absolute;left:119.99px;top:93.24px" class="cls_020"><span class="cls_020">T *pointee;</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:96.00px;top:127.20px" class="cls_020"><span class="cls_020">RCIPtr&lt;T>::CountHolder *counter;</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">void init();</span></div>
<div style="position:absolute;left:72.00px;top:149.88px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:183.84px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:195.12px" class="cls_020"><span class="cls_020">void RCIPtr&lt;T>::init()</span></div>
<div style="position:absolute;left:72.00px;top:206.52px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:217.80px" class="cls_020"><span class="cls_020">if (0 == counter) return;</span></div>
<div style="position:absolute;left:96.00px;top:240.48px" class="cls_020"><span class="cls_020">if (false == counter->isShareable() ) {</span></div>
<div style="position:absolute;left:119.99px;top:251.76px" class="cls_020"><span class="cls_020">counter = new CountHolder;</span></div>
<div style="position:absolute;left:119.99px;top:263.16px" class="cls_020"><span class="cls_020">counter->pointee = new T(*counter->pointee);</span></div>
<div style="position:absolute;left:96.00px;top:274.44px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:297.12px" class="cls_020"><span class="cls_020">counter->addReference();</span></div>
<div style="position:absolute;left:72.00px;top:308.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:331.08px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:342.48px" class="cls_020"><span class="cls_020">RCIPtr&lt;T>::RCIPtr(T *realPtr)</span></div>
<div style="position:absolute;left:96.00px;top:353.76px" class="cls_020"><span class="cls_020">: counter(new CountHolder)</span></div>
<div style="position:absolute;left:72.00px;top:365.04px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:376.44px" class="cls_020"><span class="cls_020">counter->pointee = realPtr;</span></div>
<div style="position:absolute;left:96.00px;top:387.72px" class="cls_020"><span class="cls_020">init();</span></div>
<div style="position:absolute;left:72.00px;top:399.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:421.68px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:433.08px" class="cls_020"><span class="cls_020">RCIPtr&lt;T>::RCIPtr(const RCIPtr& rhs) : counter(rhs.counter)</span></div>
<div style="position:absolute;left:72.00px;top:444.36px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:455.76px" class="cls_020"><span class="cls_020">init();</span></div>
<div style="position:absolute;left:72.00px;top:467.04px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:489.72px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:501.00px" class="cls_020"><span class="cls_020">RCIPtr&lt;T>::~RCIPtr()</span></div>
<div style="position:absolute;left:72.00px;top:512.40px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:523.68px" class="cls_020"><span class="cls_020">if (counter) counter->removeReference();</span></div>
<div style="position:absolute;left:72.00px;top:534.96px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:557.64px" class="cls_020"><span class="cls_020">template &lt;class T></span></div>
<div style="position:absolute;left:72.00px;top:569.04px" class="cls_020"><span class="cls_020">RCIPtr&lt;T>& RCIPtr&lt;T>::operator=(const RCIPtr& rhs)</span></div>
<div style="position:absolute;left:72.00px;top:580.32px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:591.60px" class="cls_020"><span class="cls_020">if (counter != rhs.counter) {</span></div>
<div style="position:absolute;left:119.99px;top:603.00px" class="cls_020"><span class="cls_020">if (counter) counter->removeReference();</span></div>
<div style="position:absolute;left:119.99px;top:614.28px" class="cls_020"><span class="cls_020">counter = rhs.counter;</span></div>
<div style="position:absolute;left:119.99px;top:625.68px" class="cls_020"><span class="cls_020">init();</span></div>
<div style="position:absolute;left:96.00px;top:636.96px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:659.63px" class="cls_020"><span class="cls_020">return *this;</span></div>
<div style="position:absolute;left:72.00px;top:670.91px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:697.20px" class="cls_006"><span class="cls_006">The implementation of </span><span class="cls_020">RCIPtr&lt;T>::operator=</span><span class="cls_006"> is similar in cost to the corresponding implementation</span></div>
<div style="position:absolute;left:72.00px;top:709.92px" class="cls_006"><span class="cls_006">of </span><span class="cls_020">RCPtr</span><span class="cls_006">. Consequently, the execution speed of the assignment test (</span><span class="cls_020">testRCBigIntAssign</span><span class="cls_006">) has</span></div>
<div style="position:absolute;left:72.00px;top:722.76px" class="cls_006"><span class="cls_006">remained the same for both versions of </span><span class="cls_020">RCBigInt</span><span class="cls_006">. This is not the case with the creation test</span></div>
<div style="position:absolute;left:72.00px;top:735.48px" class="cls_006"><span class="cls_006">(</span><span class="cls_020">testRCBigIntCreate)</span><span class="cls_006">. This test creates first references to new </span><span class="cls_020">BigInt</span><span class="cls_006"> objects and then turns</span></div>
<div style="position:absolute;left:72.00px;top:748.32px" class="cls_006"><span class="cls_006">around and destroys them. The migration from </span><span class="cls_020">RCPtr</span><span class="cls_006"> to </span><span class="cls_020">RCIPtr</span><span class="cls_006"> has made the creation of a first </span><span class="cls_020">BigInt</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">125</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:118428px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background140.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">reference, and its destruction, more expensive. Not only do we need to allocate a new heap-based </span><span class="cls_020">BigInt</span></div>
<div style="position:absolute;left:72.00px;top:84.24px" class="cls_006"><span class="cls_006">object, we also have to allocate a new </span><span class="cls_020">CountHolder</span><span class="cls_006"> object, and we have to delete them upon destruction.</span></div>
<div style="position:absolute;left:72.00px;top:96.96px" class="cls_006"><span class="cls_006">The performance gap between </span><span class="cls_020">BigInt</span><span class="cls_006"> and </span><span class="cls_020">RCBigInt</span><span class="cls_006"> has gotten bigger in this scenario. The new</span></div>
<div style="position:absolute;left:72.00px;top:109.32px" class="cls_006"><span class="cls_006">execution speed of our test is given in </span><span class="cls_036">Figure 12.7</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:205.92px;top:134.64px" class="cls_021"><span class="cls_021">Figure 12.7. </span><span class="cls_024">BigInt</span><span class="cls_021"> creation speed.</span></div>
<div style="position:absolute;left:72.00px;top:443.64px" class="cls_016"><span class="cls_016">Concurrent Reference Counting</span></div>
<div style="position:absolute;left:72.00px;top:475.44px" class="cls_006"><span class="cls_006">We have already investigated two versions of reference counting and established that one (using </span><span class="cls_020">RCPtr</span><span class="cls_006">)</span></div>
<div style="position:absolute;left:72.00px;top:488.28px" class="cls_006"><span class="cls_006">was faster than the other (using </span><span class="cls_020">RCIPtr</span><span class="cls_006">). There's one more important twist on reference counting that we</span></div>
<div style="position:absolute;left:72.00px;top:500.64px" class="cls_006"><span class="cls_006">need to evaluate. The third implementation variant handles reference-counted objects in a multithreaded</span></div>
<div style="position:absolute;left:72.00px;top:512.64px" class="cls_006"><span class="cls_006">execution environment. In that case, multiple threads may access a reference-counted object concurrently.</span></div>
<div style="position:absolute;left:72.00px;top:524.76px" class="cls_006"><span class="cls_006">Therefore, the variable holding the reference count must be protected so that updates are atomic. Atomic</span></div>
<div style="position:absolute;left:72.00px;top:536.88px" class="cls_006"><span class="cls_006">updates require a locking mechanism. We have discussed locking classes in </span><span class="cls_036">Chapter 7</span><span class="cls_006">, and we reproduce</span></div>
<div style="position:absolute;left:72.00px;top:548.88px" class="cls_006"><span class="cls_006">the relevant code subset here:</span></div>
<div style="position:absolute;left:72.00px;top:574.68px" class="cls_020"><span class="cls_020">class MutexLock {</span></div>
<div style="position:absolute;left:72.00px;top:585.96px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:597.24px" class="cls_020"><span class="cls_020">MutexLock() {mutex = CreateMutex(NULL, FALSE,NULL);}</span></div>
<div style="position:absolute;left:96.00px;top:608.64px" class="cls_020"><span class="cls_020">virtual ~MutexLock() {CloseHandle(mutex);}</span></div>
<div style="position:absolute;left:96.00px;top:619.92px" class="cls_020"><span class="cls_020">void lock() {WaitForSingleObject(mutex, INFINITE);}</span></div>
<div style="position:absolute;left:96.00px;top:631.32px" class="cls_020"><span class="cls_020">void unlock() {ReleaseMutex(mutex);}</span></div>
<div style="position:absolute;left:72.00px;top:642.60px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:653.88px" class="cls_020"><span class="cls_020">HANDLE mutex;</span></div>
<div style="position:absolute;left:72.00px;top:665.28px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:691.44px" class="cls_006"><span class="cls_006">Adding concurrency-control to </span><span class="cls_020">RCBigInt</span><span class="cls_006"> requires a one-line change to its class declaration. We are</span></div>
<div style="position:absolute;left:72.00px;top:704.28px" class="cls_006"><span class="cls_006">adding a </span><span class="cls_020">MutexLock</span><span class="cls_006"> template argument to the </span><span class="cls_020">RCIPtr</span><span class="cls_006"> smart pointer:</span></div>
<div style="position:absolute;left:72.00px;top:730.20px" class="cls_020"><span class="cls_020">class RCBigInt {</span></div>
<div style="position:absolute;left:96.00px;top:741.48px" class="cls_020"><span class="cls_020">... // Same as before</span></div>
<div style="position:absolute;left:72.00px;top:752.88px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">126</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:119280px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background141.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">RCIPtr&lt;BigInt, MutexLock> value;// Add MutexLock</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:108.12px" class="cls_006"><span class="cls_006">The task of handling concurrent access has been given to the </span><span class="cls_020">RCIPtr</span><span class="cls_006"> class. We have expanded its</span></div>
<div style="position:absolute;left:72.00px;top:120.36px" class="cls_006"><span class="cls_006">template declaration to allow an additional lock class argument. That lock is used to serialize access to</span></div>
<div style="position:absolute;left:72.00px;top:132.48px" class="cls_006"><span class="cls_006">variables requiring atomic updates:</span></div>
<div style="position:absolute;left:72.00px;top:158.16px" class="cls_020"><span class="cls_020">template &lt; class T, class LOCK></span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_020"><span class="cls_020">class RCIPtr {</span></div>
<div style="position:absolute;left:72.00px;top:180.84px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:72.00px;top:203.52px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:214.80px" class="cls_020"><span class="cls_020">struct CountHolder : public RCObject {</span></div>
<div style="position:absolute;left:119.99px;top:226.08px" class="cls_020"><span class="cls_020">~CountHolder() { delete pointee; }</span></div>
<div style="position:absolute;left:119.99px;top:237.48px" class="cls_020"><span class="cls_020">T *pointee;</span></div>
<div style="position:absolute;left:119.99px;top:248.76px" class="cls_020"><span class="cls_020">LOCK key;</span></div>
<div style="position:absolute;left:96.00px;top:260.16px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:96.00px;top:282.72px" class="cls_020"><span class="cls_020">RCIPtr&lt;T,LOCK>::CountHolder *counter;</span></div>
<div style="position:absolute;left:96.00px;top:294.12px" class="cls_020"><span class="cls_020">void init();</span></div>
<div style="position:absolute;left:72.00px;top:305.40px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:331.68px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">init()</span><span class="cls_006"> method does not bother with concurrency and is unchanged. Atomic access, if necessary, is</span></div>
<div style="position:absolute;left:72.00px;top:344.40px" class="cls_006"><span class="cls_006">going to be handled by the callers of </span><span class="cls_020">init()</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:370.32px" class="cls_020"><span class="cls_020">template &lt;class T, class L></span></div>
<div style="position:absolute;left:72.00px;top:381.72px" class="cls_020"><span class="cls_020">void RCIPtr&lt;T,L>::init()</span></div>
<div style="position:absolute;left:72.00px;top:393.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:404.40px" class="cls_020"><span class="cls_020">if (0 == counter) return;</span></div>
<div style="position:absolute;left:96.00px;top:426.96px" class="cls_020"><span class="cls_020">if (false == counter->isShareable() ) {</span></div>
<div style="position:absolute;left:119.99px;top:438.36px" class="cls_020"><span class="cls_020">T *p = counter->pointee;</span></div>
<div style="position:absolute;left:119.99px;top:449.64px" class="cls_020"><span class="cls_020">counter = new CountHolder;</span></div>
<div style="position:absolute;left:119.99px;top:461.04px" class="cls_020"><span class="cls_020">counter->pointee = new T(*p);</span></div>
<div style="position:absolute;left:96.00px;top:472.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:495.00px" class="cls_020"><span class="cls_020">counter->addReference();</span></div>
<div style="position:absolute;left:72.00px;top:506.28px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:532.08px" class="cls_006"><span class="cls_006">The rest of the methods will manipulate the lock explicitly. The implementation is straightforward—all</span></div>
<div style="position:absolute;left:72.00px;top:544.56px" class="cls_006"><span class="cls_006">operations that require serialization are surrounded by a pair of </span><span class="cls_020">lock()</span><span class="cls_006"> and </span><span class="cls_020">unlock()</span><span class="cls_006"> calls:</span></div>
<div style="position:absolute;left:72.00px;top:570.48px" class="cls_020"><span class="cls_020">template &lt;class T, class L></span></div>
<div style="position:absolute;left:72.00px;top:581.88px" class="cls_020"><span class="cls_020">RCIPtr&lt;T,L>::RCIPtr(T *realPtr)</span></div>
<div style="position:absolute;left:72.00px;top:593.16px" class="cls_020"><span class="cls_020">: counter(new CountHolder)</span></div>
<div style="position:absolute;left:72.00px;top:604.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:615.84px" class="cls_020"><span class="cls_020">counter->pointee = realPtr;</span></div>
<div style="position:absolute;left:96.00px;top:627.12px" class="cls_020"><span class="cls_020">init();</span></div>
<div style="position:absolute;left:72.00px;top:638.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:661.20px" class="cls_020"><span class="cls_020">template &lt;class T, class L></span></div>
<div style="position:absolute;left:72.00px;top:672.48px" class="cls_020"><span class="cls_020">RCIPtr&lt;T, L>::RCIPtr(const RCIPtr& rhs)</span></div>
<div style="position:absolute;left:72.00px;top:683.76px" class="cls_020"><span class="cls_020">: counter(rhs.counter)</span></div>
<div style="position:absolute;left:72.00px;top:695.16px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:706.44px" class="cls_020"><span class="cls_020">if (rhs.counter) rhs.counter->key.lock();</span></div>
<div style="position:absolute;left:96.00px;top:717.84px" class="cls_020"><span class="cls_020">init();</span></div>
<div style="position:absolute;left:96.00px;top:729.12px" class="cls_020"><span class="cls_020">if (rhs.counter) rhs.counter->key.unlock();</span></div>
<div style="position:absolute;left:72.00px;top:740.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:120132px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background142.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">template &lt;class T, class L></span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">RCIPtr&lt;T, L>::~RCIPtr()</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">if (counter) {</span></div>
<div style="position:absolute;left:119.99px;top:115.92px" class="cls_020"><span class="cls_020">if (counter->isShared() {</span></div>
<div style="position:absolute;left:143.99px;top:127.20px" class="cls_020"><span class="cls_020">counter->key.lock();</span></div>
<div style="position:absolute;left:143.99px;top:138.48px" class="cls_020"><span class="cls_020">counter->removeReference();</span></div>
<div style="position:absolute;left:143.99px;top:149.88px" class="cls_020"><span class="cls_020">counter->key.unlock();</span></div>
<div style="position:absolute;left:119.99px;top:161.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:119.99px;top:172.56px" class="cls_020"><span class="cls_020">else</span></div>
<div style="position:absolute;left:143.99px;top:183.84px" class="cls_020"><span class="cls_020">counter->removeReference();</span></div>
<div style="position:absolute;left:96.00px;top:195.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:206.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:229.20px" class="cls_020"><span class="cls_020">template &lt;class T, class L></span></div>
<div style="position:absolute;left:72.00px;top:240.48px" class="cls_020"><span class="cls_020">RCIPtr&lt;T, L>& RCIPtr&lt;T,L>::operator=(const RCIPtr& rhs)</span></div>
<div style="position:absolute;left:72.00px;top:251.76px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:263.16px" class="cls_020"><span class="cls_020">if (counter != rhs.counter) {</span></div>
<div style="position:absolute;left:119.99px;top:274.44px" class="cls_020"><span class="cls_020">if (counter) {</span></div>
<div style="position:absolute;left:143.99px;top:285.84px" class="cls_020"><span class="cls_020">if (counter->isShared() {</span></div>
<div style="position:absolute;left:173.98px;top:297.12px" class="cls_020"><span class="cls_020">counter->key.lock();</span></div>
<div style="position:absolute;left:173.98px;top:308.40px" class="cls_020"><span class="cls_020">counter->removeReference();</span></div>
<div style="position:absolute;left:173.98px;top:319.80px" class="cls_020"><span class="cls_020">counter->key.unlock();</span></div>
<div style="position:absolute;left:143.99px;top:331.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:143.99px;top:342.48px" class="cls_020"><span class="cls_020">else</span></div>
<div style="position:absolute;left:167.98px;top:353.76px" class="cls_020"><span class="cls_020">counter->removeReference();</span></div>
<div style="position:absolute;left:119.99px;top:365.04px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:119.99px;top:387.72px" class="cls_020"><span class="cls_020">counter = rhs.counter;</span></div>
<div style="position:absolute;left:119.99px;top:399.12px" class="cls_020"><span class="cls_020">if (rhs.counter) rhs.counter->key.lock();</span></div>
<div style="position:absolute;left:119.99px;top:410.40px" class="cls_020"><span class="cls_020">init();</span></div>
<div style="position:absolute;left:119.99px;top:421.68px" class="cls_020"><span class="cls_020">if (rhs.counter) rhs.counter->key.unlock();</span></div>
<div style="position:absolute;left:96.00px;top:433.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:455.76px" class="cls_020"><span class="cls_020">return *this;</span></div>
<div style="position:absolute;left:72.00px;top:467.04px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:493.20px" class="cls_006"><span class="cls_006">The additional computations required to provide atomic updates have slightly raised the cost of </span><span class="cls_020">RCBigInt</span></div>
<div style="position:absolute;left:72.00px;top:506.04px" class="cls_006"><span class="cls_006">assignment. The execution-time of our test (</span><span class="cls_020">testRCBigIntAssign</span><span class="cls_006">) has gone up from 130 to 150 ms.</span></div>
<div style="position:absolute;left:72.00px;top:518.88px" class="cls_006"><span class="cls_006">Still, assigning </span><span class="cls_020">RCBigInt</span><span class="cls_006"> objects is cheaper than </span><span class="cls_020">BigInt</span><span class="cls_006">, and reference counting is still a winner in this</span></div>
<div style="position:absolute;left:72.00px;top:531.12px" class="cls_006"><span class="cls_006">case, as shown in </span><span class="cls_036">Figure 12.8</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:160.92px;top:556.56px" class="cls_021"><span class="cls_021">Figure 12.8. Multithreaded </span><span class="cls_024">BigInt</span><span class="cls_021"> assignment speed.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">128</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:120984px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background143.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:315.84px" class="cls_006"><span class="cls_006">The migration to multithreaded environment did not have a huge impact on object assignment. It did,</span></div>
<div style="position:absolute;left:72.00px;top:327.84px" class="cls_006"><span class="cls_006">however, have a dramatic effect on reference creation and destruction. The creation (destruction) of a</span></div>
<div style="position:absolute;left:72.00px;top:340.44px" class="cls_020"><span class="cls_020">BigInt</span><span class="cls_006"> reference was already expensive because we had to create (destroy) a </span><span class="cls_020">BigInt</span><span class="cls_006"> and</span></div>
<div style="position:absolute;left:72.00px;top:353.28px" class="cls_020"><span class="cls_020">CountHolder</span><span class="cls_006"> objects on the heap. On top of that, we now have to add the cost of creating (destroying) a</span></div>
<div style="position:absolute;left:72.00px;top:366.12px" class="cls_020"><span class="cls_020">MutexLock</span><span class="cls_006"> object. In this scenario, the performance gap between a plain </span><span class="cls_020">BigInt</span><span class="cls_006"> and reference-counted</span></div>
<div style="position:absolute;left:72.00px;top:378.84px" class="cls_006"><span class="cls_006">one has blown up into a factor of (almost) 9x in favor of a plain </span><span class="cls_020">BigInt</span><span class="cls_006"> object, as shown in </span><span class="cls_036">Figure 12.9</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:169.80px;top:404.52px" class="cls_021"><span class="cls_021">Figure 12.9. Multithreaded </span><span class="cls_024">BigInt</span><span class="cls_021"> creation speed.</span></div>
<div style="position:absolute;left:72.00px;top:707.52px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:72.00px;top:738.84px" class="cls_006"><span class="cls_006">Reference counting is not an automatic performance winner. Reference counting, execution speed, and</span></div>
<div style="position:absolute;left:72.00px;top:750.84px" class="cls_006"><span class="cls_006">resource conservation form a delicate interaction that must be evaluated carefully if performance is an</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">129</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:121836px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background144.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">important consideration. Reference counting may help or hurt performance depending on the usage pattern.</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">The case in favor of reference counting is strengthened by any one of the following items:</span></div>
<div style="position:absolute;left:90.00px;top:109.32px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The target object is a large resource consumer</span></div>
<div style="position:absolute;left:90.00px;top:121.68px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The resource in question is expensive to allocate and free</span></div>
<div style="position:absolute;left:90.00px;top:133.92px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A high degree of sharing; the reference count is likely to be high due to the use of the assignment</span></div>
<div style="position:absolute;left:108.00px;top:146.04px" class="cls_006"><span class="cls_006">operator and copy constructor</span></div>
<div style="position:absolute;left:90.00px;top:158.40px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The creation or destruction of a reference is relatively cheap</span></div>
<div style="position:absolute;left:72.00px;top:184.44px" class="cls_006"><span class="cls_006">If you reverse these items, you start leaning towards skipping reference counting in favor of the plain</span></div>
<div style="position:absolute;left:72.00px;top:196.56px" class="cls_006"><span class="cls_006">uncounted object.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">130</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:122688px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background145.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 13. Coding Optimizations</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">If our discussion centered around domain- or application-specific issues, it would be of very little use for</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">most people. It would benefit only programmers working in that specific domain or a related application.</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">To appeal to a larger audience we must address the performance issues that spread across programming</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">domains and are likely to appear in a random application, without making any assumptions about the</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">problem domain.</span></div>
<div style="position:absolute;left:72.00px;top:192.24px" class="cls_006"><span class="cls_006">Although manifestations of performance issues are infinite, they may be classified into a finite set of types.</span></div>
<div style="position:absolute;left:72.00px;top:204.36px" class="cls_006"><span class="cls_006">Each type represents a set of equivalent performance bugs. They may look different on the surface, but</span></div>
<div style="position:absolute;left:72.00px;top:216.36px" class="cls_006"><span class="cls_006">they are essentially the same. As an example, take redundant computations, which can take many forms.</span></div>
<div style="position:absolute;left:72.00px;top:228.48px" class="cls_006"><span class="cls_006">Consider a loop-invariant computation:</span></div>
<div style="position:absolute;left:72.00px;top:254.16px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; 100; i++) {</span></div>
<div style="position:absolute;left:96.00px;top:265.56px" class="cls_020"><span class="cls_020">a[i] = m*n;</span></div>
<div style="position:absolute;left:72.00px;top:276.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:303.12px" class="cls_006"><span class="cls_006">The value of </span><span class="cls_020">m*n</span><span class="cls_006"> is computed every iteration. By moving loop-invariant computations outside the loop,</span></div>
<div style="position:absolute;left:72.00px;top:315.36px" class="cls_006"><span class="cls_006">we avoid redundant computations:</span></div>
<div style="position:absolute;left:72.00px;top:341.04px" class="cls_020"><span class="cls_020">int k = m*n;</span></div>
<div style="position:absolute;left:72.00px;top:363.72px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; 100; i++) {</span></div>
<div style="position:absolute;left:96.00px;top:375.00px" class="cls_020"><span class="cls_020">a[i] = k;</span></div>
<div style="position:absolute;left:72.00px;top:386.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:412.08px" class="cls_006"><span class="cls_006">Computational waste takes other forms as well. In the following example each routine needs to access</span></div>
<div style="position:absolute;left:72.00px;top:424.56px" class="cls_006"><span class="cls_006">information that is private to the current thread. </span><span class="cls_020">pthread_getspecific()</span><span class="cls_006"> returns a pointer to a thread-</span></div>
<div style="position:absolute;left:72.00px;top:437.40px" class="cls_006"><span class="cls_006">private data structure. Both functions </span><span class="cls_020">f()</span><span class="cls_006"> and </span><span class="cls_020">g()</span><span class="cls_006"> need access to that data so each calls</span></div>
<div style="position:absolute;left:72.00px;top:450.24px" class="cls_020"><span class="cls_020">pthread_getspecific()</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:476.16px" class="cls_020"><span class="cls_020">static pthread_key_t global_key;</span></div>
<div style="position:absolute;left:72.00px;top:498.84px" class="cls_020"><span class="cls_020">void f()</span></div>
<div style="position:absolute;left:72.00px;top:510.12px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:521.52px" class="cls_020"><span class="cls_020">void *x = pthread_getspecific(global_key);</span></div>
<div style="position:absolute;left:96.00px;top:532.80px" class="cls_020"><span class="cls_020">g();</span></div>
<div style="position:absolute;left:72.00px;top:555.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:578.16px" class="cls_020"><span class="cls_020">void g()</span></div>
<div style="position:absolute;left:72.00px;top:589.44px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:600.84px" class="cls_020"><span class="cls_020">void *y = pthread_getspecific(global_key);</span></div>
<div style="position:absolute;left:72.00px;top:623.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:649.68px" class="cls_006"><span class="cls_006">Since </span><span class="cls_020">f()</span><span class="cls_006"> calls </span><span class="cls_020">g()</span><span class="cls_006"> on the same thread of execution, calling </span><span class="cls_020">pthread_getspecific()</span><span class="cls_006"> twice on the</span></div>
<div style="position:absolute;left:72.00px;top:662.40px" class="cls_006"><span class="cls_006">same flow is a waste. It is made worse by the fact that </span><span class="cls_020">pthread_getspecific()</span><span class="cls_006"> is a fairly expensive</span></div>
<div style="position:absolute;left:72.00px;top:675.24px" class="cls_006"><span class="cls_006">call. We should eliminate the second call to </span><span class="cls_020">pthread_getspecific()</span><span class="cls_006"> by passing its result to </span><span class="cls_020">g()</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:701.16px" class="cls_020"><span class="cls_020">static pthread_key_t global_key;</span></div>
<div style="position:absolute;left:72.00px;top:723.84px" class="cls_020"><span class="cls_020">void f()</span></div>
<div style="position:absolute;left:72.00px;top:735.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:746.52px" class="cls_020"><span class="cls_020">void *x = pthread_getspecific(global_key);</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">131</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:123540px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background146.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">g(x); // Pass a pointer to thread-private data as a parameter</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:127.20px" class="cls_020"><span class="cls_020">void g(void *y)</span></div>
<div style="position:absolute;left:72.00px;top:138.48px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:161.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:186.96px" class="cls_006"><span class="cls_006">Both examples are distinct manifestations of the same inefficiency: redundant computations. We are</span></div>
<div style="position:absolute;left:72.00px;top:199.44px" class="cls_006"><span class="cls_006">recomputing something we already know: the value of </span><span class="cls_020">(m*n)</span><span class="cls_006"> in the first example and the return value of</span></div>
<div style="position:absolute;left:72.00px;top:212.28px" class="cls_020"><span class="cls_020">pthread_getspecific()</span><span class="cls_006"> in the second.</span></div>
<div style="position:absolute;left:72.00px;top:238.56px" class="cls_006"><span class="cls_006">This chapter focuses on performance problems that are introduced in the application coding phase. We will</span></div>
<div style="position:absolute;left:72.00px;top:250.68px" class="cls_006"><span class="cls_006">not cover all instances as they are infinite. We will cover what we perceive as the dominant types. Those</span></div>
<div style="position:absolute;left:72.00px;top:262.68px" class="cls_006"><span class="cls_006">types are often small-scale issues; their resolution does not necessitate looking any further than a few lines</span></div>
<div style="position:absolute;left:72.00px;top:274.80px" class="cls_006"><span class="cls_006">of code. Lifting invariants outside the loop is an example of such coding optimization. You really don't</span></div>
<div style="position:absolute;left:72.00px;top:287.28px" class="cls_006"><span class="cls_006">have to understand the overall program design. Understanding the </span><span class="cls_020">for</span><span class="cls_006"> loop is sufficient.</span></div>
<div style="position:absolute;left:72.00px;top:313.68px" class="cls_006"><span class="cls_006">Performance coding issues are easier to fix than deep design problems. When we first joined the Web</span></div>
<div style="position:absolute;left:72.00px;top:325.68px" class="cls_006"><span class="cls_006">server development team we were not in position to make far-reaching design optimizations. We did not</span></div>
<div style="position:absolute;left:72.00px;top:337.80px" class="cls_006"><span class="cls_006">understand the overall server design well enough, at that point, to perform invasive surgery on it. But we</span></div>
<div style="position:absolute;left:72.00px;top:350.40px" class="cls_006"><span class="cls_006">immediately spotted the </span><span class="cls_020">pthread_getspecific()</span><span class="cls_006"> inefficiency we just described. This call was made</span></div>
<div style="position:absolute;left:72.00px;top:362.64px" class="cls_006"><span class="cls_006">at least a hundred times during HTTP request handling. By passing the return value to those routines that</span></div>
<div style="position:absolute;left:72.00px;top:374.76px" class="cls_006"><span class="cls_006">needed it, we gained an easy 10% on server throughput.</span></div>
<div style="position:absolute;left:72.00px;top:428.52px" class="cls_016"><span class="cls_016">Caching</span></div>
<div style="position:absolute;left:72.00px;top:459.84px" class="cls_006"><span class="cls_006">Caching is often associated with data and instruction caching on modern processors. But, caching</span></div>
<div style="position:absolute;left:72.00px;top:471.96px" class="cls_006"><span class="cls_006">opportunities appear in much wider contexts, including application-level coding and design. Caching is</span></div>
<div style="position:absolute;left:72.00px;top:484.08px" class="cls_006"><span class="cls_006">about remembering the results of frequent and costly computations, so that you will not have to perform</span></div>
<div style="position:absolute;left:72.00px;top:496.08px" class="cls_006"><span class="cls_006">those computations over and over again.</span></div>
<div style="position:absolute;left:72.00px;top:522.12px" class="cls_006"><span class="cls_006">Caching opportunities are easier to detect and implement in the coding arena. Evaluating constant</span></div>
<div style="position:absolute;left:72.00px;top:534.24px" class="cls_006"><span class="cls_006">expressions inside a loop is a well known performance inefficiency. For example:</span></div>
<div style="position:absolute;left:72.00px;top:559.92px" class="cls_020"><span class="cls_020">for(... ;!done;... ) {</span></div>
<div style="position:absolute;left:96.00px;top:571.32px" class="cls_020"><span class="cls_020">done = patternMatch(pat1, pat2, isCaseSensitive());</span></div>
<div style="position:absolute;left:72.00px;top:582.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:608.88px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">patternMatch()</span><span class="cls_006"> function takes two string patterns to match and a third argument indicating</span></div>
<div style="position:absolute;left:72.00px;top:621.12px" class="cls_006"><span class="cls_006">whether a case-sensitive match is required. The decision itself is generated by a function call,</span></div>
<div style="position:absolute;left:72.00px;top:633.72px" class="cls_020"><span class="cls_020">isCaseSensitive()</span><span class="cls_006">. This function simply distinguishes the case sensitive UNIX platforms from the</span></div>
<div style="position:absolute;left:72.00px;top:645.96px" class="cls_006"><span class="cls_006">nonsensitive PC platforms. This decision is fixed. It is independent of the loop and will not change from</span></div>
<div style="position:absolute;left:72.00px;top:658.08px" class="cls_006"><span class="cls_006">one iteration to the next. It should, therefore, be called outside the loop:</span></div>
<div style="position:absolute;left:72.00px;top:683.76px" class="cls_020"><span class="cls_020">int isSensitive = isCaseSensitive();</span></div>
<div style="position:absolute;left:72.00px;top:706.44px" class="cls_020"><span class="cls_020">for(... ;!done;... ) {</span></div>
<div style="position:absolute;left:90.00px;top:717.72px" class="cls_020"><span class="cls_020">done = patternMatch(pat1, pat2, isSensitive);</span></div>
<div style="position:absolute;left:72.00px;top:729.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:754.68px" class="cls_006"><span class="cls_006">Now you compute case-sensitivity once, cache it in a local variable, and reuse it.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">132</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:124392px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background147.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:98.64px" class="cls_016"><span class="cls_016">Precompute</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">Precomputing is a close relative of caching. When you cache a result, you pay the price of computing it</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">once in the performance-critical path. When you precompute, you don't even pay the first time. You</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">perform the precomputation outside the performance-critical path (say, initialization-time) and never pay</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">the price of performing a costly computation inside the performance-critical path.</span></div>
<div style="position:absolute;left:72.00px;top:192.24px" class="cls_006"><span class="cls_006">Back to the Web server implementation for an example: A Web server spends a significant portion of its</span></div>
<div style="position:absolute;left:72.00px;top:204.36px" class="cls_006"><span class="cls_006">time manipulating character strings. If you can speed up string manipulation, performance will rise</span></div>
<div style="position:absolute;left:72.00px;top:216.36px" class="cls_006"><span class="cls_006">significantly. One string manipulation task we often encountered was uppercasing strings and characters. If</span></div>
<div style="position:absolute;left:72.00px;top:228.96px" class="cls_006"><span class="cls_006">the browser sends us an </span><span class="cls_020">"Accept:"</span><span class="cls_006"> request header, the server must recognize it regardless of case. We</span></div>
<div style="position:absolute;left:72.00px;top:241.80px" class="cls_006"><span class="cls_006">should not distinguish among </span><span class="cls_020">"accept:"</span><span class="cls_006">, </span><span class="cls_020">"AcCePt:"</span><span class="cls_006"> or any other combination of lower- and</span></div>
<div style="position:absolute;left:72.00px;top:254.52px" class="cls_006"><span class="cls_006">uppercase letters. (The </span><span class="cls_020">accept</span><span class="cls_006"> header tells the server what document types are acceptable to the</span></div>
<div style="position:absolute;left:72.00px;top:266.88px" class="cls_006"><span class="cls_006">browser—text/html, image/gif,</span></div>
<div style="position:absolute;left:215.31px;top:266.88px" class="cls_006"><span class="cls_006">)</span></div>
<div style="position:absolute;left:72.00px;top:293.40px" class="cls_006"><span class="cls_006">Since </span><span class="cls_020">memcmp(header, "ACCEPT:", 7)</span><span class="cls_006"> is case sensitive, we need to uppercase the </span><span class="cls_020">header</span><span class="cls_006"> string</span></div>
<div style="position:absolute;left:72.00px;top:306.24px" class="cls_006"><span class="cls_006">prior to calling </span><span class="cls_020">memcmp()</span><span class="cls_006">. We may do the following:</span></div>
<div style="position:absolute;left:72.00px;top:332.28px" class="cls_020"><span class="cls_020">for (char *p = header; *p ; p++) {</span></div>
<div style="position:absolute;left:299.96px;top:332.28px" class="cls_020"><span class="cls_020">// Uppercase the header</span></div>
<div style="position:absolute;left:96.00px;top:343.56px" class="cls_020"><span class="cls_020">*p = toupper(*p);</span></div>
<div style="position:absolute;left:72.00px;top:354.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:377.52px" class="cls_020"><span class="cls_020">if (0 == memcmp(header, "ACCEPT:", 7)) {</span></div>
<div style="position:absolute;left:72.00px;top:400.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:426.36px" class="cls_006"><span class="cls_006">In a performance-critical path, you may find the cost of repeated </span><span class="cls_020">toupper()</span><span class="cls_006"> calls to be unacceptable.</span></div>
<div style="position:absolute;left:72.00px;top:439.20px" class="cls_006"><span class="cls_006">Even if </span><span class="cls_020">toupper()</span><span class="cls_006"> was implemented as an inline function, it would still contain a conditional statement</span></div>
<div style="position:absolute;left:72.00px;top:451.44px" class="cls_006"><span class="cls_006">of the form:</span></div>
<div style="position:absolute;left:72.00px;top:477.24px" class="cls_020"><span class="cls_020">return (c >='a' && c&lt;='z') ? c - ('a'-'A') : c;</span></div>
<div style="position:absolute;left:72.00px;top:502.92px" class="cls_006"><span class="cls_006">This is the ASCII implementation. It gets even more complex with the EBCDIC character set (the</span></div>
<div style="position:absolute;left:72.00px;top:514.92px" class="cls_006"><span class="cls_006">EBCDIC alphabet sequence is not contiguous).</span></div>
<div style="position:absolute;left:72.00px;top:541.08px" class="cls_006"><span class="cls_006">We didn't want to pay the price of a possible library call or even an inlined conditional statement. We</span></div>
<div style="position:absolute;left:72.00px;top:553.08px" class="cls_006"><span class="cls_006">chose to precompute the corresponding uppercase value of each possible character:</span></div>
<div style="position:absolute;left:72.00px;top:578.88px" class="cls_020"><span class="cls_020">void initLookupTable()</span></div>
<div style="position:absolute;left:72.00px;top:590.16px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:601.44px" class="cls_020"><span class="cls_020">for (int i = 0; i &lt; 256; i++) {</span></div>
<div style="position:absolute;left:119.99px;top:612.84px" class="cls_020"><span class="cls_020">uppercaseTable[i] = toupper(i);</span></div>
<div style="position:absolute;left:96.00px;top:624.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:635.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:661.68px" class="cls_006"><span class="cls_006">It doesn't matter how expensive </span><span class="cls_020">islower()</span><span class="cls_006"> and </span><span class="cls_020">toupper()</span><span class="cls_006"> are since the </span><span class="cls_020">uppercaseTable</span><span class="cls_006"> is</span></div>
<div style="position:absolute;left:72.00px;top:673.92px" class="cls_006"><span class="cls_006">initialized at start-up time and performance is not an issue.</span></div>
<div style="position:absolute;left:72.00px;top:700.08px" class="cls_006"><span class="cls_006">Now we can uppercase a character consuming two instructions only. This significantly speeds up our</span></div>
<div style="position:absolute;left:72.00px;top:712.08px" class="cls_006"><span class="cls_006">string manipulation:</span></div>
<div style="position:absolute;left:72.00px;top:737.88px" class="cls_020"><span class="cls_020">for (char *p = header; *p ; p++) {</span></div>
<div style="position:absolute;left:96.00px;top:749.16px" class="cls_020"><span class="cls_020">*p = uppercaseTable[*p];</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">133</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:125244px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background148.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">if (0 == memcmp(header, "ACCEPT:", 7)) {</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:141.60px" class="cls_006"><span class="cls_006">While we were at it, we precomputed a table lookup of other character functions that were required in the</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">performance critical path: </span><span class="cls_020">islower()</span><span class="cls_006">, </span><span class="cls_020">isspace()</span><span class="cls_006">, </span><span class="cls_020">isdigit()</span><span class="cls_006">, and others.</span></div>
<div style="position:absolute;left:72.00px;top:208.20px" class="cls_016"><span class="cls_016">Reduce Flexibility</span></div>
<div style="position:absolute;left:72.00px;top:239.52px" class="cls_006"><span class="cls_006">As a domain expert you are often in position to make simplifying assumptions that boost performance.</span></div>
<div style="position:absolute;left:72.00px;top:265.56px" class="cls_006"><span class="cls_006">Often, a Web server needs to know the IP address of the client where the request originated. An IP address</span></div>
<div style="position:absolute;left:72.00px;top:277.68px" class="cls_006"><span class="cls_006">is a dotted decimal expression like 9.37.37.205. Initially, for every request, our code allocated heap storage</span></div>
<div style="position:absolute;left:72.00px;top:289.68px" class="cls_006"><span class="cls_006">large enough to hold the client IP address. That storage was deallocated at the end of the request handling.</span></div>
<div style="position:absolute;left:72.00px;top:302.28px" class="cls_006"><span class="cls_006">Calling </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006"> for heap memory is expensive. This is particularly bad since you do it for</span></div>
<div style="position:absolute;left:72.00px;top:314.64px" class="cls_006"><span class="cls_006">every request. Using memory pools can alleviate the burden, but it is still not as good as eliminating the</span></div>
<div style="position:absolute;left:72.00px;top:327.12px" class="cls_020"><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006"> calls altogether.</span></div>
<div style="position:absolute;left:72.00px;top:353.52px" class="cls_006"><span class="cls_006">If an IP address was potentially unbounded in length, we would have had no choice but to allocate memory</span></div>
<div style="position:absolute;left:72.00px;top:365.52px" class="cls_006"><span class="cls_006">on-the-fly. However, we are TCP/IP domain experts, and we know that currently an IP address cannot be</span></div>
<div style="position:absolute;left:72.00px;top:377.64px" class="cls_006"><span class="cls_006">longer than 15 bytes. The longest address would be</span></div>
<div style="position:absolute;left:72.00px;top:403.32px" class="cls_020"><span class="cls_020">xxx.xxx.xxx.xxx</span></div>
<div style="position:absolute;left:72.00px;top:429.00px" class="cls_006"><span class="cls_006">If you add a terminating NULL, you get 16 bytes. The next generation IP address (IPv6) will be longer, but</span></div>
<div style="position:absolute;left:72.00px;top:441.12px" class="cls_006"><span class="cls_006">still bounded. Since the string length is bounded, it is more efficient to store the IP address on the stack as</span></div>
<div style="position:absolute;left:72.00px;top:453.12px" class="cls_006"><span class="cls_006">a local variable:</span></div>
<div style="position:absolute;left:72.00px;top:478.92px" class="cls_020"><span class="cls_020">char clientIPAddr[256];</span></div>
<div style="position:absolute;left:72.00px;top:504.60px" class="cls_006"><span class="cls_006">This is good enough for our domain for many years to come. Although 32 bytes would be more than</span></div>
<div style="position:absolute;left:72.00px;top:516.60px" class="cls_006"><span class="cls_006">enough, we chose 256 to be on the safe side. This bounded character array eliminates expensive calls to</span></div>
<div style="position:absolute;left:72.00px;top:529.20px" class="cls_006"><span class="cls_006">both </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006">. We traded flexibility that we never needed for higher performance.</span></div>
<div style="position:absolute;left:72.00px;top:583.20px" class="cls_016"><span class="cls_016">80-20 Rule: Speed Up the Common Path</span></div>
<div style="position:absolute;left:72.00px;top:614.52px" class="cls_006"><span class="cls_006">The 80-20 rule has many applications: 80% of the execution scenarios will traverse only 20% of your</span></div>
<div style="position:absolute;left:72.00px;top:626.64px" class="cls_006"><span class="cls_006">source code, and 80% of the elapsed time will be spent in 20% of the functions encountered on the</span></div>
<div style="position:absolute;left:72.00px;top:638.76px" class="cls_006"><span class="cls_006">execution path. The 80-20 rule is the dominating force driving the argument that premature tuning is a sin.</span></div>
<div style="position:absolute;left:72.00px;top:650.76px" class="cls_006"><span class="cls_006">If you randomly tune everything you can think of, not only do you waste 80% of the effort, you will also</span></div>
<div style="position:absolute;left:72.00px;top:662.88px" class="cls_006"><span class="cls_006">hack the design beyond repair.</span></div>
<div style="position:absolute;left:72.00px;top:688.92px" class="cls_006"><span class="cls_006">The HTTP specification is a 100-page document that describes all possible HTTP requests that a Web</span></div>
<div style="position:absolute;left:72.00px;top:701.04px" class="cls_006"><span class="cls_006">server must handle. Most of the HTTP requests that traverse the Web these days are very simple. They</span></div>
<div style="position:absolute;left:72.00px;top:713.04px" class="cls_006"><span class="cls_006">contain only a small subset of the possible HTTP headers that a request could potentially contain. Finding</span></div>
<div style="position:absolute;left:72.00px;top:725.16px" class="cls_006"><span class="cls_006">out what these typical request headers look like is fairly simple: Since Microsoft and Netscape have a</span></div>
<div style="position:absolute;left:72.00px;top:737.28px" class="cls_006"><span class="cls_006">dominating share of the browser market, all you need to do is peek at the request headers sent by these two</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">134</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:126096px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background149.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">browsers. This is yet another manifestation of the 80-20 rule—20% of your possible inputs will occur 80%</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">of the time.</span></div>
<div style="position:absolute;left:72.00px;top:109.08px" class="cls_006"><span class="cls_006">HTTP request headers determine the request type and will often traverse separate execution paths. An</span></div>
<div style="position:absolute;left:72.00px;top:121.20px" class="cls_006"><span class="cls_006">efficient use of programmer resources is to tune those 20% of the request types that appear 80% of the time.</span></div>
<div style="position:absolute;left:72.00px;top:147.24px" class="cls_006"><span class="cls_006">There's another point to the 80-20 idea. Not only do you need to focus on the typical execution path, you</span></div>
<div style="position:absolute;left:72.00px;top:159.24px" class="cls_006"><span class="cls_006">should take advantage of the fact that most of your input data is going to come from a narrow range of the</span></div>
<div style="position:absolute;left:72.00px;top:171.36px" class="cls_006"><span class="cls_006">whole input space. Some examples follow.</span></div>
<div style="position:absolute;left:72.00px;top:197.88px" class="cls_006"><span class="cls_006">The HTTP </span><span class="cls_020">Accept</span><span class="cls_006"> header is part of an HTTP request. It specifies what document formats are acceptable</span></div>
<div style="position:absolute;left:72.00px;top:210.72px" class="cls_006"><span class="cls_006">to the browser. The HTTP specification allows for the </span><span class="cls_020">Accept</span><span class="cls_006"> header to have any combination of upper-</span></div>
<div style="position:absolute;left:72.00px;top:223.56px" class="cls_006"><span class="cls_006">and lowercase. When you read a string token and want to determine if it is the </span><span class="cls_020">Accept</span><span class="cls_006"> header, it is not</span></div>
<div style="position:absolute;left:72.00px;top:235.80px" class="cls_006"><span class="cls_006">enough to perform</span></div>
<div style="position:absolute;left:72.00px;top:261.60px" class="cls_020"><span class="cls_020">memcmp("Accept:", header, 7)</span></div>
<div style="position:absolute;left:72.00px;top:287.28px" class="cls_006"><span class="cls_006">We need to perform a case-sensitive string compare. We implemented a home-grown version for a case-</span></div>
<div style="position:absolute;left:72.00px;top:299.28px" class="cls_006"><span class="cls_006">sensitive string-compare:</span></div>
<div style="position:absolute;left:72.00px;top:325.08px" class="cls_020"><span class="cls_020">int memCaseCmp(char*,char*, int) {...}</span></div>
<div style="position:absolute;left:72.00px;top:350.64px" class="cls_006"><span class="cls_006">To be HTTP compliant, the correct action should be</span></div>
<div style="position:absolute;left:72.00px;top:376.44px" class="cls_020"><span class="cls_020">if ( 0 == memCaseCmp("accept:", header, 7) )</span></div>
<div style="position:absolute;left:347.95px;top:376.44px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:90.00px;top:387.72px" class="cls_020"><span class="cls_020">// This is the Accept header</span></div>
<div style="position:absolute;left:72.00px;top:399.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:425.28px" class="cls_006"><span class="cls_006">However, </span><span class="cls_020">memCaseCmp()</span><span class="cls_006"> is not cheap. It needs to uppercase both strings and then call </span><span class="cls_020">memcmp()</span><span class="cls_006">. This</span></div>
<div style="position:absolute;left:72.00px;top:437.64px" class="cls_006"><span class="cls_006">is where our domain expertise must come into play. Like we said, Microsoft and Netscape have a</span></div>
<div style="position:absolute;left:72.00px;top:450.12px" class="cls_006"><span class="cls_006">commanding share of the browser market. The </span><span class="cls_020">Accept</span><span class="cls_006"> header they send happens to be </span><span class="cls_020">"Accept:"</span><span class="cls_006">. This</span></div>
<div style="position:absolute;left:72.00px;top:462.48px" class="cls_006"><span class="cls_006">is only one of the many upper- and lowercase combination that HTTP allows, but it is the one we are going</span></div>
<div style="position:absolute;left:72.00px;top:474.60px" class="cls_006"><span class="cls_006">to receive 95% of the time, so it is the one we care about. The following test tries to take advantage of that:</span></div>
<div style="position:absolute;left:72.00px;top:500.28px" class="cls_020"><span class="cls_020">if ( (0 == memcmp("Accept:", header,7)) ||</span></div>
<div style="position:absolute;left:341.95px;top:500.28px" class="cls_020"><span class="cls_020">// An intelligent</span></div>
<div style="position:absolute;left:341.95px;top:511.56px" class="cls_020"><span class="cls_020">// gamble...</span></div>
<div style="position:absolute;left:96.00px;top:522.96px" class="cls_020"><span class="cls_020">(0 == memCaseCmp("accept:", header, 7)))</span></div>
<div style="position:absolute;left:347.95px;top:522.96px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:90.00px;top:545.52px" class="cls_020"><span class="cls_020">// This is the Accept header</span></div>
<div style="position:absolute;left:72.00px;top:556.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:583.08px" class="cls_006"><span class="cls_006">In 95% of the inputs, the </span><span class="cls_020">memcmp()</span><span class="cls_006"> test is going to succeed, and we will never call the more expensive</span></div>
<div style="position:absolute;left:72.00px;top:595.92px" class="cls_020"><span class="cls_020">memCaseCmp()</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:622.20px" class="cls_006"><span class="cls_006">The last code sample leads us right into another 80-20 issue of evaluation order. It is often the case that</span></div>
<div style="position:absolute;left:72.00px;top:634.32px" class="cls_006"><span class="cls_006">conditional expressions are built as a logical combination of subexpressions. When we examine</span></div>
<div style="position:absolute;left:72.00px;top:646.32px" class="cls_006"><span class="cls_006">expressions of the form</span></div>
<div style="position:absolute;left:72.00px;top:672.12px" class="cls_020"><span class="cls_020">if (e1 || e2) {...}</span></div>
<div style="position:absolute;left:72.00px;top:697.68px" class="cls_006"><span class="cls_006">or</span></div>
<div style="position:absolute;left:72.00px;top:723.48px" class="cls_020"><span class="cls_020">if (e1 && e2) {...}</span></div>
<div style="position:absolute;left:72.00px;top:749.64px" class="cls_006"><span class="cls_006">the order of evaluation has performance implications. Take the former </span><span class="cls_020">if</span><span class="cls_006"> statement as an example:</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">135</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:126948px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background150.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">if (e1 || e2) {...}</span></div>
<div style="position:absolute;left:72.00px;top:96.72px" class="cls_006"><span class="cls_006">If </span><span class="cls_020">(e1</span></div>
<div style="position:absolute;left:105.48px;top:96.72px" class="cls_020"><span class="cls_020">|| e2)</span><span class="cls_006"> evaluates to FALSE, we lose. Both subexpressions, </span><span class="cls_020">e1</span><span class="cls_006"> and </span><span class="cls_020">e2</span><span class="cls_006">, must be evaluated.</span></div>
<div style="position:absolute;left:72.00px;top:109.56px" class="cls_006"><span class="cls_006">However, in the case where </span><span class="cls_020">(e1 || e2)</span><span class="cls_006"> is TRUE, if </span><span class="cls_020">e1</span><span class="cls_006"> is TRUE, </span><span class="cls_020">e2</span><span class="cls_006"> will not be evaluated and the</span></div>
<div style="position:absolute;left:72.00px;top:121.80px" class="cls_006"><span class="cls_006">overall cost of the expression is reduced. In the following discussion, we narrow our attention to the case</span></div>
<div style="position:absolute;left:72.00px;top:134.40px" class="cls_006"><span class="cls_006">where </span><span class="cls_020">(e1 || e2)</span><span class="cls_006"> is TRUE.</span></div>
<div style="position:absolute;left:72.00px;top:161.16px" class="cls_006"><span class="cls_006">If </span><span class="cls_020">e1</span><span class="cls_006"> and </span><span class="cls_020">e2</span><span class="cls_006"> are equally likely to evaluate to TRUE, then the subexpression with the smaller</span></div>
<div style="position:absolute;left:72.00px;top:174.00px" class="cls_006"><span class="cls_006">computational cost should be placed first in the evaluation order. If, on the other hand, </span><span class="cls_020">e1</span><span class="cls_006"> and </span><span class="cls_020">e2</span><span class="cls_006"> are of</span></div>
<div style="position:absolute;left:72.00px;top:186.36px" class="cls_006"><span class="cls_006">equal computational cost, then the one most likely to evaluate to TRUE should appear first. In a more</span></div>
<div style="position:absolute;left:72.00px;top:198.48px" class="cls_006"><span class="cls_006">general situation, let</span></div>
<div style="position:absolute;left:72.00px;top:225.00px" class="cls_020"><span class="cls_020">p1</span><span class="cls_006"> = The conditional probability that </span><span class="cls_020">e1</span><span class="cls_006"> is TRUE given that </span><span class="cls_020">(e1</span><span class="cls_006"> </span><span class="cls_020">||</span><span class="cls_006"> </span><span class="cls_020">e2)</span><span class="cls_006"> is TRUE.</span></div>
<div style="position:absolute;left:72.00px;top:251.76px" class="cls_020"><span class="cls_020">c1</span><span class="cls_006"> = The computational cost of evaluating </span><span class="cls_020">e1</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:278.64px" class="cls_006"><span class="cls_006">We are trying to minimize the expected cost of computing </span><span class="cls_020">(e1 || e2)</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:305.40px" class="cls_006"><span class="cls_006">cost = </span><span class="cls_020">C1</span><span class="cls_006">+(</span><span class="cls_020">1-p1</span><span class="cls_006">)*</span><span class="cls_020">C2</span></div>
<div style="position:absolute;left:72.00px;top:331.68px" class="cls_006"><span class="cls_006">Our example only dealt with two subexpressions, but this easily extends to any number of subexpressions</span></div>
<div style="position:absolute;left:72.00px;top:343.80px" class="cls_006"><span class="cls_006">in a logical OR expression.</span></div>
<div style="position:absolute;left:72.00px;top:370.32px" class="cls_006"><span class="cls_006">Previously we encountered a conditional statement checking for an </span><span class="cls_020">Accept</span><span class="cls_006"> HTTP header:</span></div>
<div style="position:absolute;left:72.00px;top:396.36px" class="cls_020"><span class="cls_020">if ( (0 == memcmp("Accept:", str,7)) ||</span></div>
<div style="position:absolute;left:101.99px;top:407.64px" class="cls_020"><span class="cls_020">(0 == memCaseCmp("accept:", str, 7)))</span></div>
<div style="position:absolute;left:335.95px;top:407.64px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:90.00px;top:430.32px" class="cls_020"><span class="cls_020">// This is the Accept header</span></div>
<div style="position:absolute;left:72.00px;top:441.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:467.28px" class="cls_006"><span class="cls_006">In this case,</span></div>
<div style="position:absolute;left:72.00px;top:493.92px" class="cls_020"><span class="cls_020">e1</span><span class="cls_006"> is </span><span class="cls_020">(0 == memcmp("Accept:", str, 7))</span></div>
<div style="position:absolute;left:72.00px;top:520.68px" class="cls_020"><span class="cls_020">e2</span><span class="cls_006"> is </span><span class="cls_020">(0 == memCaseCmp("accept:", str, 7))</span></div>
<div style="position:absolute;left:72.00px;top:547.44px" class="cls_006"><span class="cls_006">In the case where the </span><span class="cls_020">if</span><span class="cls_006"> statement is TRUE, </span><span class="cls_020">e2</span><span class="cls_006"> will evaluate to TRUE 100% of the time since it is a case-</span></div>
<div style="position:absolute;left:72.00px;top:560.28px" class="cls_006"><span class="cls_006">sensitive string compare. So </span><span class="cls_020">p2</span><span class="cls_006"> = 1.0. The subexpression </span><span class="cls_020">e1</span><span class="cls_006"> will evaluate to TRUE only 90% of the time.</span></div>
<div style="position:absolute;left:72.00px;top:573.12px" class="cls_006"><span class="cls_006">So </span><span class="cls_020">p1</span><span class="cls_006"> = 0.9. The computational cost is roughly given by:</span></div>
<div style="position:absolute;left:72.00px;top:599.88px" class="cls_020"><span class="cls_020">c1</span><span class="cls_006"> = 10 instructions</span></div>
<div style="position:absolute;left:72.00px;top:626.76px" class="cls_020"><span class="cls_020">c2</span><span class="cls_006"> = 100 instructions</span></div>
<div style="position:absolute;left:72.00px;top:653.04px" class="cls_006"><span class="cls_006">Our expected cost is</span></div>
<div style="position:absolute;left:72.00px;top:679.08px" class="cls_006"><span class="cls_006">cost = 10 + 0.1 * 100 = 20</span></div>
<div style="position:absolute;left:72.00px;top:705.60px" class="cls_006"><span class="cls_006">If we flipped the order of </span><span class="cls_020">e1</span><span class="cls_006"> and </span><span class="cls_020">e2</span><span class="cls_006">, our expected cost would be</span></div>
<div style="position:absolute;left:72.00px;top:732.48px" class="cls_006"><span class="cls_006">cost = </span><span class="cls_020">c2</span><span class="cls_006"> + (1- </span><span class="cls_020">p2</span><span class="cls_006">) * </span><span class="cls_020">c1</span><span class="cls_006"> = 100 + 0 * 10 = 100</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">136</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:127800px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background151.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">Therefore,</span></div>
<div style="position:absolute;left:72.00px;top:96.60px" class="cls_020"><span class="cls_020">if (e1 || e2)</span></div>
<div style="position:absolute;left:72.00px;top:122.28px" class="cls_006"><span class="cls_006">is a better choice than</span></div>
<div style="position:absolute;left:72.00px;top:148.08px" class="cls_020"><span class="cls_020">if (e2 || e1)</span></div>
<div style="position:absolute;left:72.00px;top:173.64px" class="cls_006"><span class="cls_006">There's similar logic for logical AND expressions like</span></div>
<div style="position:absolute;left:72.00px;top:199.44px" class="cls_020"><span class="cls_020">if (e1 && e2)</span></div>
<div style="position:absolute;left:72.00px;top:225.12px" class="cls_006"><span class="cls_006">Given the case where the whole expression evaluates to FALSE, we would like it to fail as early as</span></div>
<div style="position:absolute;left:72.00px;top:237.24px" class="cls_006"><span class="cls_006">possible without having to evaluate all subexpressions. The definition of the probability in this case is</span></div>
<div style="position:absolute;left:72.00px;top:249.24px" class="cls_006"><span class="cls_006">slightly different:</span></div>
<div style="position:absolute;left:72.00px;top:275.88px" class="cls_020"><span class="cls_020">p1</span><span class="cls_006"> = The conditional probability that </span><span class="cls_020">e1</span><span class="cls_006"> is FALSE given that </span><span class="cls_020">(e1 && e2)</span><span class="cls_006"> is FALSE.</span></div>
<div style="position:absolute;left:72.00px;top:302.16px" class="cls_006"><span class="cls_006">You can easily encounter such decisions in practice; for example, when the specifications require an</span></div>
<div style="position:absolute;left:72.00px;top:314.28px" class="cls_006"><span class="cls_006">implementation to check and handle some rare combination of events like:</span></div>
<div style="position:absolute;left:72.00px;top:339.96px" class="cls_020"><span class="cls_020">if ( rareCondition_1() && rareCondition_2() ) {</span></div>
<div style="position:absolute;left:90.00px;top:351.24px" class="cls_020"><span class="cls_020">// Handle it</span></div>
<div style="position:absolute;left:72.00px;top:362.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:388.32px" class="cls_006"><span class="cls_006">Since this combination is rare, this condition will fail most of the time. We'd like for it to fail quickly on</span></div>
<div style="position:absolute;left:72.00px;top:400.32px" class="cls_006"><span class="cls_006">the first subexpression. This is, by the way, the reason why HTTP 1.1-compliant servers are somewhat</span></div>
<div style="position:absolute;left:72.00px;top:412.44px" class="cls_006"><span class="cls_006">slower than HTTP 1.0 implementations. The HTTP 1.1 specifications are much more complex, and force</span></div>
<div style="position:absolute;left:72.00px;top:424.56px" class="cls_006"><span class="cls_006">the server to perform many checks for all kinds of esoteric scenarios that rarely happen. But you still have</span></div>
<div style="position:absolute;left:72.00px;top:436.56px" class="cls_006"><span class="cls_006">to perform the test to be HTTP 1.1-compliant. For example, an HTTP 1.1-compliant browser may ask for a</span></div>
<div style="position:absolute;left:72.00px;top:448.68px" class="cls_006"><span class="cls_006">portion of a large document instead of the complete document. In practice, the browsers ask for complete</span></div>
<div style="position:absolute;left:72.00px;top:460.68px" class="cls_006"><span class="cls_006">documents in the vast majority of requests. The server, however, must still check for a partial document</span></div>
<div style="position:absolute;left:72.00px;top:472.80px" class="cls_006"><span class="cls_006">request and handle it properly.</span></div>
<div style="position:absolute;left:72.00px;top:526.56px" class="cls_016"><span class="cls_016">Lazy Evaluation</span></div>
<div style="position:absolute;left:72.00px;top:557.88px" class="cls_006"><span class="cls_006">Paying a performance penalty for a computation you ultimately may not need is a bad idea. It happens way</span></div>
<div style="position:absolute;left:72.00px;top:570.00px" class="cls_006"><span class="cls_006">too often in complex code. You should not perform costly computations "just in case." Costly</span></div>
<div style="position:absolute;left:72.00px;top:582.12px" class="cls_006"><span class="cls_006">computations should be performed only if necessary. That often means deferring computations until they</span></div>
<div style="position:absolute;left:72.00px;top:594.12px" class="cls_006"><span class="cls_006">are actually needed, hence the name Lazy Evaluation [</span><span class="cls_036">Mey96</span><span class="cls_006">, </span><span class="cls_036">ES90</span><span class="cls_006">].</span></div>
<div style="position:absolute;left:72.00px;top:620.28px" class="cls_006"><span class="cls_006">Back in the days of pure C programming we were in the habit of defining all of our variables up front, at</span></div>
<div style="position:absolute;left:72.00px;top:632.28px" class="cls_006"><span class="cls_006">the beginning of each routine. In C++, object definitions trigger constructors and destructors and that may</span></div>
<div style="position:absolute;left:72.00px;top:644.40px" class="cls_006"><span class="cls_006">be expensive. It leads to eager evaluation—something we want to avoid. The Lazy Evaluation principle</span></div>
<div style="position:absolute;left:72.00px;top:656.40px" class="cls_006"><span class="cls_006">suggests that we ought to delay object definition to the scope where it is being used. There is no sense</span></div>
<div style="position:absolute;left:72.00px;top:668.52px" class="cls_006"><span class="cls_006">paying for object construction and destruction if we are not going to use it. This sounds silly, but it</span></div>
<div style="position:absolute;left:72.00px;top:680.64px" class="cls_006"><span class="cls_006">happens in practice.</span></div>
<div style="position:absolute;left:72.00px;top:706.68px" class="cls_006"><span class="cls_006">In a C++ gateway application we had a performance-critical piece of code that ran in the AIX kernel. That</span></div>
<div style="position:absolute;left:72.00px;top:718.68px" class="cls_006"><span class="cls_006">code routed messages between downstream and upstream communication adapters. One of the objects we</span></div>
<div style="position:absolute;left:72.00px;top:730.80px" class="cls_006"><span class="cls_006">used was very expensive to construct and destroy:</span></div>
<div style="position:absolute;left:72.00px;top:756.48px" class="cls_020"><span class="cls_020">int route(Message *msg)</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:128652px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background152.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">ExpensiveClass upstream(msg);</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">if (goingUpstream) {</span></div>
<div style="position:absolute;left:149.99px;top:115.92px" class="cls_020"><span class="cls_020">// do something with the expensive object</span></div>
<div style="position:absolute;left:96.00px;top:127.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:149.88px" class="cls_020"><span class="cls_020">// upstream object not used here.</span></div>
<div style="position:absolute;left:96.00px;top:172.56px" class="cls_020"><span class="cls_020">return SUCCESS;</span></div>
<div style="position:absolute;left:72.00px;top:183.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:210.00px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">upstream</span><span class="cls_006"> object was very expensive. In the original code it was eagerly constructed at the top of the</span></div>
<div style="position:absolute;left:72.00px;top:222.84px" class="cls_006"><span class="cls_006">function. It was used only half the time when a message was routed upstream. The </span><span class="cls_020">upstream</span><span class="cls_006"> object was</span></div>
<div style="position:absolute;left:72.00px;top:235.20px" class="cls_006"><span class="cls_006">not used at all when a message was routed downstream (50% of the time). In the event of a downstream</span></div>
<div style="position:absolute;left:72.00px;top:247.68px" class="cls_006"><span class="cls_006">message, the evaluation of the </span><span class="cls_020">upstream</span><span class="cls_006"> object was pure waste. A better solution would define the</span></div>
<div style="position:absolute;left:72.00px;top:260.52px" class="cls_006"><span class="cls_006">expensive </span><span class="cls_020">upstream</span><span class="cls_006"> object in the scope where it is actually necessary:</span></div>
<div style="position:absolute;left:72.00px;top:286.44px" class="cls_020"><span class="cls_020">int route(Message *msg)</span></div>
<div style="position:absolute;left:72.00px;top:297.84px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:320.40px" class="cls_020"><span class="cls_020">if (goingUpstream) {</span></div>
<div style="position:absolute;left:119.99px;top:331.80px" class="cls_020"><span class="cls_020">ExpensiveClass upstream(msg);</span></div>
<div style="position:absolute;left:119.99px;top:354.48px" class="cls_020"><span class="cls_020">// do something with the expensive object</span></div>
<div style="position:absolute;left:96.00px;top:365.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:388.44px" class="cls_020"><span class="cls_020">// upstream object not used here.</span></div>
<div style="position:absolute;left:96.00px;top:411.12px" class="cls_020"><span class="cls_020">return SUCCESS;</span></div>
<div style="position:absolute;left:72.00px;top:422.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:448.08px" class="cls_006"><span class="cls_006">In item 32 of [</span><span class="cls_036">Mey97</span><span class="cls_006">] Meyers makes another important observation on Lazy Evaluation. Not only should</span></div>
<div style="position:absolute;left:72.00px;top:460.20px" class="cls_006"><span class="cls_006">you defer object creation to the correct scope, you should also delay that construction until you have all the</span></div>
<div style="position:absolute;left:72.00px;top:472.20px" class="cls_006"><span class="cls_006">necessary ingredients for an efficient construction. For example:</span></div>
<div style="position:absolute;left:72.00px;top:498.00px" class="cls_020"><span class="cls_020">void f()</span></div>
<div style="position:absolute;left:72.00px;top:509.28px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:520.56px" class="cls_020"><span class="cls_020">string s;</span></div>
<div style="position:absolute;left:221.97px;top:520.56px" class="cls_020"><span class="cls_020">// 1</span></div>
<div style="position:absolute;left:96.00px;top:543.24px" class="cls_020"><span class="cls_020">char *p = "Message"; // 2</span></div>
<div style="position:absolute;left:96.00px;top:565.92px" class="cls_020"><span class="cls_020">s = p;</span></div>
<div style="position:absolute;left:221.97px;top:565.92px" class="cls_020"><span class="cls_020">// 3</span></div>
<div style="position:absolute;left:72.00px;top:588.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:614.76px" class="cls_006"><span class="cls_006">In statement 1, we construct the </span><span class="cls_020">String</span><span class="cls_006"> object </span><span class="cls_020">s</span><span class="cls_006"> using the default </span><span class="cls_020">String:: String()</span><span class="cls_006"> constructor.</span></div>
<div style="position:absolute;left:72.00px;top:627.60px" class="cls_006"><span class="cls_006">Later, in statement 3, we pour some real content into </span><span class="cls_020">s</span><span class="cls_006">. Object </span><span class="cls_020">s</span><span class="cls_006"> is really not complete until statement 3</span></div>
<div style="position:absolute;left:72.00px;top:639.84px" class="cls_006"><span class="cls_006">has been performed. As such, this is an inefficient construction. It entails</span></div>
<div style="position:absolute;left:90.00px;top:666.72px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The default </span><span class="cls_020">string</span><span class="cls_006"> constructor, statement 1</span></div>
<div style="position:absolute;left:90.00px;top:679.20px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The assignment operator, statement 3.</span></div>
<div style="position:absolute;left:72.00px;top:705.36px" class="cls_006"><span class="cls_006">The Lazy Evaluation principle can reduce this to a single constructor call. We do that by deferring</span></div>
<div style="position:absolute;left:72.00px;top:717.84px" class="cls_006"><span class="cls_006">construction of </span><span class="cls_020">string s</span><span class="cls_006"> until we have the necessary parts:</span></div>
<div style="position:absolute;left:72.00px;top:743.88px" class="cls_020"><span class="cls_020">void f()</span></div>
<div style="position:absolute;left:72.00px;top:755.16px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">138</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:129504px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background153.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">char *p = "Message";</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">string s(p);</span></div>
<div style="position:absolute;left:221.97px;top:81.84px" class="cls_020"><span class="cls_020">// invoke String::String(char*)</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:130.80px" class="cls_006"><span class="cls_006">By deferring the creation of </span><span class="cls_020">s</span><span class="cls_006"> we managed a single-step construction—definitely more efficient.</span></div>
<div style="position:absolute;left:72.00px;top:184.80px" class="cls_016"><span class="cls_016">Useless Computations</span></div>
<div style="position:absolute;left:72.00px;top:216.12px" class="cls_006"><span class="cls_006">Lazy Evaluation is about computations that are not always necessary, depending on execution flow.</span></div>
<div style="position:absolute;left:72.00px;top:228.12px" class="cls_006"><span class="cls_006">Useless computations are about those computations that are never necessary. These are entirely pointless</span></div>
<div style="position:absolute;left:72.00px;top:240.24px" class="cls_006"><span class="cls_006">computations whose results are never used regardless of execution flow.</span></div>
<div style="position:absolute;left:72.00px;top:266.28px" class="cls_006"><span class="cls_006">A subtle example of a useless computation is the wasted initialization of a member object.</span></div>
<div style="position:absolute;left:72.00px;top:292.08px" class="cls_020"><span class="cls_020">class Student {</span></div>
<div style="position:absolute;left:72.00px;top:303.36px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:314.64px" class="cls_020"><span class="cls_020">Student(char *nm);</span></div>
<div style="position:absolute;left:72.00px;top:337.32px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:348.72px" class="cls_020"><span class="cls_020">string name;</span></div>
<div style="position:absolute;left:72.00px;top:360.00px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:386.16px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">Student</span><span class="cls_006"> constructor turns the input character pointer into a </span><span class="cls_020">string</span><span class="cls_006"> object representing the student's</span></div>
<div style="position:absolute;left:72.00px;top:398.52px" class="cls_006"><span class="cls_006">name:</span></div>
<div style="position:absolute;left:72.00px;top:424.20px" class="cls_020"><span class="cls_020">Student::Student(char *nm)</span></div>
<div style="position:absolute;left:72.00px;top:435.48px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:446.88px" class="cls_020"><span class="cls_020">name = nm;</span></div>
<div style="position:absolute;left:72.00px;top:469.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:495.72px" class="cls_006"><span class="cls_006">C++ guarantees that all member objects have already been constructed before the body of the </span><span class="cls_020">Student</span></div>
<div style="position:absolute;left:72.00px;top:508.44px" class="cls_006"><span class="cls_006">constructor is executed. In our case it is the </span><span class="cls_020">string</span><span class="cls_006"> </span><span class="cls_020">name</span><span class="cls_006"> object. Since we did not tell the compiler</span></div>
<div style="position:absolute;left:72.00px;top:521.28px" class="cls_006"><span class="cls_006">explicitly how to do this, it silently inserts a call to the </span><span class="cls_020">string</span><span class="cls_006"> default constructor. That call is invoked</span></div>
<div style="position:absolute;left:72.00px;top:534.12px" class="cls_006"><span class="cls_006">prior to executing the body of the </span><span class="cls_020">Student</span><span class="cls_006"> constructor. The constructor body follows with an invocation</span></div>
<div style="position:absolute;left:72.00px;top:546.48px" class="cls_006"><span class="cls_006">of:</span></div>
<div style="position:absolute;left:72.00px;top:572.16px" class="cls_020"><span class="cls_020">name = nm;</span></div>
<div style="position:absolute;left:72.00px;top:598.32px" class="cls_006"><span class="cls_006">which essentially wipes away the previous contents of the </span><span class="cls_020">name</span><span class="cls_006"> object. We never used the results of the</span></div>
<div style="position:absolute;left:72.00px;top:611.16px" class="cls_006"><span class="cls_006">compiler-generated call to the </span><span class="cls_020">string</span><span class="cls_006"> default constructor. We can eliminate this pointless computation by</span></div>
<div style="position:absolute;left:72.00px;top:623.88px" class="cls_006"><span class="cls_006">specifying an explicit </span><span class="cls_020">string </span><span class="cls_006">constructor on the </span><span class="cls_020">Student</span><span class="cls_006"> constructor initialization list:</span></div>
<div style="position:absolute;left:72.00px;top:649.92px" class="cls_020"><span class="cls_020">Student::Student(char *nm) : name(nm) // explicit string constructor</span></div>
<div style="position:absolute;left:72.00px;top:661.20px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:683.88px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:710.04px" class="cls_006"><span class="cls_006">Since we explicitly told the compiler what </span><span class="cls_020">string</span><span class="cls_006"> constructor to use, the compiler does not generate the</span></div>
<div style="position:absolute;left:72.00px;top:722.88px" class="cls_006"><span class="cls_006">hidden call to the </span><span class="cls_020">string</span><span class="cls_006"> default constructor [</span><span class="cls_036">Mey97</span><span class="cls_006">]. Thus, we have achieved a single-step creation of</span></div>
<div style="position:absolute;left:72.00px;top:735.60px" class="cls_006"><span class="cls_006">the member </span><span class="cls_020">string</span><span class="cls_006"> object.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">139</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:130356px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background154.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:98.64px" class="cls_016"><span class="cls_016">System Architecture</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">The cost of memory access is far from being uniform. On one particular RISC architecture, data access</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">takes one CPU cycle if it resides in the data cache, 8 cycles if the data resides in main memory (cache</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">miss), and 400,000 cycles if the data is on disk (page fault). Although the exact number of cycles may vary,</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">the general picture is the same across processor architectures: The speed difference between a cache hit,</span></div>
<div style="position:absolute;left:72.00px;top:178.32px" class="cls_006"><span class="cls_006">cache miss, and page fault is measured in orders of magnitude.</span></div>
<div style="position:absolute;left:72.00px;top:204.36px" class="cls_006"><span class="cls_006">The data cache is the first place that is searched when data is accessed. If the data is not in the cache, a</span></div>
<div style="position:absolute;left:72.00px;top:216.36px" class="cls_006"><span class="cls_006">cache miss is generated by the hardware. The cache miss results in this data being loaded from RAM or</span></div>
<div style="position:absolute;left:72.00px;top:228.48px" class="cls_006"><span class="cls_006">disk into the cache. The cache is loaded in units of cache lines that are typically larger then the size of the</span></div>
<div style="position:absolute;left:72.00px;top:240.60px" class="cls_006"><span class="cls_006">specific data item we are after. A cache miss on a 4-byte integer may result in a cache line of 128 bytes</span></div>
<div style="position:absolute;left:72.00px;top:252.60px" class="cls_006"><span class="cls_006">loaded into cache. That's helpful because related data items tend to lie in close proximity in memory. If a</span></div>
<div style="position:absolute;left:72.00px;top:264.72px" class="cls_006"><span class="cls_006">subsequent instruction tries to access another data item on the same cache line, we will benefit from a</span></div>
<div style="position:absolute;left:72.00px;top:276.84px" class="cls_006"><span class="cls_006">cache hit the very first time we ask for that data. In as much as we can, we ought to help our code exhibit</span></div>
<div style="position:absolute;left:72.00px;top:288.84px" class="cls_006"><span class="cls_006">such locality of reference.</span></div>
<div style="position:absolute;left:72.00px;top:315.36px" class="cls_006"><span class="cls_006">Take the class </span><span class="cls_020">X</span><span class="cls_006"> for example:</span></div>
<div style="position:absolute;left:72.00px;top:341.40px" class="cls_020"><span class="cls_020">class X {</span></div>
<div style="position:absolute;left:72.00px;top:352.68px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:364.08px" class="cls_020"><span class="cls_020">X() : a(1), c(2) {}</span></div>
<div style="position:absolute;left:72.00px;top:386.64px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:398.04px" class="cls_020"><span class="cls_020">int a;</span></div>
<div style="position:absolute;left:96.00px;top:409.32px" class="cls_020"><span class="cls_020">char b[4096]; // buffer</span></div>
<div style="position:absolute;left:96.00px;top:420.72px" class="cls_020"><span class="cls_020">int c;</span></div>
<div style="position:absolute;left:72.00px;top:432.00px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:458.16px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">X::X()</span><span class="cls_006"> constructor initializes members </span><span class="cls_020">a</span><span class="cls_006"> and </span><span class="cls_020">c</span><span class="cls_006">. A standard-conforming compiler will lay out object</span></div>
<div style="position:absolute;left:72.00px;top:471.00px" class="cls_020"><span class="cls_020">X</span><span class="cls_006"> in the declaration order: members </span><span class="cls_020">a</span><span class="cls_006"> and </span><span class="cls_020">c</span><span class="cls_006"> will be separated by 4096 bytes of member </span><span class="cls_020">b</span><span class="cls_006">, and will not</span></div>
<div style="position:absolute;left:72.00px;top:483.72px" class="cls_006"><span class="cls_006">reside on the same cache line. The </span><span class="cls_020">X::X()</span><span class="cls_006"> constructor is likely to suffer a cache miss when it accesses </span><span class="cls_020">c</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:510.60px" class="cls_006"><span class="cls_006">Since </span><span class="cls_020">a</span><span class="cls_006"> and </span><span class="cls_020">c</span><span class="cls_006"> are accessed by neighboring instructions, we could be more cache-friendly by placing them</span></div>
<div style="position:absolute;left:72.00px;top:522.96px" class="cls_006"><span class="cls_006">next to one another:</span></div>
<div style="position:absolute;left:72.00px;top:548.64px" class="cls_020"><span class="cls_020">class X {</span></div>
<div style="position:absolute;left:72.00px;top:571.32px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:582.60px" class="cls_020"><span class="cls_020">int a;</span></div>
<div style="position:absolute;left:96.00px;top:593.88px" class="cls_020"><span class="cls_020">int c;</span></div>
<div style="position:absolute;left:96.00px;top:605.28px" class="cls_020"><span class="cls_020">char b[4096]; // buffer</span></div>
<div style="position:absolute;left:72.00px;top:616.56px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:642.84px" class="cls_020"><span class="cls_020">a</span><span class="cls_006"> and </span><span class="cls_020">c</span><span class="cls_006"> are more likely now to reside on the same cache line. Since </span><span class="cls_020">a</span><span class="cls_006"> is accessed prior to </span><span class="cls_020">c</span><span class="cls_006">, </span><span class="cls_020">c</span><span class="cls_006"> is almost</span></div>
<div style="position:absolute;left:72.00px;top:655.08px" class="cls_006"><span class="cls_006">guaranteed to reside in the data cache when we need it.</span></div>
<div style="position:absolute;left:72.00px;top:708.84px" class="cls_016"><span class="cls_016">Memory Management</span></div>
<div style="position:absolute;left:72.00px;top:740.16px" class="cls_006"><span class="cls_006">Allocating and deallocating heap memory on the fly is expensive. From a performance perspective, it is</span></div>
<div style="position:absolute;left:72.00px;top:752.28px" class="cls_006"><span class="cls_006">cheaper to work with memory that does not necessitate explicit management. An object defined as a local</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">140</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:131208px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background155.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">variable resides on the stack. Stack memory occupied by this object is part of the stack memory set aside</span></div>
<div style="position:absolute;left:72.00px;top:83.52px" class="cls_006"><span class="cls_006">for the function in whose scope the object is defined. The alternative to a local object is using </span><span class="cls_020">new()</span><span class="cls_006"> and</span></div>
<div style="position:absolute;left:72.00px;top:96.24px" class="cls_020"><span class="cls_020">delete()</span><span class="cls_006"> to acquire and release heap memory:</span></div>
<div style="position:absolute;left:72.00px;top:122.28px" class="cls_020"><span class="cls_020">void f()</span></div>
<div style="position:absolute;left:72.00px;top:133.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:144.96px" class="cls_020"><span class="cls_020">X *xPtr = new X;</span></div>
<div style="position:absolute;left:96.00px;top:167.52px" class="cls_020"><span class="cls_020">delete xPtr;</span></div>
<div style="position:absolute;left:72.00px;top:178.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:205.08px" class="cls_006"><span class="cls_006">A better performance choice would be to define a local object of type </span><span class="cls_020">X</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:231.00px" class="cls_020"><span class="cls_020">void f()</span></div>
<div style="position:absolute;left:72.00px;top:242.40px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:253.68px" class="cls_020"><span class="cls_020">X x;</span></div>
<div style="position:absolute;left:72.00px;top:276.36px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:90.00px;top:276.36px" class="cls_020"><span class="cls_020">// no need to delete x.</span></div>
<div style="position:absolute;left:72.00px;top:302.52px" class="cls_006"><span class="cls_006">In the latter implementation, object </span><span class="cls_020">x</span><span class="cls_006"> is on the stack. There's no need to allocate it up front, or to deallocate</span></div>
<div style="position:absolute;left:72.00px;top:315.36px" class="cls_006"><span class="cls_006">it upon exit. The stack memory is reclaimed automatically when </span><span class="cls_020">f()</span><span class="cls_006"> returns. We have saved the nontrivial</span></div>
<div style="position:absolute;left:72.00px;top:328.08px" class="cls_006"><span class="cls_006">cost of calling </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:354.48px" class="cls_006"><span class="cls_006">A similar issue exists with member data. This time it is not heap vs stack memory; it is the choice of</span></div>
<div style="position:absolute;left:72.00px;top:366.48px" class="cls_006"><span class="cls_006">embedding a pointer or a whole object in a containing object:</span></div>
<div style="position:absolute;left:72.00px;top:392.28px" class="cls_020"><span class="cls_020">class Z {</span></div>
<div style="position:absolute;left:72.00px;top:403.56px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:414.84px" class="cls_020"><span class="cls_020">Z() : xPtr (new X) {... }</span></div>
<div style="position:absolute;left:96.00px;top:426.24px" class="cls_020"><span class="cls_020">~Z() {delete xPtr; ... }</span></div>
<div style="position:absolute;left:72.00px;top:448.92px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:460.20px" class="cls_020"><span class="cls_020">X *xPtr;</span></div>
<div style="position:absolute;left:72.00px;top:482.88px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:509.04px" class="cls_006"><span class="cls_006">The cost of a </span><span class="cls_020">Z</span><span class="cls_006"> object is significantly increased by the overhead of calling </span><span class="cls_020">new()</span><span class="cls_006"> in the constructor and</span></div>
<div style="position:absolute;left:72.00px;top:521.88px" class="cls_020"><span class="cls_020">delete()</span><span class="cls_006"> in the destructor. We could eliminate the cost of memory management by embedding the </span><span class="cls_020">X</span></div>
<div style="position:absolute;left:72.00px;top:534.60px" class="cls_006"><span class="cls_006">object within </span><span class="cls_020">Z</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:560.64px" class="cls_020"><span class="cls_020">class Z {</span></div>
<div style="position:absolute;left:72.00px;top:571.92px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:583.20px" class="cls_020"><span class="cls_020">Z()</span></div>
<div style="position:absolute;left:125.99px;top:583.20px" class="cls_020"><span class="cls_020">{... }</span></div>
<div style="position:absolute;left:96.00px;top:594.60px" class="cls_020"><span class="cls_020">~Z() {... }</span></div>
<div style="position:absolute;left:72.00px;top:617.28px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:628.56px" class="cls_020"><span class="cls_020">X x;</span></div>
<div style="position:absolute;left:72.00px;top:651.24px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:677.40px" class="cls_006"><span class="cls_006">By replacing an </span><span class="cls_020">X</span><span class="cls_006"> pointer with an </span><span class="cls_020">X</span><span class="cls_006"> object, we have traded away the option of using this member</span></div>
<div style="position:absolute;left:72.00px;top:689.76px" class="cls_006"><span class="cls_006">polymorphically. If you really need that flexibility then this optimization is not available to you. Once</span></div>
<div style="position:absolute;left:72.00px;top:701.76px" class="cls_006"><span class="cls_006">again, performance is about trade-offs.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">141</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:132060px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background156.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.80px" class="cls_016"><span class="cls_016">Library and System Calls</span></div>
<div style="position:absolute;left:72.00px;top:102.12px" class="cls_006"><span class="cls_006">The evolution of computer languages steadily has simplified the task of designing and coding solutions to</span></div>
<div style="position:absolute;left:72.00px;top:114.24px" class="cls_006"><span class="cls_006">complex problems. As languages moved forward in expressive power, we used them to tackle problems of</span></div>
<div style="position:absolute;left:72.00px;top:126.36px" class="cls_006"><span class="cls_006">higher complexity. Theoretically, a Turing Machine with its primitive syntax is as powerful as any</span></div>
<div style="position:absolute;left:72.00px;top:138.36px" class="cls_006"><span class="cls_006">programming language we have today. By powerful we mean you can code any algorithm using a Turing</span></div>
<div style="position:absolute;left:72.00px;top:150.48px" class="cls_006"><span class="cls_006">Machine. It is just a very difficult environment in which to program. The same goes for assembly language.</span></div>
<div style="position:absolute;left:72.00px;top:162.48px" class="cls_006"><span class="cls_006">The reason we don't develop Web servers in assembly is of a practical nature: It is too difficult and time-</span></div>
<div style="position:absolute;left:72.00px;top:174.60px" class="cls_006"><span class="cls_006">consuming to develop software solutions to complex problems using low-level languages.</span></div>
<div style="position:absolute;left:72.00px;top:200.64px" class="cls_006"><span class="cls_006">If we want to add two integers, it is very simple in a language such as C++:</span></div>
<div style="position:absolute;left:72.00px;top:226.44px" class="cls_020"><span class="cls_020">k = i + j;</span></div>
<div style="position:absolute;left:72.00px;top:252.00px" class="cls_006"><span class="cls_006">If we tried it in assembly language, there would be minute details we would have to handle ourselves:</span></div>
<div style="position:absolute;left:90.00px;top:278.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Load integer </span><span class="cls_020">i</span><span class="cls_006"> to register X</span></div>
<div style="position:absolute;left:90.00px;top:291.96px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Load integer </span><span class="cls_020">j</span><span class="cls_006"> to register Y.</span></div>
<div style="position:absolute;left:90.00px;top:304.56px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Add contents of registers X and Y.</span></div>
<div style="position:absolute;left:90.00px;top:317.28px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Store the result in memory address of integer </span><span class="cls_020">k</span></div>
<div style="position:absolute;left:72.00px;top:343.68px" class="cls_006"><span class="cls_006">In a higher level language, all those little details are handled by the compiler, and we normally ignore it.</span></div>
<div style="position:absolute;left:72.00px;top:355.68px" class="cls_006"><span class="cls_006">This simplicity leads to higher productivity and the ability to take on programming tasks of higher</span></div>
<div style="position:absolute;left:72.00px;top:367.80px" class="cls_006"><span class="cls_006">complexity.</span></div>
<div style="position:absolute;left:72.00px;top:393.84px" class="cls_006"><span class="cls_006">There are several ways to hide complexity: We can hide it in hardware and in software. Software hiding is</span></div>
<div style="position:absolute;left:72.00px;top:405.96px" class="cls_006"><span class="cls_006">accomplished by the compiler transforming our source code to assembly instructions. We could also</span></div>
<div style="position:absolute;left:72.00px;top:418.08px" class="cls_006"><span class="cls_006">perform it ourselves: We can encapsulate complexity away in system calls, libraries, and class</span></div>
<div style="position:absolute;left:72.00px;top:430.08px" class="cls_006"><span class="cls_006">implementations.</span></div>
<div style="position:absolute;left:72.00px;top:456.12px" class="cls_006"><span class="cls_006">Take the case of concatenating two strings. We need to allocate memory large enough to contain both</span></div>
<div style="position:absolute;left:72.00px;top:468.24px" class="cls_006"><span class="cls_006">strings plus a terminating null:</span></div>
<div style="position:absolute;left:72.00px;top:493.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:505.32px" class="cls_020"><span class="cls_020">char s0;</span></div>
<div style="position:absolute;left:96.00px;top:516.60px" class="cls_020"><span class="cls_020">char *s1 = "Hello";</span></div>
<div style="position:absolute;left:96.00px;top:528.00px" class="cls_020"><span class="cls_020">char *s2 = "World";</span></div>
<div style="position:absolute;left:96.00px;top:550.56px" class="cls_020"><span class="cls_020">s0 = (char *) malloc ( strlen(s1) + strlen(s2) + 1 );</span></div>
<div style="position:absolute;left:96.00px;top:561.96px" class="cls_020"><span class="cls_020">strcpy(s0,s1);</span></div>
<div style="position:absolute;left:197.98px;top:561.96px" class="cls_020"><span class="cls_020">// Copy first string</span></div>
<div style="position:absolute;left:96.00px;top:573.24px" class="cls_020"><span class="cls_020">strcat(s0,s2);</span></div>
<div style="position:absolute;left:197.98px;top:573.24px" class="cls_020"><span class="cls_020">// Concatenate the second</span></div>
<div style="position:absolute;left:72.00px;top:595.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:622.08px" class="cls_006"><span class="cls_006">In C++, all these details are encapsulated in a </span><span class="cls_020">string</span><span class="cls_006"> class implementation. The overloaded "+" operator</span></div>
<div style="position:absolute;left:72.00px;top:634.92px" class="cls_006"><span class="cls_006">for </span><span class="cls_020">string</span><span class="cls_006"> would simplify our client code to this:</span></div>
<div style="position:absolute;left:72.00px;top:660.84px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:672.24px" class="cls_020"><span class="cls_020">string s1 = "Hello";</span></div>
<div style="position:absolute;left:96.00px;top:683.52px" class="cls_020"><span class="cls_020">string s2 = "World";</span></div>
<div style="position:absolute;left:96.00px;top:706.20px" class="cls_020"><span class="cls_020">string s0 = s1 + s2;</span></div>
<div style="position:absolute;left:72.00px;top:728.88px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">142</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:132912px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background157.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">As we move to higher levels of programming simplicity, the detailed work does not vanish; it is done</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">elsewhere. From a performance standpoint we cannot ignore the work that is done under the covers. That's</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">where the performance engineer differs from the rest of the developers, whose only concern is to put</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">together the necessary functionality rapidly and ship it. The performance developer must be aware of</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">hidden costs as they may have a profound impact on system performance.</span></div>
<div style="position:absolute;left:72.00px;top:145.80px" class="cls_006"><span class="cls_006">For concrete examples we peek into the implementation of the </span><span class="cls_020">pthreads</span><span class="cls_006"> library. This library provides</span></div>
<div style="position:absolute;left:72.00px;top:158.52px" class="cls_006"><span class="cls_006">the user with a simple interface to thread services on UNIX platforms. The </span><span class="cls_020">pthread_mutex_lock()</span></div>
<div style="position:absolute;left:72.00px;top:171.36px" class="cls_006"><span class="cls_006">and </span><span class="cls_020">pthread_mutex_unlock()</span><span class="cls_006"> calls provide mutual exclusion. If you lock a resource, you have</span></div>
<div style="position:absolute;left:72.00px;top:184.20px" class="cls_006"><span class="cls_006">exclusive access to it until you unlock it. What you don't see is that the </span><span class="cls_020">pthreads</span><span class="cls_006"> library implementation</span></div>
<div style="position:absolute;left:72.00px;top:197.04px" class="cls_006"><span class="cls_006">checks that your thread does not already own the lock when </span><span class="cls_020">pthread_mutex_lock()</span><span class="cls_006"> is called. That</span></div>
<div style="position:absolute;left:72.00px;top:209.76px" class="cls_006"><span class="cls_006">prevents deadlocks. When you call </span><span class="cls_020">pthread_mutex_unlock()</span><span class="cls_006"> a check is performed to see that the</span></div>
<div style="position:absolute;left:72.00px;top:222.12px" class="cls_006"><span class="cls_006">caller actually holds the lock. A thread cannot unlock a resource unless it is the one that locked it</span></div>
<div style="position:absolute;left:72.00px;top:234.24px" class="cls_006"><span class="cls_006">previously. All these necessary error checks increase the pathlength of execution and slow down</span></div>
<div style="position:absolute;left:72.00px;top:246.24px" class="cls_006"><span class="cls_006">performance.</span></div>
<div style="position:absolute;left:72.00px;top:272.40px" class="cls_006"><span class="cls_006">In many situations, your application's use of locks may be simple enough, where all this overhead is a</span></div>
<div style="position:absolute;left:72.00px;top:284.40px" class="cls_006"><span class="cls_006">waste. The design of your code may already guarantee the preconditions: that the locking thread does not</span></div>
<div style="position:absolute;left:72.00px;top:296.52px" class="cls_006"><span class="cls_006">presently hold the lock and that the unlocking thread is the one that has it locked. In that case, you can</span></div>
<div style="position:absolute;left:72.00px;top:308.52px" class="cls_006"><span class="cls_006">build a simple locking scheme that builds upon primitive building blocks supplied by the native operating</span></div>
<div style="position:absolute;left:72.00px;top:320.64px" class="cls_006"><span class="cls_006">system. That will be significantly more efficient. If you are not aware of the details of a library</span></div>
<div style="position:absolute;left:72.00px;top:332.76px" class="cls_006"><span class="cls_006">implementation, you may not know that you are paying a performance cost for functionality you don't</span></div>
<div style="position:absolute;left:72.00px;top:344.76px" class="cls_006"><span class="cls_006">really need.</span></div>
<div style="position:absolute;left:72.00px;top:371.40px" class="cls_006"><span class="cls_006">We stay in the realm of the </span><span class="cls_020">pthreads</span><span class="cls_006"> library for a related example. You can associate each thread with a</span></div>
<div style="position:absolute;left:72.00px;top:383.64px" class="cls_006"><span class="cls_006">private data area where thread globals may be stored [</span><span class="cls_036">NBF96</span><span class="cls_006">]. If you need access to thread private data</span></div>
<div style="position:absolute;left:72.00px;top:395.76px" class="cls_006"><span class="cls_006">you need a pointer to that thread-specific area in memory. You can get that pointer by calling</span></div>
<div style="position:absolute;left:72.00px;top:408.24px" class="cls_020"><span class="cls_020">pthread_getspecific()</span><span class="cls_006">. The </span><span class="cls_020">pthreads</span><span class="cls_006"> library performs this magic by keeping an association</span></div>
<div style="position:absolute;left:72.00px;top:420.60px" class="cls_006"><span class="cls_006">between current threads and their private data. Since threads can come and go, this association is dynamic.</span></div>
<div style="position:absolute;left:72.00px;top:433.20px" class="cls_006"><span class="cls_006">Access to this collection must be serialized. As a result, a call to </span><span class="cls_020">pthread_getspecific()</span><span class="cls_006"> hides an</span></div>
<div style="position:absolute;left:72.00px;top:445.56px" class="cls_006"><span class="cls_006">internal serialization code. We must lock the collection while retrieving the data associated with the given</span></div>
<div style="position:absolute;left:72.00px;top:457.56px" class="cls_006"><span class="cls_006">thread. This is something you may need to know if you are concerned with scalability. If multiple threads</span></div>
<div style="position:absolute;left:72.00px;top:470.16px" class="cls_006"><span class="cls_006">perform frequent calls to </span><span class="cls_020">pthread_getspecific()</span><span class="cls_006">, the serialization logic will cause a scalability</span></div>
<div style="position:absolute;left:72.00px;top:482.40px" class="cls_006"><span class="cls_006">logjam as the threads lock each other out.</span></div>
<div style="position:absolute;left:72.00px;top:509.04px" class="cls_006"><span class="cls_006">Once you are aware of the internals of </span><span class="cls_020">pthread_getspecific()</span><span class="cls_006"> you may opt to use other methods to</span></div>
<div style="position:absolute;left:72.00px;top:521.28px" class="cls_006"><span class="cls_006">pass thread-specific data around. Instead of making a data item a thread global, you could just pass it</span></div>
<div style="position:absolute;left:72.00px;top:533.40px" class="cls_006"><span class="cls_006">around as a function call parameter. If you truly need frequent access to thread global variables, you could</span></div>
<div style="position:absolute;left:72.00px;top:546.00px" class="cls_006"><span class="cls_006">perform the </span><span class="cls_020">pthread_getspecific()</span><span class="cls_006"> call once and then pass the pointer around as a function call</span></div>
<div style="position:absolute;left:72.00px;top:558.24px" class="cls_006"><span class="cls_006">parameter.</span></div>
<div style="position:absolute;left:72.00px;top:612.12px" class="cls_016"><span class="cls_016">Compiler Optimization</span></div>
<div style="position:absolute;left:72.00px;top:643.44px" class="cls_006"><span class="cls_006">There are quite a few important optimizations that a decent compiler can apply on your behalf without</span></div>
<div style="position:absolute;left:72.00px;top:655.44px" class="cls_006"><span class="cls_006">requiring any source code intervention on your part. The first optimization that comes to mind is register</span></div>
<div style="position:absolute;left:72.00px;top:667.56px" class="cls_006"><span class="cls_006">allocation. Loading and storing a variable is fastest when that variable resides in a register. Otherwise, we</span></div>
<div style="position:absolute;left:72.00px;top:679.68px" class="cls_006"><span class="cls_006">are going to have to spend a few cycles fetching this variable from elsewhere. If an update is performed,</span></div>
<div style="position:absolute;left:72.00px;top:691.68px" class="cls_006"><span class="cls_006">we will also need to store it back where it came from. In that case, it gets even worse if the variable is not</span></div>
<div style="position:absolute;left:72.00px;top:703.80px" class="cls_006"><span class="cls_006">in the cache. A single memory access on modern architecture is upwards of five cycles. All this is avoided</span></div>
<div style="position:absolute;left:72.00px;top:715.80px" class="cls_006"><span class="cls_006">if the variable resides in a register. Register allocation is an important optimization because its application</span></div>
<div style="position:absolute;left:72.00px;top:727.92px" class="cls_006"><span class="cls_006">is available on many of the methods along the execution path. This is particularly significant when it</span></div>
<div style="position:absolute;left:72.00px;top:740.04px" class="cls_006"><span class="cls_006">comes to loop index variables. Those variables are accessed and updated at every iteration of the loop.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">143</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:133764px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background158.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">A second dominant optimization that we strongly care about is inlining. </span><span class="cls_036">Chapters 8</span><span class="cls_006">, </span><span class="cls_036">9</span><span class="cls_006">, and </span><span class="cls_036">10</span><span class="cls_006"> already</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">stressed the point that inlining could significantly help performance of many C++ applications. Another</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">optimization of interest to C++ programmers is the return value optimization discussed in </span><span class="cls_036">Chapter 4</span><span class="cls_006">. The</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">list goes on. For a more exhaustive enumeration of various compiler optimizations see [</span><span class="cls_036">O98</span><span class="cls_006">]. The point we</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">are trying to make is not necessarily to list all possible optimizations but to raise awareness to the fact that</span></div>
<div style="position:absolute;left:72.00px;top:131.28px" class="cls_006"><span class="cls_006">you cannot take them for granted.</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">It is often the case that by default the compiler does not perform any optimization at all. That means that</span></div>
<div style="position:absolute;left:72.00px;top:169.92px" class="cls_006"><span class="cls_006">these important speed optimizations will not take place—not even if you place the </span><span class="cls_020">register</span><span class="cls_006"> and</span></div>
<div style="position:absolute;left:72.00px;top:182.76px" class="cls_020"><span class="cls_020">inline</span><span class="cls_006"> keywords in your code. The compiler is free to ignore them, and it often does. To enhance your</span></div>
<div style="position:absolute;left:72.00px;top:195.00px" class="cls_006"><span class="cls_006">chance at those optimizations you have to turn on compiler optimization manually by adding a switch to</span></div>
<div style="position:absolute;left:72.00px;top:207.12px" class="cls_006"><span class="cls_006">the command line (-O on UNIX flavors) or selecting the speed optimization option on your GUI interface.</span></div>
<div style="position:absolute;left:72.00px;top:233.16px" class="cls_006"><span class="cls_006">It's hard to quantify the effect of compiler optimizations precisely since it varies from one application to</span></div>
<div style="position:absolute;left:72.00px;top:245.28px" class="cls_006"><span class="cls_006">another. In our experience we have seen a 20-40% speedup on various applications. This is significant</span></div>
<div style="position:absolute;left:72.00px;top:257.40px" class="cls_006"><span class="cls_006">"low hanging fruit."</span></div>
<div style="position:absolute;left:72.00px;top:311.16px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:72.00px;top:342.48px" class="cls_006"><span class="cls_006">Coding optimizations are local in scope and do not necessitate understanding of overall program design.</span></div>
<div style="position:absolute;left:72.00px;top:354.60px" class="cls_006"><span class="cls_006">This is a good place to start when you join an ongoing project whose design you don't yet understand.</span></div>
<div style="position:absolute;left:72.00px;top:380.64px" class="cls_006"><span class="cls_006">The fastest code is the one that's never executed. Try the following to bail out of a costly computation:</span></div>
<div style="position:absolute;left:90.00px;top:406.92px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Are you ever going to use the result? It sounds silly, but it happens. At times we perform</span></div>
<div style="position:absolute;left:108.00px;top:419.04px" class="cls_006"><span class="cls_006">computation and never use the results.</span></div>
<div style="position:absolute;left:90.00px;top:431.28px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Do you need the results now? Defer a computation to the point where it is actually needed.</span></div>
<div style="position:absolute;left:108.00px;top:443.40px" class="cls_006"><span class="cls_006">Premature computations may never be used on some execution flows.</span></div>
<div style="position:absolute;left:90.00px;top:455.76px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Do you know the result already? We have seen costly computations performed even though their</span></div>
<div style="position:absolute;left:108.00px;top:467.76px" class="cls_006"><span class="cls_006">results were available two lines above. If you already computed it earlier in the execution flow,</span></div>
<div style="position:absolute;left:108.00px;top:479.88px" class="cls_006"><span class="cls_006">make the result available for reuse.</span></div>
<div style="position:absolute;left:72.00px;top:505.92px" class="cls_006"><span class="cls_006">Sometimes you cannot bail out, and you just have to perform the computation. The challenge now is to</span></div>
<div style="position:absolute;left:72.00px;top:518.04px" class="cls_006"><span class="cls_006">speed it up:</span></div>
<div style="position:absolute;left:90.00px;top:544.32px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Is the computation overly generic? You only need to be as flexible as the domain requires, not</span></div>
<div style="position:absolute;left:108.00px;top:556.44px" class="cls_006"><span class="cls_006">more. Take advantage of simplifying assumptions. Reduced flexibility increases speed.</span></div>
<div style="position:absolute;left:90.00px;top:568.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Some flexibility is hidden in library calls. You may gain speed by rolling your own version of</span></div>
<div style="position:absolute;left:108.00px;top:580.80px" class="cls_006"><span class="cls_006">specific library calls that are called often enough to justify the effort. Familiarize yourself with the</span></div>
<div style="position:absolute;left:108.00px;top:592.92px" class="cls_006"><span class="cls_006">hidden cost of those library and system calls that you use.</span></div>
<div style="position:absolute;left:90.00px;top:605.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Minimize memory management calls. They are relatively expensive on most compilers.</span></div>
<div style="position:absolute;left:90.00px;top:617.52px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   If you consider the set of all possible input data, 20% of it shows up 80% of the time. Speed up the</span></div>
<div style="position:absolute;left:108.00px;top:629.64px" class="cls_006"><span class="cls_006">processing of typical input at the expense of other scenarios.</span></div>
<div style="position:absolute;left:90.00px;top:642.00px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The speed differential among cache, RAM, and disk access is significant. Write cache-friendly</span></div>
<div style="position:absolute;left:108.00px;top:654.00px" class="cls_006"><span class="cls_006">code.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">144</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:134616px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background159.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 14. Design Optimizations</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">Performance optimizations can roughly be divided into two major categories: coding and design. We</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">define a coding optimization as one that does not necessitate overall understanding of the problem domain</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">or the application's execution flow. Coding optimizations are by definition localized and well isolated from</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">the surrounding code. Design optimizations are what's left, everything but the "low hanging fruit." These</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">optimizations are systemic—they have dependencies on other components and remote parts of the code. A</span></div>
<div style="position:absolute;left:72.00px;top:178.32px" class="cls_006"><span class="cls_006">design optimization will often leave its fingerprints throughout the code. This is not exactly a precise</span></div>
<div style="position:absolute;left:72.00px;top:190.32px" class="cls_006"><span class="cls_006">mathematical definition, and some optimizations will fall in the gray area created by this imprecise</span></div>
<div style="position:absolute;left:72.00px;top:202.44px" class="cls_006"><span class="cls_006">definition. The overall idea should become clearer with the examples provided in this chapter.</span></div>
<div style="position:absolute;left:72.00px;top:256.20px" class="cls_016"><span class="cls_016">Design Flexibility</span></div>
<div style="position:absolute;left:72.00px;top:287.52px" class="cls_006"><span class="cls_006">In the last ten years we have encountered quite a few C++ projects that fell far short of their required</span></div>
<div style="position:absolute;left:72.00px;top:299.64px" class="cls_006"><span class="cls_006">performance. At the heart of those performance failures was a design and an implementation geared for</span></div>
<div style="position:absolute;left:72.00px;top:311.64px" class="cls_006"><span class="cls_006">extreme flexibility and reusability. The obsession with reusable code has produced software that, due to the</span></div>
<div style="position:absolute;left:72.00px;top:323.76px" class="cls_006"><span class="cls_006">lack of efficiency, was not even usable, not to mention reusable. C++ ushered OO programming into the</span></div>
<div style="position:absolute;left:72.00px;top:335.88px" class="cls_006"><span class="cls_006">mainstream and paved the way for the enthusiastic adoption of OO by the wide programming community.</span></div>
<div style="position:absolute;left:72.00px;top:347.88px" class="cls_006"><span class="cls_006">The OO education machinery has transformed C programmers into a new generation whose main focus</span></div>
<div style="position:absolute;left:72.00px;top:360.00px" class="cls_006"><span class="cls_006">was the creation of generic, flexible, and reusable software. The problem is that performance and</span></div>
<div style="position:absolute;left:72.00px;top:372.00px" class="cls_006"><span class="cls_006">flexibility are often enemies. It is not an artifact of poor design or of implementation. We are talking about</span></div>
<div style="position:absolute;left:72.00px;top:384.12px" class="cls_006"><span class="cls_006">a fundamental tension between two forces that are pushing in opposite directions. In mathematics, if the</span></div>
<div style="position:absolute;left:72.00px;top:396.24px" class="cls_006"><span class="cls_006">product of X*Y is a constant, then as X becomes larger, Y must become smaller. Period. Generally</span></div>
<div style="position:absolute;left:72.00px;top:408.24px" class="cls_006"><span class="cls_006">speaking, there's a similar relationship between performance and flexibility.</span></div>
<div style="position:absolute;left:72.00px;top:434.40px" class="cls_006"><span class="cls_006">If you try making the counterpoint that performance and flexibility could actually coexist in peace, you'd</span></div>
<div style="position:absolute;left:72.00px;top:446.40px" class="cls_006"><span class="cls_006">probably throw in the STL (Standard Template Library) as evidence. The STL is powerful, generic,</span></div>
<div style="position:absolute;left:72.00px;top:458.52px" class="cls_006"><span class="cls_006">flexible, and extendible. The STL, in some cases, generates code whose performance can rival that of</span></div>
<div style="position:absolute;left:72.00px;top:470.52px" class="cls_006"><span class="cls_006">hand-coded C. It seems to defeat our proposition. Let's take a closer look.</span></div>
<div style="position:absolute;left:72.00px;top:497.16px" class="cls_006"><span class="cls_006">Take the STL's </span><span class="cls_020">accumulate()</span><span class="cls_006"> template function; it is capable of adding an arbitrary collection of</span></div>
<div style="position:absolute;left:72.00px;top:509.40px" class="cls_006"><span class="cls_006">objects. It takes three parameters:</span></div>
<div style="position:absolute;left:90.00px;top:535.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   An iterator pointing to the start of the collection</span></div>
<div style="position:absolute;left:90.00px;top:548.04px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   An iterator indicating the end of the collection</span></div>
<div style="position:absolute;left:90.00px;top:560.40px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   An initial value</span></div>
<div style="position:absolute;left:72.00px;top:586.92px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">accumulate()</span><span class="cls_006"> function will iterate from start to finish adding objects to its initial value. It is</span></div>
<div style="position:absolute;left:72.00px;top:599.28px" class="cls_006"><span class="cls_006">capable of adding a diverse set of objects: integers, floats, characters, strings, and even user-defined types.</span></div>
<div style="position:absolute;left:72.00px;top:611.40px" class="cls_006"><span class="cls_006">It does not care if the collection is an array, list, vector, or any other collection. All it cares about is that</span></div>
<div style="position:absolute;left:72.00px;top:623.40px" class="cls_006"><span class="cls_006">you pass in the two required iterators to control the start and finish of the iteration. Furthermore,</span></div>
<div style="position:absolute;left:72.00px;top:636.00px" class="cls_020"><span class="cls_020">accumulate()</span><span class="cls_006"> is also capable of performing other binary operations, not just additions. You can specify</span></div>
<div style="position:absolute;left:72.00px;top:648.36px" class="cls_006"><span class="cls_006">the binary operator as an optional argument.</span></div>
<div style="position:absolute;left:72.00px;top:674.88px" class="cls_006"><span class="cls_006">Obviously, this is a fine piece of code. It is highly flexible and generic. At times, </span><span class="cls_020">accumulate()</span><span class="cls_006"> will</span></div>
<div style="position:absolute;left:72.00px;top:687.24px" class="cls_006"><span class="cls_006">even exhibit superb performance. It can add an array of integers such as</span></div>
<div style="position:absolute;left:72.00px;top:712.92px" class="cls_020"><span class="cls_020">sum = accumulate(&x[0], &x[100], 0);</span></div>
<div style="position:absolute;left:72.00px;top:738.48px" class="cls_006"><span class="cls_006">just as fast as your home-grown version:</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">145</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:135468px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background160.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">int sum = 0;</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">for (int i = 0; i &lt; 100; i++) {</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">sum += x[i];</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">This is pretty good. The implementation of the </span><span class="cls_020">accumulate()</span><span class="cls_006"> function is something along the lines of</span></div>
<div style="position:absolute;left:72.00px;top:154.32px" class="cls_006"><span class="cls_006">[</span><span class="cls_036">MS96</span><span class="cls_006">]:</span></div>
<div style="position:absolute;left:72.00px;top:180.12px" class="cls_020"><span class="cls_020">template &lt;class InputIterator, class T></span></div>
<div style="position:absolute;left:72.00px;top:191.40px" class="cls_020"><span class="cls_020">T accumulate(InputIterator first,</span></div>
<div style="position:absolute;left:149.99px;top:202.68px" class="cls_020"><span class="cls_020">InputIterator beyondLast,</span></div>
<div style="position:absolute;left:149.99px;top:214.08px" class="cls_020"><span class="cls_020">T initialValue)</span></div>
<div style="position:absolute;left:72.00px;top:225.36px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:236.76px" class="cls_020"><span class="cls_020">while (first != beyondLast) {</span></div>
<div style="position:absolute;left:119.99px;top:248.04px" class="cls_020"><span class="cls_020">initialValue = initialValue + *first++;</span></div>
<div style="position:absolute;left:96.00px;top:259.32px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:270.72px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:296.88px" class="cls_006"><span class="cls_006">The strength of the </span><span class="cls_020">accumulate(</span><span class="cls_006">) implementation stems from the fact that it makes very few</span></div>
<div style="position:absolute;left:72.00px;top:309.24px" class="cls_006"><span class="cls_006">assumptions about the collection and the objects contained in it. It knows only two things:</span></div>
<div style="position:absolute;left:90.00px;top:336.00px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Starting from the </span><span class="cls_020">first</span><span class="cls_006"> iterator, it will advance sequentially, eventually running into the</span></div>
<div style="position:absolute;left:108.00px;top:348.84px" class="cls_020"><span class="cls_020">beyondLast</span><span class="cls_006"> iterator.</span></div>
<div style="position:absolute;left:90.00px;top:361.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The objects contained in the collection are acceptable arguments to the </span><span class="cls_020">+</span><span class="cls_006"> operator.</span></div>
<div style="position:absolute;left:72.00px;top:388.68px" class="cls_006"><span class="cls_006">These two minimal assumptions allow </span><span class="cls_020">accumulate()</span><span class="cls_006"> its extreme flexibility. They could also become its</span></div>
<div style="position:absolute;left:72.00px;top:401.04px" class="cls_006"><span class="cls_006">performance weakness. Those assumptions may suffice for high-performance integer addition, but other</span></div>
<div style="position:absolute;left:72.00px;top:413.52px" class="cls_006"><span class="cls_006">classes with richer structure will have to forgo the benefit of their class-specific knowledge. Take </span><span class="cls_020">string</span></div>
<div style="position:absolute;left:72.00px;top:425.88px" class="cls_006"><span class="cls_006">for example. Suppose you wanted to concatenate a collection of strings such as:</span></div>
<div style="position:absolute;left:72.00px;top:451.56px" class="cls_020"><span class="cls_020">vector&lt;string> vectorx;</span></div>
<div style="position:absolute;left:72.00px;top:474.24px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; 100; i++) {</span></div>
<div style="position:absolute;left:96.00px;top:485.52px" class="cls_020"><span class="cls_020">vectorx.push_back("abcd");</span></div>
<div style="position:absolute;left:72.00px;top:496.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:523.08px" class="cls_006"><span class="cls_006">Using </span><span class="cls_020">accumulate()</span><span class="cls_006"> should be your first choice. You don't want to reinvent the wheel unless you have</span></div>
<div style="position:absolute;left:72.00px;top:535.44px" class="cls_006"><span class="cls_006">a compelling reason to do so:</span></div>
<div style="position:absolute;left:72.00px;top:561.12px" class="cls_020"><span class="cls_020">string empty;</span></div>
<div style="position:absolute;left:209.97px;top:561.12px" class="cls_020"><span class="cls_020">// initial value for result string.</span></div>
<div style="position:absolute;left:72.00px;top:583.80px" class="cls_020"><span class="cls_020">result = accumulate(vectorx.begin(), vectorx.end(), empty);</span></div>
<div style="position:absolute;left:72.00px;top:609.36px" class="cls_006"><span class="cls_006">This would do it, but how fast is it? We timed 100,000 iterations of this code as follows:</span></div>
<div style="position:absolute;left:72.00px;top:635.16px" class="cls_020"><span class="cls_020">string empty;</span></div>
<div style="position:absolute;left:209.97px;top:635.16px" class="cls_020"><span class="cls_020">// initial value for result string.</span></div>
<div style="position:absolute;left:72.00px;top:657.84px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; 100000; i++) {</span></div>
<div style="position:absolute;left:96.00px;top:669.12px" class="cls_020"><span class="cls_020">result = accumulate(vectorx.begin(), vectorx.end(), empty);</span></div>
<div style="position:absolute;left:72.00px;top:680.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:706.20px" class="cls_006"><span class="cls_006">This code snippet elapsed in 29 seconds. Can we beat the STL by crafting a home-grown solution? We</span></div>
<div style="position:absolute;left:72.00px;top:718.20px" class="cls_006"><span class="cls_006">tried the following:</span></div>
<div style="position:absolute;left:72.00px;top:744.00px" class="cls_020"><span class="cls_020">void stringSum1(vector&lt;string> vs, string& result)</span></div>
<div style="position:absolute;left:72.00px;top:755.28px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">146</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:136320px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background161.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">int i=0;</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">int totalInputLength = 0;</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">int vectorSize = vs.size();</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">int *stringSizes = new int[vectorSize];</span></div>
<div style="position:absolute;left:96.00px;top:127.20px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; vectorSize; i++) {</span></div>
<div style="position:absolute;left:119.99px;top:138.48px" class="cls_020"><span class="cls_020">stringSizes[i] = vs[i].length();</span></div>
<div style="position:absolute;left:119.99px;top:149.88px" class="cls_020"><span class="cls_020">totalInputLength += stringSizes[i];</span></div>
<div style="position:absolute;left:96.00px;top:161.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:183.84px" class="cls_020"><span class="cls_020">char* s = new char [totalInputLength+1];</span></div>
<div style="position:absolute;left:96.00px;top:206.52px" class="cls_020"><span class="cls_020">int sp = 0;</span></div>
<div style="position:absolute;left:96.00px;top:217.80px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; vectorSize; i++) {</span></div>
<div style="position:absolute;left:119.99px;top:229.20px" class="cls_020"><span class="cls_020">memcpy(&s[sp], vs[i].c_str(), stringSizes[i]);</span></div>
<div style="position:absolute;left:119.99px;top:240.48px" class="cls_020"><span class="cls_020">sp += stringSizes[i];</span></div>
<div style="position:absolute;left:96.00px;top:251.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:274.44px" class="cls_020"><span class="cls_020">delete stringSizes;</span></div>
<div style="position:absolute;left:96.00px;top:285.84px" class="cls_020"><span class="cls_020">result = s;</span></div>
<div style="position:absolute;left:96.00px;top:308.40px" class="cls_020"><span class="cls_020">return;</span></div>
<div style="position:absolute;left:72.00px;top:319.80px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:345.36px" class="cls_006"><span class="cls_006">We timed this solution as well:</span></div>
<div style="position:absolute;left:72.00px;top:371.16px" class="cls_020"><span class="cls_020">string result;</span></div>
<div style="position:absolute;left:173.98px;top:371.16px" class="cls_020"><span class="cls_020">// initial value for result string.</span></div>
<div style="position:absolute;left:72.00px;top:393.84px" class="cls_020"><span class="cls_020">for (i = 0; i &lt; 100000; i++) {</span></div>
<div style="position:absolute;left:96.00px;top:405.12px" class="cls_020"><span class="cls_020">stringSum1(vectorx, result);</span></div>
<div style="position:absolute;left:96.00px;top:416.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:442.20px" class="cls_006"><span class="cls_006">Our home-grown solution was much faster—only five seconds. We got better than a 5x speedup. We have</span></div>
<div style="position:absolute;left:72.00px;top:454.68px" class="cls_006"><span class="cls_006">beaten </span><span class="cls_020">accumulate()</span><span class="cls_006"> by a wide margin because we chose to sacrifice generality for improved</span></div>
<div style="position:absolute;left:72.00px;top:467.52px" class="cls_006"><span class="cls_006">performance. Our </span><span class="cls_020">stringSum1()</span><span class="cls_006"> implementation makes the following </span><span class="cls_020">string</span><span class="cls_006">-specific assumptions:</span></div>
<div style="position:absolute;left:90.00px;top:494.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   We know that the only objects we are adding here are strings.</span></div>
<div style="position:absolute;left:90.00px;top:506.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   We know that </span><span class="cls_020">string</span><span class="cls_006"> additions will require memory allocations to contain the evolving </span><span class="cls_020">string</span></div>
<div style="position:absolute;left:108.00px;top:519.24px" class="cls_006"><span class="cls_006">result.</span></div>
<div style="position:absolute;left:90.00px;top:532.08px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   We know that each </span><span class="cls_020">string</span><span class="cls_006"> object can tell us what size it is by invoking </span><span class="cls_020">string::length()</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:558.84px" class="cls_006"><span class="cls_006">We use these assumptions to figure out in advance how big the result </span><span class="cls_020">string</span><span class="cls_006"> is going to be. We use that</span></div>
<div style="position:absolute;left:72.00px;top:571.20px" class="cls_006"><span class="cls_006">knowledge to allocate, in a single step, a memory buffer large enough to contain it. This is the primary</span></div>
<div style="position:absolute;left:72.00px;top:583.68px" class="cls_006"><span class="cls_006">reason why our implementation is so much faster than </span><span class="cls_020">accumulate()</span><span class="cls_006">. The </span><span class="cls_020">accumulate()</span><span class="cls_006"> function</span></div>
<div style="position:absolute;left:72.00px;top:596.04px" class="cls_006"><span class="cls_006">has to make multiple calls to allocate additional memory buffers on-the-fly. It does not know in advance</span></div>
<div style="position:absolute;left:72.00px;top:608.64px" class="cls_006"><span class="cls_006">how big a buffer it really needs. Worse yet, every time </span><span class="cls_020">accumulate()</span><span class="cls_006"> runs out of buffer space, it needs</span></div>
<div style="position:absolute;left:72.00px;top:621.00px" class="cls_006"><span class="cls_006">to copy the content of the old buffer to the newly acquired larger one.</span></div>
<div style="position:absolute;left:72.00px;top:647.52px" class="cls_006"><span class="cls_006">This is a good example of how reduction in flexibility leads to increased efficiency. Our </span><span class="cls_020">stringSum1()</span></div>
<div style="position:absolute;left:72.00px;top:660.36px" class="cls_006"><span class="cls_006">is nowhere near the flexibility and power of </span><span class="cls_020">accumulate()</span><span class="cls_006">. We cannot add anything other than </span><span class="cls_020">string</span></div>
<div style="position:absolute;left:72.00px;top:672.60px" class="cls_006"><span class="cls_006">objects. This is the difference between a 60W lightbulb and a laser beam. The laser beam does not pack</span></div>
<div style="position:absolute;left:72.00px;top:684.72px" class="cls_006"><span class="cls_006">more energy than a lightbulb—it is just a narrowly focused light beam. Although we cannot use a laser</span></div>
<div style="position:absolute;left:72.00px;top:696.72px" class="cls_006"><span class="cls_006">beam to illuminate the room, we could use it to drill a hole in a brick wall.</span></div>
<div style="position:absolute;left:72.00px;top:722.88px" class="cls_006"><span class="cls_006">Our purpose is not to criticize the STL. Far from it. You should only consider replacement of STL code on</span></div>
<div style="position:absolute;left:72.00px;top:734.88px" class="cls_006"><span class="cls_006">performance hot spots. Since these hot spots are hard to predict, you should use the STL, by default,</span></div>
<div style="position:absolute;left:72.00px;top:747.00px" class="cls_006"><span class="cls_006">everywhere in the early phases of software development. The point of this discussion is to highlight a</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:137172px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background162.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">principle that has been pushed aside in the mad dash to create reusable software: There is a fundamental</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">trade-off between software performance and flexibility. Special circumstances and simplifying</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">assumptions are commonplace in typical applications. Software libraries are general-purpose, but</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">applications are not. The ability to narrow the focus of a code fragment leads to higher efficiency.</span></div>
<div style="position:absolute;left:72.00px;top:160.92px" class="cls_016"><span class="cls_016">Caching</span></div>
<div style="position:absolute;left:72.00px;top:192.24px" class="cls_006"><span class="cls_006">We have discussed caching optimizations in </span><span class="cls_036">Chapter 13</span><span class="cls_006"> with respect to coding. But caching opportunities</span></div>
<div style="position:absolute;left:72.00px;top:204.36px" class="cls_006"><span class="cls_006">are abundant in the design arena as well. In this section we describe three design optimizations</span></div>
<div style="position:absolute;left:72.00px;top:216.36px" class="cls_006"><span class="cls_006">representing this set.</span></div>
<div style="position:absolute;left:72.00px;top:242.64px" class="cls_023"><span class="cls_023">Web Server Timestamps</span></div>
<div style="position:absolute;left:72.00px;top:271.44px" class="cls_006"><span class="cls_006">There are multiple times during the service of an HTTP request that the server must take a timestamp to</span></div>
<div style="position:absolute;left:72.00px;top:283.56px" class="cls_006"><span class="cls_006">record the current time. For example, right after a TCP connection is established between the server and</span></div>
<div style="position:absolute;left:72.00px;top:295.56px" class="cls_006"><span class="cls_006">browser, the server starts a timer for this particular connection. If the timer pops before the request has</span></div>
<div style="position:absolute;left:72.00px;top:307.68px" class="cls_006"><span class="cls_006">arrived on the connection, the connection is terminated. These time-outs prevent attackers from flooding</span></div>
<div style="position:absolute;left:72.00px;top:319.68px" class="cls_006"><span class="cls_006">the server with connections that never submit any request. These dead connections tie up server resources</span></div>
<div style="position:absolute;left:72.00px;top:331.80px" class="cls_006"><span class="cls_006">(such as threads) and hang the server. Server termination of dead connections is designed specifically to</span></div>
<div style="position:absolute;left:72.00px;top:343.92px" class="cls_006"><span class="cls_006">address this type of attack on the server.</span></div>
<div style="position:absolute;left:72.00px;top:369.96px" class="cls_006"><span class="cls_006">A Web server also generates a log entry for every request. It is very useful to know how popular your site</span></div>
<div style="position:absolute;left:72.00px;top:382.08px" class="cls_006"><span class="cls_006">is, who is visiting it, and what particular information on your site is in hot demand. The request log</span></div>
<div style="position:absolute;left:72.00px;top:394.08px" class="cls_006"><span class="cls_006">contains a timestamp indicating when the request was serviced.</span></div>
<div style="position:absolute;left:72.00px;top:420.12px" class="cls_006"><span class="cls_006">The last time we counted, each request handling triggered seven timestamps. Since the life of a request</span></div>
<div style="position:absolute;left:72.00px;top:432.24px" class="cls_006"><span class="cls_006">lasts only a few milliseconds, and the necessary timing granularity is measured in seconds, it would be</span></div>
<div style="position:absolute;left:72.00px;top:444.36px" class="cls_006"><span class="cls_006">more efficient to generate a single timestamp per request and reuse it. On some platforms, timestamp</span></div>
<div style="position:absolute;left:72.00px;top:456.36px" class="cls_006"><span class="cls_006">generation is expensive. On one particular platform the computational cost of a typical request was</span></div>
<div style="position:absolute;left:72.00px;top:468.48px" class="cls_006"><span class="cls_006">120,000 instructions. Each timestamp call cost 1,500 instructions, and the seven calls we had totalled about</span></div>
<div style="position:absolute;left:72.00px;top:480.60px" class="cls_006"><span class="cls_006">10,500 instructions. By caching the result of the first timestamp, we eliminated six timestamp</span></div>
<div style="position:absolute;left:72.00px;top:492.60px" class="cls_006"><span class="cls_006">computations and saved 9,000 instructions. That's roughly 8% improvement in the speed of request</span></div>
<div style="position:absolute;left:72.00px;top:504.72px" class="cls_006"><span class="cls_006">handling.</span></div>
<div style="position:absolute;left:72.00px;top:530.76px" class="cls_006"><span class="cls_006">We stashed away the result of the first timestamp computation, and passed it along to the other six</span></div>
<div style="position:absolute;left:72.00px;top:542.88px" class="cls_006"><span class="cls_006">functions as a function call argument. This is an example of caching a result on the call stack. This</span></div>
<div style="position:absolute;left:72.00px;top:554.88px" class="cls_006"><span class="cls_006">particular value was never stored in memory.</span></div>
<div style="position:absolute;left:72.00px;top:581.16px" class="cls_023"><span class="cls_023">Data Expansion</span></div>
<div style="position:absolute;left:72.00px;top:609.96px" class="cls_006"><span class="cls_006">There are many different ways to cache previous results. One of them is in the object itself as a data</span></div>
<div style="position:absolute;left:72.00px;top:621.96px" class="cls_006"><span class="cls_006">member. If you find yourself using an object over and over to derive a related result, it may be better to</span></div>
<div style="position:absolute;left:72.00px;top:634.08px" class="cls_006"><span class="cls_006">stash that result as an object data member and reuse it in future computations.</span></div>
<div style="position:absolute;left:72.00px;top:660.12px" class="cls_006"><span class="cls_006">A web server spends a significant amount of time manipulating character strings. It is often the case that</span></div>
<div style="position:absolute;left:72.00px;top:672.24px" class="cls_006"><span class="cls_006">we compute the length of the same string multiple times as the string travels through the code. In a naive</span></div>
<div style="position:absolute;left:72.00px;top:684.84px" class="cls_020"><span class="cls_020">string</span><span class="cls_006"> class implementation, you'll find yourselves doing redundant </span><span class="cls_020">strlen()</span><span class="cls_006"> calls:</span></div>
<div style="position:absolute;left:72.00px;top:710.76px" class="cls_020"><span class="cls_020">class string {</span></div>
<div style="position:absolute;left:72.00px;top:722.04px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:744.72px" class="cls_020"><span class="cls_020">int length() const {return strlen(str);}</span></div>
<div style="position:absolute;left:72.00px;top:756.12px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">148</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:138024px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background163.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">char *str;</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:107.52px" class="cls_006"><span class="cls_006">It would be more efficient to add a data member that stores the string length:</span></div>
<div style="position:absolute;left:72.00px;top:133.32px" class="cls_020"><span class="cls_020">class string {</span></div>
<div style="position:absolute;left:72.00px;top:144.60px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:167.28px" class="cls_020"><span class="cls_020">int length() const {return strLen;}</span></div>
<div style="position:absolute;left:72.00px;top:178.56px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:189.96px" class="cls_020"><span class="cls_020">char *str;</span></div>
<div style="position:absolute;left:96.00px;top:201.24px" class="cls_020"><span class="cls_020">int</span></div>
<div style="position:absolute;left:131.99px;top:201.24px" class="cls_020"><span class="cls_020">strLen;</span></div>
<div style="position:absolute;left:72.00px;top:212.64px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:238.80px" class="cls_006"><span class="cls_006">The member </span><span class="cls_020">strLen</span><span class="cls_006"> is computed when the </span><span class="cls_020">string</span><span class="cls_006"> object is created or modified. Subsequent calls to</span></div>
<div style="position:absolute;left:72.00px;top:251.52px" class="cls_006"><span class="cls_006">compute the length of the string will return the already computed length and avoid a costly </span><span class="cls_020">strlen()</span><span class="cls_006"> call.</span></div>
<div style="position:absolute;left:72.00px;top:278.40px" class="cls_006"><span class="cls_006">There's another advantage to remembering the length of a string: The family of </span><span class="cls_020">mem*()</span><span class="cls_006"> calls </span><span class="cls_020">(memcpy()</span><span class="cls_006">,</span></div>
<div style="position:absolute;left:72.00px;top:291.12px" class="cls_020"><span class="cls_020">memcmp()</span><span class="cls_006">, etc.) is more efficient than the </span><span class="cls_020">str*()</span><span class="cls_006"> family (</span><span class="cls_020">strcpy()</span><span class="cls_006">, </span><span class="cls_020">strcmp()</span><span class="cls_006">, etc.). The added</span></div>
<div style="position:absolute;left:72.00px;top:303.96px" class="cls_006"><span class="cls_006">efficiency of the </span><span class="cls_020">mem*()</span><span class="cls_006"> family stems from the fact that those functions don't have to inspect every byte</span></div>
<div style="position:absolute;left:72.00px;top:316.80px" class="cls_006"><span class="cls_006">for a possible null termination. The </span><span class="cls_020">mem*()</span><span class="cls_006"> family requires the length of the string as a parameter. If you</span></div>
<div style="position:absolute;left:72.00px;top:329.64px" class="cls_006"><span class="cls_006">stash away the length of the </span><span class="cls_020">string</span><span class="cls_006"> object, you'll be able to use the </span><span class="cls_020">mem*()</span><span class="cls_006"> family of calls to achieve</span></div>
<div style="position:absolute;left:72.00px;top:341.88px" class="cls_006"><span class="cls_006">higher efficiency.</span></div>
<div style="position:absolute;left:72.00px;top:368.16px" class="cls_023"><span class="cls_023">The Common Code Trap</span></div>
<div style="position:absolute;left:72.00px;top:396.96px" class="cls_006"><span class="cls_006">Typical Web server implementations provide support for multiple closely related protocols. Most</span></div>
<div style="position:absolute;left:72.00px;top:408.96px" class="cls_006"><span class="cls_006">implementations support both HTTP as well as SSL. (Secure Socket Layer provides a secure connection</span></div>
<div style="position:absolute;left:72.00px;top:421.08px" class="cls_006"><span class="cls_006">for Web documents. It is essentially a secure, encrypted HTTP.) Naturally, most of the code that</span></div>
<div style="position:absolute;left:72.00px;top:433.20px" class="cls_006"><span class="cls_006">implements Web connections is common between HTTP and SSL. This is great for reuse but care must be</span></div>
<div style="position:absolute;left:72.00px;top:445.20px" class="cls_006"><span class="cls_006">taken to protect performance. In an early implementation of our Web server, we maximized reuse and paid</span></div>
<div style="position:absolute;left:72.00px;top:457.32px" class="cls_006"><span class="cls_006">a performance penalty. There were many decision points along the execution path of request handling</span></div>
<div style="position:absolute;left:72.00px;top:469.44px" class="cls_006"><span class="cls_006">where the SSL code branched off the HTTP code. Every such branch point necessitated a conditional</span></div>
<div style="position:absolute;left:72.00px;top:481.44px" class="cls_006"><span class="cls_006">statement of the form</span></div>
<div style="position:absolute;left:72.00px;top:507.12px" class="cls_020"><span class="cls_020">bool HTHandle(StreamSocket& mySocket)</span></div>
<div style="position:absolute;left:72.00px;top:518.52px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:541.20px" class="cls_020"><span class="cls_020">if (mySocket->SSL()) {</span></div>
<div style="position:absolute;left:113.99px;top:552.48px" class="cls_020"><span class="cls_020">requestHandler->perform_the_SSL_action();</span></div>
<div style="position:absolute;left:96.00px;top:563.76px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:575.16px" class="cls_020"><span class="cls_020">else {</span></div>
<div style="position:absolute;left:113.99px;top:586.44px" class="cls_020"><span class="cls_020">requestHandler->perform_the_HTTP_action();</span></div>
<div style="position:absolute;left:96.00px;top:597.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:620.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:646.20px" class="cls_006"><span class="cls_006">This repeated computation was a burden on execution speed. If we performed this check 20 times in the</span></div>
<div style="position:absolute;left:72.00px;top:658.68px" class="cls_006"><span class="cls_006">life of a request, that's 19 too many. The caller of </span><span class="cls_020">HTHandle()</span><span class="cls_006"> already knew the request type (SSL or</span></div>
<div style="position:absolute;left:72.00px;top:671.04px" class="cls_006"><span class="cls_006">HTTP), and we failed to hold on to this knowledge and reuse it.</span></div>
<div style="position:absolute;left:72.00px;top:697.08px" class="cls_006"><span class="cls_006">Since most of those checks were clustered in a small number of routines, one possible approach to resolve</span></div>
<div style="position:absolute;left:72.00px;top:709.68px" class="cls_006"><span class="cls_006">this redundancy was to duplicate each routine: say, split the routine </span><span class="cls_020">HTHandle()</span><span class="cls_006"> into </span><span class="cls_020">HTHandle_HTTP()</span></div>
<div style="position:absolute;left:72.00px;top:722.40px" class="cls_006"><span class="cls_006">and </span><span class="cls_020">HTHandle_SSL()</span><span class="cls_006">. Now each routine "knows" what type of connection it is dealing with and can</span></div>
<div style="position:absolute;left:72.00px;top:734.76px" class="cls_006"><span class="cls_006">avoid the HTTP/SSL decision.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">149</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:138876px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background164.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">A better solution is to derive an </span><span class="cls_020">SSLRequestHandler</span><span class="cls_006"> and </span><span class="cls_020">HTTPRequestHandler</span><span class="cls_006"> from a base</span></div>
<div style="position:absolute;left:72.00px;top:84.24px" class="cls_020"><span class="cls_020">RequestHandler</span><span class="cls_006"> class. Now </span><span class="cls_020">HTHandle()</span><span class="cls_006"> becomes a virtual function and the HTTP/SSL decision is</span></div>
<div style="position:absolute;left:72.00px;top:96.48px" class="cls_006"><span class="cls_006">resolved once via virtual function resolution. The code simply calls</span></div>
<div style="position:absolute;left:72.00px;top:122.28px" class="cls_020"><span class="cls_020">RequestHandler->HTHandle(mySocket)</span></div>
<div style="position:absolute;left:72.00px;top:148.44px" class="cls_006"><span class="cls_006">and </span><span class="cls_020">HTHandle()</span><span class="cls_006"> will be resolved to the correct routine. The advantage of the virtual call solution is that</span></div>
<div style="position:absolute;left:72.00px;top:160.68px" class="cls_006"><span class="cls_006">it takes a single decision point to separate SSL from HTTP. That's more efficient than revisiting this</span></div>
<div style="position:absolute;left:72.00px;top:173.28px" class="cls_006"><span class="cls_006">decision multiple times inside of a combined SSL/HTTP </span><span class="cls_020">HTHandle()</span><span class="cls_006"> implementation.</span></div>
<div style="position:absolute;left:72.00px;top:199.56px" class="cls_006"><span class="cls_006">Actually, our server implementation was even more complex than this description. Our server was not only</span></div>
<div style="position:absolute;left:72.00px;top:211.68px" class="cls_006"><span class="cls_006">an HTTP and SSL server, it was also a proxy server and an FTP server. It is a real design challenge to</span></div>
<div style="position:absolute;left:72.00px;top:223.80px" class="cls_006"><span class="cls_006">avoid having to make the HTTP/SSL/FTP/proxy decision over and over, hundreds of times.</span></div>
<div style="position:absolute;left:72.00px;top:249.84px" class="cls_006"><span class="cls_006">A similar issue exists with current TCP/IP implementations. The current dominating IP implementation is</span></div>
<div style="position:absolute;left:72.00px;top:261.96px" class="cls_006"><span class="cls_006">Version 4. The emerging next generation IP implementation is Version 6, also known as IPNG (IP Next</span></div>
<div style="position:absolute;left:72.00px;top:273.96px" class="cls_006"><span class="cls_006">Generation). In recent years, TCP/IP vendors have rushed to add V6 support to their existing V4 TCP/IP</span></div>
<div style="position:absolute;left:72.00px;top:286.08px" class="cls_006"><span class="cls_006">implementations. Since both V4 and V6 are closely related, they will execute lots of common code. It is</span></div>
<div style="position:absolute;left:72.00px;top:298.08px" class="cls_006"><span class="cls_006">probably very tempting to use a single V4 base code with V6 branches where necessary. This will produce</span></div>
<div style="position:absolute;left:72.00px;top:310.20px" class="cls_006"><span class="cls_006">code littered with conditional statements of the form:</span></div>
<div style="position:absolute;left:72.00px;top:335.88px" class="cls_020"><span class="cls_020">if (V4) {</span></div>
<div style="position:absolute;left:90.00px;top:347.28px" class="cls_020"><span class="cls_020">do_one_thing();</span></div>
<div style="position:absolute;left:72.00px;top:358.56px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:369.96px" class="cls_020"><span class="cls_020">else {// V6</span></div>
<div style="position:absolute;left:90.00px;top:381.24px" class="cls_020"><span class="cls_020">do_something_else();</span></div>
<div style="position:absolute;left:72.00px;top:392.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:418.32px" class="cls_006"><span class="cls_006">With such implementation, the performance of bothV4 and V6 will be slightly degraded. A more efficient</span></div>
<div style="position:absolute;left:72.00px;top:430.32px" class="cls_006"><span class="cls_006">design is necessary to eliminate those multiple decision points. Once the execution flow determines</span></div>
<div style="position:absolute;left:72.00px;top:442.44px" class="cls_006"><span class="cls_006">whether it is V4 or V6, it should retain this knowledge and reuse it.</span></div>
<div style="position:absolute;left:72.00px;top:496.20px" class="cls_016"><span class="cls_016">Efficient Data Structures</span></div>
<div style="position:absolute;left:72.00px;top:527.52px" class="cls_006"><span class="cls_006">Software performance is often equated with the efficiency of the algorithms and data structures used by the</span></div>
<div style="position:absolute;left:72.00px;top:539.64px" class="cls_006"><span class="cls_006">implementation. It is sometimes suggested that algorithm and data structure efficiency is the most</span></div>
<div style="position:absolute;left:72.00px;top:551.64px" class="cls_006"><span class="cls_006">important factor in software performance. Whether it is or it isn't, there is no question that the use of</span></div>
<div style="position:absolute;left:72.00px;top:563.76px" class="cls_006"><span class="cls_006">efficient algorithms is a necessary condition for software efficiency. No amount of microtuning will help if</span></div>
<div style="position:absolute;left:72.00px;top:575.76px" class="cls_006"><span class="cls_006">you choose inefficient algorithms. You can stuff all variables into registers, inline every function, and</span></div>
<div style="position:absolute;left:72.00px;top:587.88px" class="cls_006"><span class="cls_006">unroll every loop. Still, your bubble-sort program is not going to be anywhere near as fast as a sloppy</span></div>
<div style="position:absolute;left:72.00px;top:600.00px" class="cls_006"><span class="cls_006">implementation of quick-sort.</span></div>
<div style="position:absolute;left:72.00px;top:626.04px" class="cls_006"><span class="cls_006">A detailed discussion of this important topic is beyond the scope of this book. Efficient algorithms and</span></div>
<div style="position:absolute;left:72.00px;top:638.16px" class="cls_006"><span class="cls_006">data structures have been the focus of intense research, and many books have been dedicated entirely to</span></div>
<div style="position:absolute;left:72.00px;top:650.16px" class="cls_006"><span class="cls_006">this subject [</span><span class="cls_036">AHU74</span><span class="cls_006">, Knu73].</span></div>
<div style="position:absolute;left:72.00px;top:676.32px" class="cls_006"><span class="cls_006">As important as they are, efficient algorithms are necessary but not sufficient to guarantee application</span></div>
<div style="position:absolute;left:72.00px;top:688.32px" class="cls_006"><span class="cls_006">efficiency. It is our experience that software performance is a combination of several necessary factors.</span></div>
<div style="position:absolute;left:72.00px;top:700.44px" class="cls_006"><span class="cls_006">You cannot single out any one of them as the most important one. The human heart is definitely an</span></div>
<div style="position:absolute;left:72.00px;top:712.44px" class="cls_006"><span class="cls_006">important organ, but you also need a liver to survive. Focusing on algorithms as the only performance</span></div>
<div style="position:absolute;left:72.00px;top:724.56px" class="cls_006"><span class="cls_006">issue is just plain wrong.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">150</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:139728px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background165.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.80px" class="cls_016"><span class="cls_016">Lazy Evaluation</span></div>
<div style="position:absolute;left:72.00px;top:102.12px" class="cls_006"><span class="cls_006">Many performance optimizations gain speed by taking a computation and performing it in a more efficient</span></div>
<div style="position:absolute;left:72.00px;top:114.24px" class="cls_006"><span class="cls_006">manner. Some of the big performance wins in the optimization game are achieved not by merely speeding</span></div>
<div style="position:absolute;left:72.00px;top:126.36px" class="cls_006"><span class="cls_006">up a computation but by eliminating it altogether.</span></div>
<div style="position:absolute;left:72.00px;top:152.40px" class="cls_006"><span class="cls_006">Issues of lazy evaluation are more likely to present themselves on large-scale code. If you are coding a</span></div>
<div style="position:absolute;left:72.00px;top:164.52px" class="cls_006"><span class="cls_006">solution for, say, the Traveling Salesman Problem (TSP), the problem description fits in one paragraph and</span></div>
<div style="position:absolute;left:72.00px;top:176.52px" class="cls_006"><span class="cls_006">the implementation is less than 100 lines of code. The TSP problem description and implementation can</span></div>
<div style="position:absolute;left:72.00px;top:188.64px" class="cls_006"><span class="cls_006">fully be comprehended by a single developer. That's typical of small scale projects. In such circumstances</span></div>
<div style="position:absolute;left:72.00px;top:200.64px" class="cls_006"><span class="cls_006">you are highly unlikely to find costly computations that are utterly useless and which could be easily</span></div>
<div style="position:absolute;left:72.00px;top:212.76px" class="cls_006"><span class="cls_006">avoided. Optimizations on such small-scale code are often tricky by nature [</span><span class="cls_036">Ben82</span><span class="cls_006">].</span></div>
<div style="position:absolute;left:72.00px;top:238.80px" class="cls_006"><span class="cls_006">When you move on to large-scale programming projects, you often find yourself swamped. Large-scale</span></div>
<div style="position:absolute;left:72.00px;top:250.92px" class="cls_006"><span class="cls_006">projects could contain hundreds of thousands lines of code. The problem description no longer fits in one</span></div>
<div style="position:absolute;left:72.00px;top:263.04px" class="cls_006"><span class="cls_006">short paragraph. It's more like the 100 pages that make up the HTTP protocol specification. The problem</span></div>
<div style="position:absolute;left:72.00px;top:275.04px" class="cls_006"><span class="cls_006">specification is more often then not a moving target. It changes from one release to the next, influenced by</span></div>
<div style="position:absolute;left:72.00px;top:287.16px" class="cls_006"><span class="cls_006">market trends and customer requirements.</span></div>
<div style="position:absolute;left:72.00px;top:313.20px" class="cls_006"><span class="cls_006">The added complexity leads to a situation where no single individual in the organization has a deep and</span></div>
<div style="position:absolute;left:72.00px;top:325.32px" class="cls_006"><span class="cls_006">comprehensive view of the whole implementation landscape. Development organizations are split into</span></div>
<div style="position:absolute;left:72.00px;top:337.32px" class="cls_006"><span class="cls_006">smaller teams that specialize in particular aspects of the whole solution.</span></div>
<div style="position:absolute;left:72.00px;top:363.48px" class="cls_006"><span class="cls_006">The loss of the big implementation picture leads to plenty of significant performance coding and design</span></div>
<div style="position:absolute;left:72.00px;top:375.48px" class="cls_006"><span class="cls_006">errors. It is in this complex environment that lazy evaluation shows up as a tuning weapon.</span></div>
<div style="position:absolute;left:72.00px;top:401.76px" class="cls_029"><span class="cls_029">getpeername(</span><span class="cls_023">)</span></div>
<div style="position:absolute;left:72.00px;top:431.28px" class="cls_006"><span class="cls_006">A TCP/IP socket connection is a communication pipe between remote and local sockets. </span><span class="cls_020">getpeername()</span></div>
<div style="position:absolute;left:72.00px;top:443.52px" class="cls_006"><span class="cls_006">computes the socket IP address of the remote socket. Your application can then proceed to convert it into</span></div>
<div style="position:absolute;left:72.00px;top:455.64px" class="cls_006"><span class="cls_006">dotted decimal notation, such as 9.37.37.205. In a Web server, the typical log record generated per request</span></div>
<div style="position:absolute;left:72.00px;top:467.76px" class="cls_006"><span class="cls_006">contains the IP address of the remote client. This is very interesting information for business Web sites that</span></div>
<div style="position:absolute;left:72.00px;top:479.76px" class="cls_006"><span class="cls_006">are eager to know who browses their site and what are they looking for. So imagine that you are a member</span></div>
<div style="position:absolute;left:72.00px;top:491.88px" class="cls_006"><span class="cls_006">of the HTTP logging team and your task is to add the client IP address to the log. You need to call</span></div>
<div style="position:absolute;left:72.00px;top:504.48px" class="cls_020"><span class="cls_020">getpeername()</span><span class="cls_006"> but where exactly do you insert the call? You don't know the full blown details of the</span></div>
<div style="position:absolute;left:72.00px;top:516.72px" class="cls_006"><span class="cls_006">whole server implementation but you suspect that the client's IP address may come in handy in other parts</span></div>
<div style="position:absolute;left:72.00px;top:529.32px" class="cls_006"><span class="cls_006">of the application. It sounds like a good idea to perform the </span><span class="cls_020">getpeername()</span><span class="cls_006"> at the beginning of each</span></div>
<div style="position:absolute;left:72.00px;top:542.16px" class="cls_006"><span class="cls_006">request, right after the </span><span class="cls_020">accept()</span><span class="cls_006"> call establishes a new socket connection. If any part of the server ever</span></div>
<div style="position:absolute;left:72.00px;top:554.40px" class="cls_006"><span class="cls_006">needs the client's IP address, it will already be available.</span></div>
<div style="position:absolute;left:72.00px;top:581.04px" class="cls_006"><span class="cls_006">A similar issue existed with </span><span class="cls_020">getsockname()</span><span class="cls_006">. Similar to </span><span class="cls_020">getpeername()</span><span class="cls_006">, </span><span class="cls_020">getsockname()</span><span class="cls_006"> computes</span></div>
<div style="position:absolute;left:72.00px;top:593.28px" class="cls_006"><span class="cls_006">the IP address of the local socket. Why do we need the local socket address? So we can host multiple Web</span></div>
<div style="position:absolute;left:72.00px;top:605.40px" class="cls_006"><span class="cls_006">sites on a single physical server. When you are hosting both </span><A HREF="http://www.lotus.com/">www.lotus.com</A><span class="cls_006"> and </span><A HREF="http://www.tivoli.com/">www.tivoli.com</A> </span><span class="cls_006"> on the</span></div>
<div style="position:absolute;left:72.00px;top:617.52px" class="cls_006"><span class="cls_006">same physical server, how do you route requests to the correct site? How do you know if the request for</span></div>
<div style="position:absolute;left:72.00px;top:629.52px" class="cls_006"><span class="cls_006">index.html is for the Lotus site or the Tivoli site? One way to tell them apart is to host each site on a</span></div>
<div style="position:absolute;left:72.00px;top:641.64px" class="cls_006"><span class="cls_006">separate IP address; then you can tell Web sites apart by the IP address on which the request has arrived.</span></div>
<div style="position:absolute;left:72.00px;top:654.12px" class="cls_006"><span class="cls_006">That's where </span><span class="cls_020">getsockname()</span><span class="cls_006"> comes in. It tells us the IP address associated with the local socket.</span></div>
<div style="position:absolute;left:72.00px;top:681.00px" class="cls_020"><span class="cls_020">getpeername()</span><span class="cls_006"> and </span><span class="cls_020">getsockname()</span><span class="cls_006"> are expensive system calls. Furthermore, if you spend some time</span></div>
<div style="position:absolute;left:72.00px;top:693.24px" class="cls_006"><span class="cls_006">studying the internal server design you'll find out that these calls are not always necessary. If the system</span></div>
<div style="position:absolute;left:72.00px;top:705.84px" class="cls_006"><span class="cls_006">administrator has chosen to turn off logging, then </span><span class="cls_020">getpeername()</span><span class="cls_006"> is no longer necessary. If your server</span></div>
<div style="position:absolute;left:72.00px;top:718.68px" class="cls_006"><span class="cls_006">hosts only a single Web site, you may not need to call </span><span class="cls_020">getsockname()</span><span class="cls_006"> either. By electing to place these</span></div>
<div style="position:absolute;left:72.00px;top:731.04px" class="cls_006"><span class="cls_006">calls at the start of every request, you have inflicted a performance penalty on all requests, whether they</span></div>
<div style="position:absolute;left:72.00px;top:743.04px" class="cls_006"><span class="cls_006">truly need those values or not.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">151</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:140580px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background166.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">Paying a performance penalty for a computation you ultimately may not need is a bad idea. It happens way</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">too often in complex code. Costly computations should be performed only if necessary. That often means</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">deferring computations until they are actually needed, hence the name Lazy Evaluation. There are plenty</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">other examples of Lazy Evaluation aside from the ones we discussed here [</span><span class="cls_036">Mey96</span><span class="cls_006">, </span><span class="cls_036">ES90</span><span class="cls_006">].</span></div>
<div style="position:absolute;left:72.00px;top:133.68px" class="cls_006"><span class="cls_006">Here's the idea. Say you have a class </span><span class="cls_020">X</span><span class="cls_006"> containing a data member pointing to data of type </span><span class="cls_020">Z</span><span class="cls_006"> whose</span></div>
<div style="position:absolute;left:72.00px;top:146.04px" class="cls_006"><span class="cls_006">computation is prohibitively expensive:</span></div>
<div style="position:absolute;left:72.00px;top:171.72px" class="cls_020"><span class="cls_020">class X {</span></div>
<div style="position:absolute;left:72.00px;top:183.12px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:194.40px" class="cls_020"><span class="cls_020">X();</span></div>
<div style="position:absolute;left:96.00px;top:205.68px" class="cls_020"><span class="cls_020">~X();</span></div>
<div style="position:absolute;left:96.00px;top:228.36px" class="cls_020"><span class="cls_020">Z</span></div>
<div style="position:absolute;left:131.99px;top:228.36px" class="cls_020"><span class="cls_020">*get_veryExpensive();</span></div>
<div style="position:absolute;left:96.00px;top:239.76px" class="cls_020"><span class="cls_020">void</span></div>
<div style="position:absolute;left:137.99px;top:239.76px" class="cls_020"><span class="cls_020">set_veryExpensive();</span></div>
<div style="position:absolute;left:72.00px;top:251.04px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:262.32px" class="cls_020"><span class="cls_020">Z</span></div>
<div style="position:absolute;left:113.99px;top:262.32px" class="cls_020"><span class="cls_020">*veryExpensive;</span></div>
<div style="position:absolute;left:72.00px;top:285.00px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:311.28px" class="cls_006"><span class="cls_006">If the data member </span><span class="cls_020">veryExpensive</span><span class="cls_006"> is essential to the usage of class </span><span class="cls_020">X</span><span class="cls_006"> objects, then it may need to be</span></div>
<div style="position:absolute;left:72.00px;top:324.00px" class="cls_006"><span class="cls_006">computed in the </span><span class="cls_020">X</span><span class="cls_006"> object constructor. However, we are talking Lazy Evaluation so we assume that this is</span></div>
<div style="position:absolute;left:72.00px;top:336.84px" class="cls_006"><span class="cls_006">not the case here, that some manipulations of </span><span class="cls_020">X</span><span class="cls_006"> objects make perfect sense even when </span><span class="cls_020">veryExpensive</span><span class="cls_006"> is</span></div>
<div style="position:absolute;left:72.00px;top:349.08px" class="cls_006"><span class="cls_006">not available. For example, a socket is still useful even if we don't know its IP address. We can still send</span></div>
<div style="position:absolute;left:72.00px;top:361.68px" class="cls_006"><span class="cls_006">and receive data. In that case, the </span><span class="cls_020">X</span><span class="cls_006"> constructor ought to set </span><span class="cls_020">veryExpensive</span><span class="cls_006"> to some default value</span></div>
<div style="position:absolute;left:72.00px;top:374.04px" class="cls_006"><span class="cls_006">indicating that it has not been computed yet:</span></div>
<div style="position:absolute;left:72.00px;top:399.72px" class="cls_020"><span class="cls_020">X::X()</span></div>
<div style="position:absolute;left:72.00px;top:411.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:422.40px" class="cls_020"><span class="cls_020">veryExpensive = 0; // Lazy evaluation.</span></div>
<div style="position:absolute;left:72.00px;top:445.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:471.24px" class="cls_006"><span class="cls_006">If you ever need the value of </span><span class="cls_020">veryExpensive</span><span class="cls_006"> you can call the following method:</span></div>
<div style="position:absolute;left:72.00px;top:497.16px" class="cls_020"><span class="cls_020">Z *get_veryExpensive()</span></div>
<div style="position:absolute;left:72.00px;top:508.44px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:519.84px" class="cls_020"><span class="cls_020">if (0 == veryExpensive) {</span></div>
<div style="position:absolute;left:119.99px;top:531.12px" class="cls_020"><span class="cls_020">set_veryExpensive();</span></div>
<div style="position:absolute;left:251.97px;top:531.12px" class="cls_020"><span class="cls_020">// Compute it.</span></div>
<div style="position:absolute;left:96.00px;top:542.52px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:565.08px" class="cls_020"><span class="cls_020">return veryExpensive;</span></div>
<div style="position:absolute;left:72.00px;top:576.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:602.64px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">get_veryExpensive()</span><span class="cls_006"> method checks first to see if the requested value has already been</span></div>
<div style="position:absolute;left:72.00px;top:615.00px" class="cls_006"><span class="cls_006">computed. If not, it performs the computation. In any event, you get back the requested value. This</span></div>
<div style="position:absolute;left:72.00px;top:627.00px" class="cls_006"><span class="cls_006">implementation guarantees that the costly computation is deferred until you explicitly request it. Now if</span></div>
<div style="position:absolute;left:72.00px;top:639.12px" class="cls_006"><span class="cls_006">you request it way before it is actually needed, you are on your own.</span></div>
<div style="position:absolute;left:72.00px;top:665.16px" class="cls_006"><span class="cls_006">Let's step back to a more concrete example of socket addresses.</span></div>
<div style="position:absolute;left:72.00px;top:690.84px" class="cls_020"><span class="cls_020">class StreamSocket {</span></div>
<div style="position:absolute;left:72.00px;top:702.24px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:724.92px" class="cls_020"><span class="cls_020">StreamSocket(int listenSocket);</span></div>
<div style="position:absolute;left:96.00px;top:747.48px" class="cls_020"><span class="cls_020">struct sockaddr *get_peername();</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">152</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:141432px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background167.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">void</span></div>
<div style="position:absolute;left:197.98px;top:70.56px" class="cls_020"><span class="cls_020">set_peername();</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">int</span></div>
<div style="position:absolute;left:197.98px;top:93.24px" class="cls_020"><span class="cls_020">sockfd;</span></div>
<div style="position:absolute;left:257.97px;top:93.24px" class="cls_020"><span class="cls_020">// Socket descriptor</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">struct sockaddr</span></div>
<div style="position:absolute;left:197.98px;top:104.52px" class="cls_020"><span class="cls_020">remoteSockAddr;</span></div>
<div style="position:absolute;left:96.00px;top:115.92px" class="cls_020"><span class="cls_020">struct sockaddr *peername; // Will point to remoteSockAddr</span></div>
<div style="position:absolute;left:72.00px;top:138.48px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:164.16px" class="cls_006"><span class="cls_006">The constructor will set the peer name to a default value indicating unavailability:</span></div>
<div style="position:absolute;left:72.00px;top:189.96px" class="cls_020"><span class="cls_020">StreamSocket::StreamSocket(int listenSock)</span></div>
<div style="position:absolute;left:72.00px;top:201.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:223.92px" class="cls_020"><span class="cls_020">peername = 0; // Not computed, yet.</span></div>
<div style="position:absolute;left:72.00px;top:235.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:261.48px" class="cls_020"><span class="cls_020">get_peername()</span><span class="cls_006"> will compute the </span><span class="cls_020">peername</span><span class="cls_006"> if necessary:</span></div>
<div style="position:absolute;left:72.00px;top:287.40px" class="cls_020"><span class="cls_020">int StreamSocket::get_peername()</span></div>
<div style="position:absolute;left:72.00px;top:298.68px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:310.08px" class="cls_020"><span class="cls_020">if (0 == peername) {</span></div>
<div style="position:absolute;left:119.99px;top:321.36px" class="cls_020"><span class="cls_020">set_peername();</span></div>
<div style="position:absolute;left:96.00px;top:332.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:355.32px" class="cls_020"><span class="cls_020">return peername;</span></div>
<div style="position:absolute;left:72.00px;top:366.72px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:392.40px" class="cls_006"><span class="cls_006">Even though network programming is not our topic, we need to set the record straight on</span></div>
<div style="position:absolute;left:72.00px;top:404.88px" class="cls_020"><span class="cls_020">getpeername()</span><span class="cls_006">. In reality, the </span><span class="cls_020">getpeername()</span><span class="cls_006"> call may not be necessary at all. You may avoid the</span></div>
<div style="position:absolute;left:72.00px;top:417.24px" class="cls_006"><span class="cls_006">call even if you need the socket address of the remote socket.</span></div>
<div style="position:absolute;left:72.00px;top:443.76px" class="cls_006"><span class="cls_006">On the server side, you must call </span><span class="cls_020">accept(int sockfd, struct sockaddr *remoteAddr, int</span></div>
<div style="position:absolute;left:72.00px;top:456.60px" class="cls_020"><span class="cls_020">addrLen)</span><span class="cls_006"> to establish the connection. The accept call computes the IP address of the remote socket and</span></div>
<div style="position:absolute;left:72.00px;top:469.44px" class="cls_006"><span class="cls_006">stores it in its second argument: </span><span class="cls_020">struct sockaddr</span></div>
<div style="position:absolute;left:303.82px;top:469.44px" class="cls_020"><span class="cls_020">*remoteAddr</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:495.36px" class="cls_020"><span class="cls_020">StreamSocket::StreamSocket(int listenSock)</span></div>
<div style="position:absolute;left:72.00px;top:506.76px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:518.04px" class="cls_020"><span class="cls_020">int addrLen;</span></div>
<div style="position:absolute;left:96.00px;top:540.72px" class="cls_020"><span class="cls_020">accept(listenSock, &remoteSockAddr, &addrLen);</span></div>
<div style="position:absolute;left:96.00px;top:552.00px" class="cls_020"><span class="cls_020">peername = &remoteSockAddr;</span></div>
<div style="position:absolute;left:281.96px;top:552.00px" class="cls_020"><span class="cls_020">// Now it's available.</span></div>
<div style="position:absolute;left:72.00px;top:574.68px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:600.84px" class="cls_006"><span class="cls_006">You must perform the </span><span class="cls_020">accept()</span><span class="cls_006"> to create a new connection, so you might as well get the peer name right</span></div>
<div style="position:absolute;left:72.00px;top:613.68px" class="cls_006"><span class="cls_006">then as a free by-product of the </span><span class="cls_020">accept()</span><span class="cls_006"> call.</span></div>
<div style="position:absolute;left:72.00px;top:667.68px" class="cls_016"><span class="cls_016">Useless Computations</span></div>
<div style="position:absolute;left:72.00px;top:699.00px" class="cls_006"><span class="cls_006">One programming habit you may encounter in practice is to zero out large data structures automatically.</span></div>
<div style="position:absolute;left:72.00px;top:711.60px" class="cls_006"><span class="cls_006">You can do that by calling </span><span class="cls_020">calloc()</span><span class="cls_006"> to allocate a zero-filled memory block, or you can do it yourself by</span></div>
<div style="position:absolute;left:72.00px;top:724.32px" class="cls_006"><span class="cls_006">invoking </span><span class="cls_020">memset(void *block, 0</span><span class="cls_006">,</span><span class="cls_020"> int blockLen)</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:750.72px" class="cls_006"><span class="cls_006">In the Web server we used a buffered socket object to store incoming requests:</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">153</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:142284px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background168.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">class BufferedStreamSocket {</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">int</span></div>
<div style="position:absolute;left:131.99px;top:93.24px" class="cls_020"><span class="cls_020">sockfd;</span></div>
<div style="position:absolute;left:257.97px;top:93.24px" class="cls_020"><span class="cls_020">// Socket descriptor</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">char</span></div>
<div style="position:absolute;left:131.99px;top:104.52px" class="cls_020"><span class="cls_020">inputBuffer[4096];</span></div>
<div style="position:absolute;left:72.00px;top:127.20px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:153.36px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">BufferedStreamSocket</span><span class="cls_006"> constructor automatically zeros out the input buffer:</span></div>
<div style="position:absolute;left:72.00px;top:179.28px" class="cls_020"><span class="cls_020">BufferedStreamSocket::BufferedStreamSocket(...)</span></div>
<div style="position:absolute;left:72.00px;top:190.68px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:201.96px" class="cls_020"><span class="cls_020">memset(buffer,0,4096);</span></div>
<div style="position:absolute;left:72.00px;top:224.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:250.80px" class="cls_006"><span class="cls_006">We are not generally opposed to the </span><span class="cls_020">memset()</span><span class="cls_006"> call. It has its place. We are opposed to it only when it</span></div>
<div style="position:absolute;left:72.00px;top:263.16px" class="cls_006"><span class="cls_006">achieves nothing.</span></div>
<div style="position:absolute;left:72.00px;top:289.20px" class="cls_006"><span class="cls_006">A close inspection of our source code revealed that nowhere did we use the fact that the input buffer was</span></div>
<div style="position:absolute;left:72.00px;top:301.80px" class="cls_006"><span class="cls_006">zeroed out. We never assumed it and never took advantage of it. Apparently, the buffer was </span><span class="cls_020">memset()</span></div>
<div style="position:absolute;left:72.00px;top:314.04px" class="cls_006"><span class="cls_006">"just in case." When you read data from a socket the data is copied into a user-supplied buffer, and you</span></div>
<div style="position:absolute;left:72.00px;top:326.16px" class="cls_006"><span class="cls_006">also get back the number of bytes read. That's all you need. The number of bytes read tells you where the</span></div>
<div style="position:absolute;left:72.00px;top:338.28px" class="cls_006"><span class="cls_006">logical end of your data buffer is. This is not a null-terminated string. Since we never used it, the</span></div>
<div style="position:absolute;left:72.00px;top:350.76px" class="cls_006"><span class="cls_006">constructor call to </span><span class="cls_020">memset()</span><span class="cls_006"> was a pure waste of time.</span></div>
<div style="position:absolute;left:72.00px;top:377.16px" class="cls_006"><span class="cls_006">Examples of useless computations often look silly, and you may think that you would never do something</span></div>
<div style="position:absolute;left:72.00px;top:389.16px" class="cls_006"><span class="cls_006">like that. We, however, have encountered such computations on numerous occasions in practice. You are</span></div>
<div style="position:absolute;left:72.00px;top:401.28px" class="cls_006"><span class="cls_006">more likely to see it in complex, large-scale code.</span></div>
<div style="position:absolute;left:72.00px;top:455.04px" class="cls_016"><span class="cls_016">Obsolete Code</span></div>
<div style="position:absolute;left:72.00px;top:486.36px" class="cls_006"><span class="cls_006">This is another one of those tips that sounds silly but actually happens in practice quite often. We are</span></div>
<div style="position:absolute;left:72.00px;top:498.48px" class="cls_006"><span class="cls_006">talking about code that no longer serves a purpose but still remains on the execution path. This is not likely</span></div>
<div style="position:absolute;left:72.00px;top:510.48px" class="cls_006"><span class="cls_006">to happen on a school programming assignment or a small prototype. It happens on large-scale</span></div>
<div style="position:absolute;left:72.00px;top:522.60px" class="cls_006"><span class="cls_006">programming efforts. The requirements that drive a software implementation are a moving target, tending</span></div>
<div style="position:absolute;left:72.00px;top:534.72px" class="cls_006"><span class="cls_006">to evolve from one release to the next. New features are added and support for old features may be</span></div>
<div style="position:absolute;left:72.00px;top:546.72px" class="cls_006"><span class="cls_006">dropped. The implementation itself keeps shifting underneath your feet with bug fixes and enhancements.</span></div>
<div style="position:absolute;left:72.00px;top:558.84px" class="cls_006"><span class="cls_006">This constant movement of requirements and implementation creates bubbles of dead (never executed) and</span></div>
<div style="position:absolute;left:72.00px;top:570.96px" class="cls_006"><span class="cls_006">obsolete (executed but not necessary) code. Let's go back to the trenches of one HTTP server for a concrete</span></div>
<div style="position:absolute;left:72.00px;top:582.96px" class="cls_006"><span class="cls_006">example.</span></div>
<div style="position:absolute;left:72.00px;top:609.00px" class="cls_006"><span class="cls_006">The initial crop of Web servers supported both HTTP and the Secure-HTTP (S-HTTP) protocols. Shortly</span></div>
<div style="position:absolute;left:72.00px;top:621.12px" class="cls_006"><span class="cls_006">thereafter SSL emerged as a replacement for S-HTTP. For a while we supported all three. Then, SSL took</span></div>
<div style="position:absolute;left:72.00px;top:633.24px" class="cls_006"><span class="cls_006">off and knocked S-HTTP into oblivion. Naturally, we followed the market trend and dropped support for</span></div>
<div style="position:absolute;left:72.00px;top:645.24px" class="cls_006"><span class="cls_006">S-HTTP.</span></div>
<div style="position:absolute;left:72.00px;top:671.40px" class="cls_006"><span class="cls_006">In the early days of the WWW craze, product release cycles had been reduced from 1-2 years to 2-3</span></div>
<div style="position:absolute;left:72.00px;top:683.40px" class="cls_006"><span class="cls_006">months. Consequently, even though S-HTTP support was disabled, nobody bothered to go and clean out</span></div>
<div style="position:absolute;left:72.00px;top:695.52px" class="cls_006"><span class="cls_006">the source code. S-HTTP code was all over and removing all traces of it was an error-prone, tedious, and</span></div>
<div style="position:absolute;left:72.00px;top:707.52px" class="cls_006"><span class="cls_006">time-consuming job. Obsolete code due to S-HTTP was taking a toll on performance in several major ways.</span></div>
<div style="position:absolute;left:72.00px;top:719.64px" class="cls_006"><span class="cls_006">First, there were many occurrences of data members introduced by S-HTTP into various objects. Those</span></div>
<div style="position:absolute;left:72.00px;top:731.76px" class="cls_006"><span class="cls_006">members were initialized and destroyed, unnecessarily consuming CPU cycles since their values were</span></div>
<div style="position:absolute;left:72.00px;top:744.24px" class="cls_006"><span class="cls_006">essentially dead. Moreover, there were plenty of </span><span class="cls_020">if then else</span><span class="cls_006"> decision points to separate S-HTTP</span></div>
<div style="position:absolute;left:72.00px;top:756.60px" class="cls_006"><span class="cls_006">execution flow from </span><A HREF="http:/">HTTP:</A> </div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">154</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:143136px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background169.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">if (/* HTTP */) {</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">else { /* S-HTTP */</span></div>
<div style="position:absolute;left:72.00px;top:127.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:152.88px" class="cls_006"><span class="cls_006">Those extraneous branch points hurt performance by adding cycles as well as introducing bubbles into the</span></div>
<div style="position:absolute;left:72.00px;top:165.00px" class="cls_006"><span class="cls_006">processor's instruction pipeline.</span></div>
<div style="position:absolute;left:72.00px;top:191.04px" class="cls_006"><span class="cls_006">Other minor damages inflicted by obsolete code are increased executable size, memory footprint, and</span></div>
<div style="position:absolute;left:72.00px;top:203.16px" class="cls_006"><span class="cls_006">source code. Source code that contains obsolete and dead code is harder to understand, maintain, and</span></div>
<div style="position:absolute;left:72.00px;top:215.16px" class="cls_006"><span class="cls_006">extend. For all those reasons, removing dead and obsolete code is highly recommended as routine source</span></div>
<div style="position:absolute;left:72.00px;top:227.28px" class="cls_006"><span class="cls_006">code maintenance.</span></div>
<div style="position:absolute;left:72.00px;top:281.04px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:312.60px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   A fundamental tension exists between software performance and flexibility. On the 20% of your</span></div>
<div style="position:absolute;left:108.00px;top:324.72px" class="cls_006"><span class="cls_006">software that executes 80% of the time, performance often comes first at the expense of flexibility.</span></div>
<div style="position:absolute;left:90.00px;top:336.96px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Caching opportunities may surface in the overall program design as well as in the minute coding</span></div>
<div style="position:absolute;left:108.00px;top:349.08px" class="cls_006"><span class="cls_006">details. You can often avoid big blobs of computation by simply stashing away the result of</span></div>
<div style="position:absolute;left:108.00px;top:361.20px" class="cls_006"><span class="cls_006">previous computations.</span></div>
<div style="position:absolute;left:90.00px;top:373.44px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The use of efficient algorithms and data structures is a necessary but not sufficient condition for</span></div>
<div style="position:absolute;left:108.00px;top:385.56px" class="cls_006"><span class="cls_006">software efficiency.</span></div>
<div style="position:absolute;left:90.00px;top:397.92px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Some computations may be necessary only on a subset of the overall likely execution scenarios.</span></div>
<div style="position:absolute;left:108.00px;top:409.92px" class="cls_006"><span class="cls_006">Those computations should be deferred to those execution paths that must have them. If a</span></div>
<div style="position:absolute;left:108.00px;top:422.04px" class="cls_006"><span class="cls_006">computation is performed prematurely, its result may go unused.</span></div>
<div style="position:absolute;left:90.00px;top:434.40px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Large-scale software often tends towards chaos. One by-product of chaotic software is the</span></div>
<div style="position:absolute;left:108.00px;top:446.40px" class="cls_006"><span class="cls_006">execution of obsolete code: code that once upon a time served a purpose but no longer does.</span></div>
<div style="position:absolute;left:108.00px;top:458.52px" class="cls_006"><span class="cls_006">Periodic purges of obsolete code and other useless computations will boost performance as well as</span></div>
<div style="position:absolute;left:108.00px;top:470.64px" class="cls_006"><span class="cls_006">overall software hygiene.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">155</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:143988px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background170.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 15. Scalability</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">Faced with the task of speeding up a C++ application, you generally have the following options:</span></div>
<div style="position:absolute;left:90.00px;top:144.24px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Tune your application. Reduce the application's pathlength by optimizing the code. This has been</span></div>
<div style="position:absolute;left:108.00px;top:156.24px" class="cls_006"><span class="cls_006">the focus of our discussion up to this point, speeding up a single thread of execution on a</span></div>
<div style="position:absolute;left:108.00px;top:168.36px" class="cls_006"><span class="cls_006">uniprocessor (single CPU) machine.</span></div>
<div style="position:absolute;left:90.00px;top:180.72px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Upgrade processing speed. A faster CPU should result in faster execution for CPU-bound</span></div>
<div style="position:absolute;left:108.00px;top:192.72px" class="cls_006"><span class="cls_006">workloads.</span></div>
<div style="position:absolute;left:90.00px;top:205.08px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Add processors. A multiprocessor machine consists of multiple CPUs. In theory, multiple CPUs</span></div>
<div style="position:absolute;left:108.00px;top:217.20px" class="cls_006"><span class="cls_006">should outperform a single CPU of identical speed. This is what scalability is all about.</span></div>
<div style="position:absolute;left:72.00px;top:243.24px" class="cls_006"><span class="cls_006">The scalability challenge facing an application code is to keep up with the additional processing power.</span></div>
<div style="position:absolute;left:72.00px;top:255.36px" class="cls_006"><span class="cls_006">When you move an application from a uniprocessor to a 2-way multiprocessor, it would be nice if you</span></div>
<div style="position:absolute;left:72.00px;top:267.36px" class="cls_006"><span class="cls_006">could double execution speed. Would your application run four times as fast on a 4-way multiprocessor?</span></div>
<div style="position:absolute;left:72.00px;top:279.48px" class="cls_006"><span class="cls_006">eight times as fast on an 8-way multiprocessor? This is the scalability challenge. Most applications will not</span></div>
<div style="position:absolute;left:72.00px;top:291.48px" class="cls_006"><span class="cls_006">exhibit such perfect linear scaling, but the goal is to get as close as you can.</span></div>
<div style="position:absolute;left:72.00px;top:317.64px" class="cls_006"><span class="cls_006">To understand the software performance issues on a multiprocessor, we have to establish a rudimentary</span></div>
<div style="position:absolute;left:72.00px;top:329.64px" class="cls_006"><span class="cls_006">grasp of the underlying architecture. Since multiprocessors evolved out of uniprocessors, let's step back</span></div>
<div style="position:absolute;left:72.00px;top:341.76px" class="cls_006"><span class="cls_006">and start with the world's quickest overview of the uniprocessor computer architecture. The mainstream</span></div>
<div style="position:absolute;left:72.00px;top:353.88px" class="cls_006"><span class="cls_006">uniprocessor architecture consists of a single CPU and a single main memory module. Program data and</span></div>
<div style="position:absolute;left:72.00px;top:365.88px" class="cls_006"><span class="cls_006">instructions reside in main memory. Since CPU speed is at least an order of magnitude faster than memory,</span></div>
<div style="position:absolute;left:72.00px;top:378.00px" class="cls_006"><span class="cls_006">we also have an additional (very) fast memory inserted between the processor (= CPU) and main memory.</span></div>
<div style="position:absolute;left:72.00px;top:390.00px" class="cls_006"><span class="cls_006">This fast memory is also known as the cache. The cache provides faster access to program data and</span></div>
<div style="position:absolute;left:72.00px;top:402.12px" class="cls_006"><span class="cls_006">instructions. The cache may be split into two physical units, one for data and another for instructions. We'll</span></div>
<div style="position:absolute;left:72.00px;top:414.24px" class="cls_006"><span class="cls_006">ignore that distinction and refer to it as a single logical entity. The processor needs at least one memory</span></div>
<div style="position:absolute;left:72.00px;top:426.24px" class="cls_006"><span class="cls_006">access per instruction in order to retrieve the instruction itself. On most instructions it may need additional</span></div>
<div style="position:absolute;left:72.00px;top:438.36px" class="cls_006"><span class="cls_006">memory references for data. When the processor needs memory access, it looks in the cache first. Since</span></div>
<div style="position:absolute;left:72.00px;top:450.48px" class="cls_006"><span class="cls_006">cache hit-ratios are upwards of 90%, slow trips to main memory are infrequent. This whole story is</span></div>
<div style="position:absolute;left:72.00px;top:462.48px" class="cls_006"><span class="cls_006">summarized in </span><span class="cls_036">Figure 15.1</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:191.04px;top:488.64px" class="cls_021"><span class="cls_021">Figure 15.1. Single processor architecture.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">156</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:144840px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background171.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:342.12px" class="cls_006"><span class="cls_006">An application is a single process or a set of cooperating processes. Each process consists of one or more</span></div>
<div style="position:absolute;left:72.00px;top:354.24px" class="cls_006"><span class="cls_006">threads. The scheduling entity on modern operating systems is a thread. The operating system does not</span></div>
<div style="position:absolute;left:72.00px;top:366.36px" class="cls_006"><span class="cls_006">execute a process, it executes a thread. Threads that are ready to execute are placed on the system's Run</span></div>
<div style="position:absolute;left:72.00px;top:378.36px" class="cls_006"><span class="cls_006">Queue. The thread on top of the queue is next in line for execution (</span><span class="cls_036">Figure 15.2</span><span class="cls_006">).</span></div>
<div style="position:absolute;left:177.00px;top:404.64px" class="cls_021"><span class="cls_021">Figure 15.2. Threads are the scheduling entities.</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:145692px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background172.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:564.96px" class="cls_006"><span class="cls_006">Modern uniprocessor machines are controlled by preemptive multitasking operating systems. An operating</span></div>
<div style="position:absolute;left:72.00px;top:576.96px" class="cls_006"><span class="cls_006">system of that type creates the illusion of concurrent program execution. From the user's point of view, it</span></div>
<div style="position:absolute;left:72.00px;top:589.08px" class="cls_006"><span class="cls_006">seems like multiple programs are executing simultaneously. As you know, this is not the case. At the</span></div>
<div style="position:absolute;left:72.00px;top:601.20px" class="cls_006"><span class="cls_006">hardware level, there's only one CPU and only one thread of execution at any one time. Multitasking on a</span></div>
<div style="position:absolute;left:72.00px;top:613.20px" class="cls_006"><span class="cls_006">uniprocessor is accomplished by having threads take turns using the CPU.</span></div>
<div style="position:absolute;left:72.00px;top:639.24px" class="cls_006"><span class="cls_006">With this picture of a uniprocessor architecture tucked away, we are now ready to move on to</span></div>
<div style="position:absolute;left:72.00px;top:651.36px" class="cls_006"><span class="cls_006">multiprocessors. Faithful to our 80-20 principle, we will focus the discussion on the dominant</span></div>
<div style="position:absolute;left:72.00px;top:663.48px" class="cls_006"><span class="cls_006">multiprocessor architecture, the Symmetric MultiProcessor (SMP).</span></div>
<div style="position:absolute;left:72.00px;top:717.24px" class="cls_016"><span class="cls_016">The SMP Architecture</span></div>
<div style="position:absolute;left:72.00px;top:748.56px" class="cls_006"><span class="cls_006">The name SMP already gives it away:</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">158</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:146544px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background173.jpg" width=595 height=842></div>
<div style="position:absolute;left:90.00px;top:71.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   It is MP, as in multiprocessor. The system consists of multiple identical CPUs.</span></div>
<div style="position:absolute;left:90.00px;top:83.52px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   It is symmetric. All processors have an identical view of the system. They all have the same</span></div>
<div style="position:absolute;left:108.00px;top:95.52px" class="cls_006"><span class="cls_006">capabilities. For example, they have identical access to any location in memory as well as to any</span></div>
<div style="position:absolute;left:108.00px;top:107.64px" class="cls_006"><span class="cls_006">I/O device.</span></div>
<div style="position:absolute;left:90.00px;top:120.00px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Everything else is single. It has a single memory system, a single copy of the operating system, a</span></div>
<div style="position:absolute;left:108.00px;top:132.00px" class="cls_006"><span class="cls_006">single Run Queue.</span></div>
<div style="position:absolute;left:72.00px;top:158.16px" class="cls_036"><span class="cls_036">Figure 15.3</span><span class="cls_006"> captures the SMP story.</span></div>
<div style="position:absolute;left:210.72px;top:184.32px" class="cls_021"><span class="cls_021">Figure 15.3. The SMP Architecture.</span></div>
<div style="position:absolute;left:72.00px;top:606.72px" class="cls_006"><span class="cls_006">Unless your application code bends over backwards, threads have no affinity to any particular CPU. The</span></div>
<div style="position:absolute;left:72.00px;top:618.84px" class="cls_006"><span class="cls_006">same thread may execute on CPU_1 in one particular time-slice and CPU_2 on the next time-slice.</span></div>
<div style="position:absolute;left:72.00px;top:630.96px" class="cls_006"><span class="cls_006">Another lesson driven by </span><span class="cls_036">Figure 15.3</span><span class="cls_006"> is that multiple threads really do execute simultaneously. While</span></div>
<div style="position:absolute;left:72.00px;top:642.96px" class="cls_006"><span class="cls_006">thread T1 executes on CPU_1, thread T2 may very well execute on CPU_2. Since the scheduling entity is</span></div>
<div style="position:absolute;left:72.00px;top:655.08px" class="cls_006"><span class="cls_006">a thread, there's nothing preventing threads T1 and T2 from belonging to the same process. In this case it is</span></div>
<div style="position:absolute;left:72.00px;top:667.08px" class="cls_006"><span class="cls_006">very likely that they will access the same memory locations on a regular basis. Which brings us to the next</span></div>
<div style="position:absolute;left:72.00px;top:679.20px" class="cls_006"><span class="cls_006">issue: There is only one bus connecting the processors to the memory system. The bus is the major</span></div>
<div style="position:absolute;left:72.00px;top:691.32px" class="cls_006"><span class="cls_006">bottleneck in SMP systems and the chief reason why 256-way SMP machines are not commonplace—</span></div>
<div style="position:absolute;left:72.00px;top:703.32px" class="cls_006"><span class="cls_006">because bus contention will bring them to a grinding halt.</span></div>
<div style="position:absolute;left:72.00px;top:729.48px" class="cls_006"><span class="cls_006">The solution to bus contention is large caches, one per processor. A large cache will make bus trips</span></div>
<div style="position:absolute;left:72.00px;top:741.96px" class="cls_006"><span class="cls_006">infrequent, but raises a new problem: What if two distinct caches both have a copy of a variable, </span><span class="cls_020">x</span><span class="cls_006">, and</span></div>
<div style="position:absolute;left:72.00px;top:754.80px" class="cls_006"><span class="cls_006">one of the processors updates its private copy? The other cache might have a stale, incorrect value for </span><span class="cls_020">x</span><span class="cls_006">,</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">159</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:147396px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background174.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">and we hate when that happens. This is the </span><span class="cls_007">cache consistency</span><span class="cls_006"> problem. The SMP architecture provides a</span></div>
<div style="position:absolute;left:72.00px;top:83.52px" class="cls_006"><span class="cls_006">hardware solution for it. The details are not terribly important; all we need to know is that when variable </span><span class="cls_020">x</span></div>
<div style="position:absolute;left:72.00px;top:95.76px" class="cls_006"><span class="cls_006">gets updated, all of its other cache copies get updated as does the main memory master copy. The </span><span class="cls_007">cache</span></div>
<div style="position:absolute;left:72.00px;top:107.88px" class="cls_007"><span class="cls_007">consistency</span><span class="cls_006"> hardware solution is completely invisible to the application software.</span></div>
<div style="position:absolute;left:72.00px;top:133.92px" class="cls_006"><span class="cls_006">The SMP architecture offers potential scalability. Obviously, the number of processors presents an easy</span></div>
<div style="position:absolute;left:72.00px;top:146.04px" class="cls_006"><span class="cls_006">upper bound. You cannot get more than 8x speedup on an 8-way SMP. The practical scalability limit may</span></div>
<div style="position:absolute;left:72.00px;top:158.04px" class="cls_006"><span class="cls_006">be even tighter than that. We explore that practical limit next.</span></div>
<div style="position:absolute;left:72.00px;top:211.92px" class="cls_016"><span class="cls_016">Amdahl's Law</span></div>
<div style="position:absolute;left:72.00px;top:243.24px" class="cls_006"><span class="cls_006">Amdahl's Law quantifies the fact that the sequential portion of an application will put a lid on its potential</span></div>
<div style="position:absolute;left:72.00px;top:255.24px" class="cls_006"><span class="cls_006">scalability. This is best illustrated by an example such as matrix multiplication. It consists of three stages:</span></div>
<div style="position:absolute;left:90.00px;top:281.64px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Initialization: read in the matrices data values.</span></div>
<div style="position:absolute;left:90.00px;top:293.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Multiplication: multiply the two matrices.</span></div>
<div style="position:absolute;left:90.00px;top:306.24px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Presentation: present the resulting matrix.</span></div>
<div style="position:absolute;left:72.00px;top:332.28px" class="cls_006"><span class="cls_006">Let's assume further that the whole computation takes 10 ms, broken down as follows (these numbers are</span></div>
<div style="position:absolute;left:72.00px;top:344.40px" class="cls_006"><span class="cls_006">completely fictitious but help illustrate the point):</span></div>
<div style="position:absolute;left:90.00px;top:370.68px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Initialization: 2 ms</span></div>
<div style="position:absolute;left:90.00px;top:383.04px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Multiplication: 6 ms</span></div>
<div style="position:absolute;left:90.00px;top:395.40px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Presentation: 2 ms</span></div>
<div style="position:absolute;left:72.00px;top:421.44px" class="cls_006"><span class="cls_006">Over the years, many clever parallel algorithms have been developed to exploit multiprocessor</span></div>
<div style="position:absolute;left:72.00px;top:433.56px" class="cls_006"><span class="cls_006">architectures to speed up the matrix multiplication phase. Not so with the Initialization and Presentation</span></div>
<div style="position:absolute;left:72.00px;top:445.56px" class="cls_006"><span class="cls_006">phase. Practically, these two stages in the computation are fundamentally sequential. In the ideal world, an</span></div>
<div style="position:absolute;left:72.00px;top:457.68px" class="cls_006"><span class="cls_006">unlimited number of parallel processors could, in theory, reduce the multiplication stage to 0 ms. But they</span></div>
<div style="position:absolute;left:72.00px;top:469.80px" class="cls_006"><span class="cls_006">would not help at all with the other two sequential stages, as shown by </span><span class="cls_036">Figure 15.4</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:195.84px;top:495.96px" class="cls_021"><span class="cls_021">Figure 15.4. Potential speedup is limited.</span></div>
<div style="position:absolute;left:72.00px;top:717.36px" class="cls_006"><span class="cls_006">An unlimited number of parallel processors has only reduced a 10 ms computation to 4 ms. Looks like</span></div>
<div style="position:absolute;left:72.00px;top:729.48px" class="cls_006"><span class="cls_006">2.5x is the speedup limit for this particular application on any SMP system regardless of the number of</span></div>
<div style="position:absolute;left:72.00px;top:741.60px" class="cls_006"><span class="cls_006">processors.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">160</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:148248px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background175.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">This matrix example exhibits a response-time limit. The same idea also applies to throughput. Consider the</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">original design of our Web server, a 3-stage pipeline (</span><span class="cls_036">Figure 15.5</span><span class="cls_006">).</span></div>
<div style="position:absolute;left:175.20px;top:109.20px" class="cls_021"><span class="cls_021">Figure 15.5. A specific design of one Web server.</span></div>
<div style="position:absolute;left:72.00px;top:272.16px" class="cls_006"><span class="cls_006">Let's assume that the whole pipeline consumes 10 ms as follows (again, the numbers are fictitious):</span></div>
<div style="position:absolute;left:90.00px;top:298.44px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Accept: 2 ms</span></div>
<div style="position:absolute;left:90.00px;top:310.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Service: 6 ms</span></div>
<div style="position:absolute;left:90.00px;top:323.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Log: 2 ms</span></div>
<div style="position:absolute;left:72.00px;top:349.20px" class="cls_006"><span class="cls_006">At 10 ms, we can serve 100 requests-per-second on a uniprocessor. Our server was designed to have a</span></div>
<div style="position:absolute;left:72.00px;top:361.32px" class="cls_006"><span class="cls_006">single thread perform the Accept stage. It then queued accepted connections to the Service stage. A pool of</span></div>
<div style="position:absolute;left:72.00px;top:373.32px" class="cls_006"><span class="cls_006">available threads consumed requests off of that queue to perform the Service stage. Upon completion of</span></div>
<div style="position:absolute;left:72.00px;top:385.44px" class="cls_006"><span class="cls_006">the Service stage, a log record was queued to the Log stage. The Log stage, like the Accept stage, was</span></div>
<div style="position:absolute;left:72.00px;top:397.44px" class="cls_006"><span class="cls_006">performed by a single thread. It follows that only the Service stage could benefit from an SMP. The Accept</span></div>
<div style="position:absolute;left:72.00px;top:409.56px" class="cls_006"><span class="cls_006">and Log stages were inherently sequential, as they were single-threaded.</span></div>
<div style="position:absolute;left:72.00px;top:435.60px" class="cls_006"><span class="cls_006">Regardless of the number of parallel processors, we only have a single thread accepting new connections.</span></div>
<div style="position:absolute;left:72.00px;top:447.72px" class="cls_006"><span class="cls_006">Since each new connection takes 2 ms to establish, this thread cannot accept more than 500 connections-</span></div>
<div style="position:absolute;left:72.00px;top:459.84px" class="cls_006"><span class="cls_006">per-second. This puts a 5x scaling limit on our Web server design even if we move it from a uniprocessor</span></div>
<div style="position:absolute;left:72.00px;top:471.84px" class="cls_006"><span class="cls_006">to a 12-way SMP.</span></div>
<div style="position:absolute;left:72.00px;top:497.88px" class="cls_006"><span class="cls_006">Sequential (single-threaded) computations are the major roadblock on the way to scalability. In the</span></div>
<div style="position:absolute;left:72.00px;top:510.00px" class="cls_006"><span class="cls_006">following sections we will enumerate ways to eliminate or at least minimize sequential computations.</span></div>
<div style="position:absolute;left:72.00px;top:522.12px" class="cls_006"><span class="cls_006">Before we go there, we briefly need to clarify some terminology.</span></div>
<div style="position:absolute;left:72.00px;top:575.88px" class="cls_016"><span class="cls_016">Multithreaded and Synchronization Terminology</span></div>
<div style="position:absolute;left:72.00px;top:607.20px" class="cls_006"><span class="cls_006">This is not the first time in this book that we have run into synchronization terminology. We have already</span></div>
<div style="position:absolute;left:72.00px;top:619.32px" class="cls_006"><span class="cls_006">used terms such as synchronization, serialization, critical sections, race condition, and locks. We never</span></div>
<div style="position:absolute;left:72.00px;top:630.48px" class="cls_006"><span class="cls_006">really explained them, and it is time to step back and clarify the terminology.</span><span class="cls_037"><sup>[1]</sup></span><span class="cls_006"> The first issue is presenting</span></div>
<div style="position:absolute;left:72.00px;top:644.04px" class="cls_006"><span class="cls_006">the problem: What is the problem that all that terminology is trying to address?</span></div>
<div style="position:absolute;left:90.00px;top:669.36px" class="cls_026"><span class="cls_026"><sup>[1]</sup></span><span class="cls_027"> It does not help at all that Java has overloaded the term "serialization" to mean something entirely</span></div>
<div style="position:absolute;left:90.00px;top:683.04px" class="cls_027"><span class="cls_027">different and unrelated to synchronization.</span></div>
<div style="position:absolute;left:72.00px;top:707.04px" class="cls_006"><span class="cls_006">Take a simple code statement such as</span></div>
<div style="position:absolute;left:72.00px;top:732.84px" class="cls_020"><span class="cls_020">x = x + 1;</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">161</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:149100px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background176.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">If two threads execute this statement, we expect the resulting value stored in </span><span class="cls_020">x</span><span class="cls_006"> to be </span><span class="cls_020">x+2</span><span class="cls_006">. Any other value</span></div>
<div style="position:absolute;left:72.00px;top:83.76px" class="cls_006"><span class="cls_006">would be incorrect. The problem with this code statement is that it is not executed atomically. It is actually</span></div>
<div style="position:absolute;left:72.00px;top:95.76px" class="cls_006"><span class="cls_006">broken into a small number of assembler instructions:</span></div>
<div style="position:absolute;left:72.00px;top:121.56px" class="cls_020"><span class="cls_020">load  x, r5</span></div>
<div style="position:absolute;left:155.98px;top:121.56px" class="cls_020"><span class="cls_020">// load the value of x into register r5</span></div>
<div style="position:absolute;left:72.00px;top:132.84px" class="cls_020"><span class="cls_020">add</span></div>
<div style="position:absolute;left:107.99px;top:132.84px" class="cls_020"><span class="cls_020">r5, 1</span></div>
<div style="position:absolute;left:155.98px;top:132.84px" class="cls_020"><span class="cls_020">// add 1 to register r5</span></div>
<div style="position:absolute;left:72.00px;top:144.12px" class="cls_020"><span class="cls_020">store r5, x</span></div>
<div style="position:absolute;left:155.98px;top:144.12px" class="cls_020"><span class="cls_020">// store the value of register r5 into x</span></div>
<div style="position:absolute;left:72.00px;top:169.92px" class="cls_006"><span class="cls_006">If two threads execute this code at roughly the same time, their instruction execution could interleave in a</span></div>
<div style="position:absolute;left:72.00px;top:182.40px" class="cls_006"><span class="cls_006">way that would result in </span><span class="cls_020">x+1</span><span class="cls_006"> stored as the new value of </span><span class="cls_020">x</span><span class="cls_006"> instead of </span><span class="cls_020">x+2</span><span class="cls_006">. That unfortunate interleaving of</span></div>
<div style="position:absolute;left:72.00px;top:194.76px" class="cls_006"><span class="cls_006">thread execution is called a race condition. The solution to this race condition is to guarantee that this</span></div>
<div style="position:absolute;left:72.00px;top:206.76px" class="cls_006"><span class="cls_006">block of assembler statements executes atomically. We call that block a critical section. Once a thread</span></div>
<div style="position:absolute;left:72.00px;top:218.88px" class="cls_006"><span class="cls_006">enters a critical section, no other thread can enter until the first one leaves. In that case we say that the two</span></div>
<div style="position:absolute;left:72.00px;top:231.00px" class="cls_006"><span class="cls_006">threads are synchronized (or serialized) and that the critical section is mutually exclusive. Since the</span></div>
<div style="position:absolute;left:72.00px;top:243.48px" class="cls_006"><span class="cls_006">variable </span><span class="cls_020">x</span><span class="cls_006"> is accessed by more than a single thread it is considered shared data. Critical sections always</span></div>
<div style="position:absolute;left:72.00px;top:255.84px" class="cls_006"><span class="cls_006">revolve around access to shared data. To guarantee safe access to shared data (and correct execution) we</span></div>
<div style="position:absolute;left:72.00px;top:267.96px" class="cls_006"><span class="cls_006">use a lock—a flag (bit or int) associated with shared data. A thread must check the state of the lock prior to</span></div>
<div style="position:absolute;left:72.00px;top:279.96px" class="cls_006"><span class="cls_006">entering the critical section. If the lock is off, no other thread currently is executing in the critical section.</span></div>
<div style="position:absolute;left:72.00px;top:292.08px" class="cls_006"><span class="cls_006">Consequently, access permission is granted and the state of the lock status is changed to reflect it. (Testing</span></div>
<div style="position:absolute;left:72.00px;top:304.08px" class="cls_006"><span class="cls_006">and setting the lock are guaranteed to be atomic by the hardware.) If the lock is on, the thread must wait</span></div>
<div style="position:absolute;left:72.00px;top:316.20px" class="cls_006"><span class="cls_006">until the lock status is turned off by the thread currently executing in the critical section. When a critical</span></div>
<div style="position:absolute;left:72.00px;top:328.32px" class="cls_006"><span class="cls_006">section is protected by a lock, we often say that its execution is sequential. Multiple threads wanting to</span></div>
<div style="position:absolute;left:72.00px;top:340.32px" class="cls_006"><span class="cls_006">enter the critical section have to line up and enter one at a time.</span></div>
<div style="position:absolute;left:72.00px;top:366.48px" class="cls_006"><span class="cls_006">With this terminology out of the way, we move on to discuss ways to alleviate the scalability bottlenecks</span></div>
<div style="position:absolute;left:72.00px;top:378.48px" class="cls_006"><span class="cls_006">inherent in sequential execution.</span></div>
<div style="position:absolute;left:72.00px;top:432.24px" class="cls_016"><span class="cls_016">Break Up a Task into Multiple Subtasks</span></div>
<div style="position:absolute;left:72.00px;top:463.68px" class="cls_006"><span class="cls_006">To unleash potential scalability, your application must divide its computational task into multiple subtasks</span></div>
<div style="position:absolute;left:72.00px;top:475.68px" class="cls_006"><span class="cls_006">that could be executed in parallel. The Web server is a good example. The computational task is to service</span></div>
<div style="position:absolute;left:72.00px;top:487.80px" class="cls_006"><span class="cls_006">multiple client requests as they arrive on a designated HTTP port. If your Web server is single-threaded, it</span></div>
<div style="position:absolute;left:72.00px;top:499.80px" class="cls_006"><span class="cls_006">can perform only one request at a time; all other requests have to wait on a queue. To enable scalability we</span></div>
<div style="position:absolute;left:72.00px;top:511.92px" class="cls_006"><span class="cls_006">must break up the service task. The task of servicing all the requests on the queue is split into smaller tasks</span></div>
<div style="position:absolute;left:72.00px;top:524.04px" class="cls_006"><span class="cls_006">of serving a single request. By unleashing multiple threads on the smaller subtasks, we can achieve true</span></div>
<div style="position:absolute;left:72.00px;top:536.04px" class="cls_006"><span class="cls_006">parallelism and scalability. Breaking up the Web service into parallel subtasks improves several</span></div>
<div style="position:absolute;left:72.00px;top:548.16px" class="cls_006"><span class="cls_006">performance indicators:</span></div>
<div style="position:absolute;left:90.00px;top:574.44px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Response-time of an individual request</span></div>
<div style="position:absolute;left:90.00px;top:586.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Server throughput in requests-per-second</span></div>
<div style="position:absolute;left:90.00px;top:599.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Better server CPU utilization</span></div>
<div style="position:absolute;left:72.00px;top:625.20px" class="cls_006"><span class="cls_006">A Web server performs frequent blocking I/O operations. If the server consists of a single thread, no work</span></div>
<div style="position:absolute;left:72.00px;top:637.32px" class="cls_006"><span class="cls_006">is performed while waiting on I/O completion. A multithreaded server would just switch over to perform</span></div>
<div style="position:absolute;left:72.00px;top:649.32px" class="cls_006"><span class="cls_006">other tasks and keep the processors humming. The result is better throughput and higher CPU utilization.</span></div>
<div style="position:absolute;left:72.00px;top:661.44px" class="cls_006"><span class="cls_006">One thing that makes customers sick is seeing their 12-way SMP server at 25% CPU utilization.</span></div>
<div style="position:absolute;left:72.00px;top:687.48px" class="cls_006"><span class="cls_006">There are some commercial Web servers that are single-threaded by design. These vendors have</span></div>
<div style="position:absolute;left:72.00px;top:699.60px" class="cls_006"><span class="cls_006">intentionally ignored the high volume Web sites that typically require SMP servers. Instead, single-</span></div>
<div style="position:absolute;left:72.00px;top:711.60px" class="cls_006"><span class="cls_006">threaded servers are targeted at the low-volume Web sites running on low-end uniprocessor servers.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">162</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:149952px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background177.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.80px" class="cls_016"><span class="cls_016">Cache Shared Data</span></div>
<div style="position:absolute;left:72.00px;top:102.12px" class="cls_006"><span class="cls_006">Anytime you can skip a visit to a critical section, you are looking at a scalability gain. The simplest</span></div>
<div style="position:absolute;left:72.00px;top:114.24px" class="cls_006"><span class="cls_006">application of this idea is by caching shared data and reusing it in future access without needing to lock</span></div>
<div style="position:absolute;left:72.00px;top:126.36px" class="cls_006"><span class="cls_006">and unlock a shared resource. This was actually the single biggest scalability optimization that we made to</span></div>
<div style="position:absolute;left:72.00px;top:138.36px" class="cls_006"><span class="cls_006">our original Web server design and implementation. Initially, not only did it not scale, it had actually</span></div>
<div style="position:absolute;left:72.00px;top:150.48px" class="cls_006"><span class="cls_006">exhibited fractional scaling—throughput was slashed in half when we moved from a uniprocessor to a 4-</span></div>
<div style="position:absolute;left:72.00px;top:162.48px" class="cls_006"><span class="cls_006">way SMP. Something was seriously wrong.</span></div>
<div style="position:absolute;left:72.00px;top:188.64px" class="cls_006"><span class="cls_006">We have already described the overall design of our Web server earlier in this chapter. We had a 1-1</span></div>
<div style="position:absolute;left:72.00px;top:200.64px" class="cls_006"><span class="cls_006">mapping between threads and requests. A pool of available threads had consumed requests off the</span></div>
<div style="position:absolute;left:72.00px;top:212.76px" class="cls_006"><span class="cls_006">connection queue. Once a request was assigned to a particular thread, it remained confined to that thread</span></div>
<div style="position:absolute;left:72.00px;top:224.88px" class="cls_006"><span class="cls_006">for the duration of request handling. There were many objects pertaining to the request that were</span></div>
<div style="position:absolute;left:72.00px;top:236.88px" class="cls_006"><span class="cls_006">manipulated throughout the lifetime of a request. We needed to make those objects available to those</span></div>
<div style="position:absolute;left:72.00px;top:249.00px" class="cls_006"><span class="cls_006">routines that needed them. We could have passed them on the stack as function call arguments, but that</span></div>
<div style="position:absolute;left:72.00px;top:261.00px" class="cls_006"><span class="cls_006">would force us to pass 10-15 object references to hundreds of deeply nested calls. Not only would this be</span></div>
<div style="position:absolute;left:72.00px;top:273.12px" class="cls_006"><span class="cls_006">ugly, it would raise the overhead of function and procedure calls.</span></div>
<div style="position:absolute;left:72.00px;top:299.16px" class="cls_006"><span class="cls_006">A more elegant choice was made to package all the relevant data in a single data structure. A skeleton of it</span></div>
<div style="position:absolute;left:72.00px;top:311.28px" class="cls_006"><span class="cls_006">is shown here:</span></div>
<div style="position:absolute;left:72.00px;top:336.96px" class="cls_020"><span class="cls_020">class ThreadSpecificData {</span></div>
<div style="position:absolute;left:96.00px;top:348.36px" class="cls_020"><span class="cls_020">HTRequest</span></div>
<div style="position:absolute;left:167.98px;top:348.36px" class="cls_020"><span class="cls_020">*reqPtr;</span></div>
<div style="position:absolute;left:233.97px;top:348.36px" class="cls_020"><span class="cls_020">// Attributes of current HTTP request</span></div>
<div style="position:absolute;left:96.00px;top:359.64px" class="cls_020"><span class="cls_020">StreamSocket socket;</span></div>
<div style="position:absolute;left:233.97px;top:359.64px" class="cls_020"><span class="cls_020">// Socket used by current HTTP connection</span></div>
<div style="position:absolute;left:72.00px;top:382.32px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:408.48px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">ThreadSpecificData</span><span class="cls_006"> object contained all the data necessary for the various procedure calls</span></div>
<div style="position:absolute;left:72.00px;top:420.84px" class="cls_006"><span class="cls_006">invoked by the thread during request lifetime. Now we needed to make this data private to a particular</span></div>
<div style="position:absolute;left:72.00px;top:433.32px" class="cls_006"><span class="cls_006">thread. The </span><span class="cls_020">pthreads</span><span class="cls_006"> library provides the machinery to do that. The </span><span class="cls_020">pthread_setspecific()</span></div>
<div style="position:absolute;left:72.00px;top:445.68px" class="cls_006"><span class="cls_006">function creates the association between the calling thread and the data pointer:</span></div>
<div style="position:absolute;left:72.00px;top:471.36px" class="cls_020"><span class="cls_020">void initThread(...)</span></div>
<div style="position:absolute;left:72.00px;top:482.76px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:505.32px" class="cls_020"><span class="cls_020">ThreadSpecificData *tsd = new ThreadSpecificData;</span></div>
<div style="position:absolute;left:96.00px;top:516.72px" class="cls_020"><span class="cls_020">pthread_setspecific(global_key, tsd);</span></div>
<div style="position:absolute;left:72.00px;top:539.40px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:565.56px" class="cls_006"><span class="cls_006">When a thread needs access to its private data it used the </span><span class="cls_020">pthread_getspecific()</span><span class="cls_006"> call to get a pointer</span></div>
<div style="position:absolute;left:72.00px;top:577.80px" class="cls_006"><span class="cls_006">to its private data:</span></div>
<div style="position:absolute;left:72.00px;top:603.60px" class="cls_020"><span class="cls_020">ThreadSpecificData *HTInitRequest (StreamSocket sock)</span></div>
<div style="position:absolute;left:72.00px;top:614.88px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:637.56px" class="cls_020"><span class="cls_020">ThreadSpecificData *tsd = pthread_getspecific(global_key);</span></div>
<div style="position:absolute;left:96.00px;top:648.84px" class="cls_020"><span class="cls_020">tsd->socket = sock;</span></div>
<div style="position:absolute;left:96.00px;top:660.24px" class="cls_020"><span class="cls_020">tsd->reqPtr = new HTRequest;</span></div>
<div style="position:absolute;left:96.00px;top:682.92px" class="cls_020"><span class="cls_020">return tsd;</span></div>
<div style="position:absolute;left:72.00px;top:694.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:719.88px" class="cls_006"><span class="cls_006">The handling of a single HTTP request necessitated invocations of many functions and procedure calls.</span></div>
<div style="position:absolute;left:72.00px;top:732.00px" class="cls_006"><span class="cls_006">The vast majority of those calls needed access to the request information stored in the</span></div>
<div style="position:absolute;left:72.00px;top:744.48px" class="cls_020"><span class="cls_020">ThreadSpecificData</span><span class="cls_006"> object. Our code was, therefore, littered with hundreds of calls to</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">163</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:150804px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background178.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_020"><span class="cls_020">pthread_getspecific()</span><span class="cls_006"> and about 100 such calls were invoked by each thread during the service of</span></div>
<div style="position:absolute;left:72.00px;top:83.76px" class="cls_006"><span class="cls_006">a single request.</span></div>
<div style="position:absolute;left:72.00px;top:110.28px" class="cls_006"><span class="cls_006">Somewhere, somehow, the </span><span class="cls_020">pthreads</span><span class="cls_006"> library is maintaining an association between threads and their</span></div>
<div style="position:absolute;left:72.00px;top:122.64px" class="cls_006"><span class="cls_006">private data. Since threads may come and go in and out of existence, this association is dynamic and must</span></div>
<div style="position:absolute;left:72.00px;top:134.64px" class="cls_006"><span class="cls_006">be protected by a lock. When you go looking for an association, you want to guarantee that it does not</span></div>
<div style="position:absolute;left:72.00px;top:146.76px" class="cls_006"><span class="cls_006">disappear from underneath your feet. What we ended up with is a situation in which multiple threads</span></div>
<div style="position:absolute;left:72.00px;top:158.88px" class="cls_006"><span class="cls_006">working on distinct requests were going after the same lock, 100 times per request. As you can imagine,</span></div>
<div style="position:absolute;left:72.00px;top:170.88px" class="cls_006"><span class="cls_006">threads spent most of their time spinning idle waiting their turn to grab a hot lock.</span></div>
<div style="position:absolute;left:72.00px;top:196.92px" class="cls_006"><span class="cls_006">This hotly contended lock creates another severe problem on an SMP architecture. The lock word is likely</span></div>
<div style="position:absolute;left:72.00px;top:209.04px" class="cls_006"><span class="cls_006">to have a copy on each and every processor cache. Since it is frequently updated (when the lock is acquired</span></div>
<div style="position:absolute;left:72.00px;top:221.16px" class="cls_006"><span class="cls_006">and released), it will trigger a </span><span class="cls_007">cache consistency</span><span class="cls_006"> storm as the SMP hardware tries to invalidate stale copies</span></div>
<div style="position:absolute;left:72.00px;top:233.16px" class="cls_006"><span class="cls_006">of the lock on all but one of the caches. </span><span class="cls_007">Cache consistency</span><span class="cls_006"> storms are bad. They hit the SMP architecture</span></div>
<div style="position:absolute;left:72.00px;top:245.28px" class="cls_006"><span class="cls_006">at its most vulnerable scalabilty factor—the bus connecting the processors to the memory subsystem and to</span></div>
<div style="position:absolute;left:72.00px;top:257.40px" class="cls_006"><span class="cls_006">one another.</span></div>
<div style="position:absolute;left:72.00px;top:283.44px" class="cls_006"><span class="cls_006">To unleash the scalability potential of our Web server, we had to ditch the frequent calls to</span></div>
<div style="position:absolute;left:72.00px;top:295.92px" class="cls_020"><span class="cls_020">pthread_getspecific()</span><span class="cls_006">. We had to find an alternate way of passing thread data around. The</span></div>
<div style="position:absolute;left:72.00px;top:308.28px" class="cls_006"><span class="cls_006">alternative was pretty simple; although the thread data was frequently updated, the pointer to it was</span></div>
<div style="position:absolute;left:72.00px;top:320.40px" class="cls_006"><span class="cls_006">constant for the life of the thread. It was essentially a read-only pointer, which automatically suggests</span></div>
<div style="position:absolute;left:72.00px;top:332.88px" class="cls_006"><span class="cls_006">caching. We get the pointer via a single </span><span class="cls_020">pthread_getspecific()</span><span class="cls_006"> call at the beginning of the request</span></div>
<div style="position:absolute;left:72.00px;top:345.24px" class="cls_006"><span class="cls_006">and subsequently pass it around on the stack as a function (or procedure) call argument. That way, we</span></div>
<div style="position:absolute;left:72.00px;top:357.84px" class="cls_006"><span class="cls_006">reduced 100 </span><span class="cls_020">pthread_getspecific()</span><span class="cls_006"> calls down to one and practically eliminated the contention for</span></div>
<div style="position:absolute;left:72.00px;top:370.08px" class="cls_006"><span class="cls_006">its internal lock.</span></div>
<div style="position:absolute;left:72.00px;top:395.88px" class="cls_020"><span class="cls_020">void HTHandleRequest (StreamSocket sock)</span></div>
<div style="position:absolute;left:72.00px;top:407.16px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:429.84px" class="cls_020"><span class="cls_020">ThreadSpecificData *tsd = HTInitRequest(sock);</span></div>
<div style="position:absolute;left:96.00px;top:452.52px" class="cls_020"><span class="cls_020">readRequest(tsd);</span></div>
<div style="position:absolute;left:96.00px;top:463.80px" class="cls_020"><span class="cls_020">mapURLToFilename(tsd);</span></div>
<div style="position:absolute;left:96.00px;top:475.20px" class="cls_020"><span class="cls_020">authenticate(tsd);</span></div>
<div style="position:absolute;left:96.00px;top:486.48px" class="cls_020"><span class="cls_020">authorize(tsd);</span></div>
<div style="position:absolute;left:96.00px;top:497.76px" class="cls_020"><span class="cls_020">sendData(tsd);</span></div>
<div style="position:absolute;left:96.00px;top:509.16px" class="cls_020"><span class="cls_020">log(tsd);</span></div>
<div style="position:absolute;left:96.00px;top:520.44px" class="cls_020"><span class="cls_020">cleanup(tsd);</span></div>
<div style="position:absolute;left:72.00px;top:543.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:569.28px" class="cls_006"><span class="cls_006">By passing the data pointer on the stack, we have eliminated frequent access to the </span><span class="cls_020">pthreads</span><span class="cls_006"> container</span></div>
<div style="position:absolute;left:72.00px;top:581.64px" class="cls_006"><span class="cls_006">maintaining the thread-to-data associations. We effectively have reduced the sharing frequency of this</span></div>
<div style="position:absolute;left:72.00px;top:593.64px" class="cls_006"><span class="cls_006">container among the various threads. The reduction in sharing is a recurrent theme in most scalabilty</span></div>
<div style="position:absolute;left:72.00px;top:605.76px" class="cls_006"><span class="cls_006">optimizations.</span></div>
<div style="position:absolute;left:72.00px;top:659.52px" class="cls_016"><span class="cls_016">Share Nothing</span></div>
<div style="position:absolute;left:72.00px;top:690.84px" class="cls_006"><span class="cls_006">Reduction in sharing is good, but nothing beats eliminating contention altogether. Instead of sharing a</span></div>
<div style="position:absolute;left:72.00px;top:702.96px" class="cls_006"><span class="cls_006">resource, you can sometimes eliminate sharing completely by giving each thread its own private resource.</span></div>
<div style="position:absolute;left:72.00px;top:715.08px" class="cls_006"><span class="cls_006">Recall from the previous section that each Web server worker thread (in our implementation) maintained a</span></div>
<div style="position:absolute;left:72.00px;top:727.56px" class="cls_006"><span class="cls_006">pointer to its private data object of type </span><span class="cls_020">ThreadSpecificData</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:753.60px" class="cls_020"><span class="cls_020">class ThreadSpecificData {</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">164</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:151656px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background179.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">HTRequest *reqPtr;</span></div>
<div style="position:absolute;left:221.97px;top:70.56px" class="cls_020"><span class="cls_020">// Attributes of current HTTP request</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:119.40px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">reqPtr</span><span class="cls_006"> member was a pointer to an </span><span class="cls_020">HTRequest</span><span class="cls_006"> object containing information about the current</span></div>
<div style="position:absolute;left:72.00px;top:131.76px" class="cls_006"><span class="cls_006">HTTP request. At the beginning of each request, the worker thread created a brand new object of type</span></div>
<div style="position:absolute;left:72.00px;top:144.24px" class="cls_020"><span class="cls_020">HTRequest</span><span class="cls_006">:</span></div>
<div style="position:absolute;left:72.00px;top:170.28px" class="cls_020"><span class="cls_020">ThreadSpecificData *HTInitRequest(StreamSocket sock)</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:204.24px" class="cls_020"><span class="cls_020">tsd->reqPtr = new HTRequest;</span></div>
<div style="position:absolute;left:72.00px;top:226.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:253.08px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">HTRequest</span><span class="cls_006"> object was destroyed during request cleanup stage:</span></div>
<div style="position:absolute;left:72.00px;top:279.00px" class="cls_020"><span class="cls_020">void cleanup (ThreadSpecificData *tsd)</span></div>
<div style="position:absolute;left:72.00px;top:290.28px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:301.68px" class="cls_020"><span class="cls_020">delete tsd->reqPtr;</span></div>
<div style="position:absolute;left:72.00px;top:324.36px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:350.52px" class="cls_006"><span class="cls_006">It may not look like it on the surface but there is some thread friction going on here by calling </span><span class="cls_020">new()</span><span class="cls_006"> and</span></div>
<div style="position:absolute;left:72.00px;top:363.24px" class="cls_020"><span class="cls_020">delete()</span><span class="cls_006">. Using the global </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006"> created contention among the worker threads. These</span></div>
<div style="position:absolute;left:72.00px;top:375.60px" class="cls_006"><span class="cls_006">calls manage memory in the process scope that is shared by all the threads of the process. Access to the</span></div>
<div style="position:absolute;left:72.00px;top:388.20px" class="cls_006"><span class="cls_006">internal data structures manipulated by </span><span class="cls_020">new()</span><span class="cls_006"> and </span><span class="cls_020">delete()</span><span class="cls_006"> must be protected for mutual exclusion.</span></div>
<div style="position:absolute;left:72.00px;top:400.44px" class="cls_006"><span class="cls_006">There are parts of their implementation that are sequential by nature.</span></div>
<div style="position:absolute;left:72.00px;top:427.08px" class="cls_006"><span class="cls_006">The solution in this case is fairly simple. The </span><span class="cls_020">HTRequest</span><span class="cls_006"> object should not be allocated from the heap on</span></div>
<div style="position:absolute;left:72.00px;top:439.80px" class="cls_006"><span class="cls_006">every request. It should be embedded in the </span><span class="cls_020">ThreadSpecificData</span><span class="cls_006"> object belonging to the thread and</span></div>
<div style="position:absolute;left:72.00px;top:452.16px" class="cls_006"><span class="cls_006">recycled for subsequent requests:</span></div>
<div style="position:absolute;left:72.00px;top:477.84px" class="cls_020"><span class="cls_020">class ThreadSpecificData {</span></div>
<div style="position:absolute;left:96.00px;top:489.24px" class="cls_020"><span class="cls_020">HTRequest req;</span></div>
<div style="position:absolute;left:197.98px;top:489.24px" class="cls_020"><span class="cls_020">// An object, not a pointer to one</span></div>
<div style="position:absolute;left:72.00px;top:511.92px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:538.08px" class="cls_006"><span class="cls_006">Now, instead of allocating and deallocating </span><span class="cls_020">HTRequest</span><span class="cls_006"> object we simply recycle the one we have:</span></div>
<div style="position:absolute;left:72.00px;top:564.00px" class="cls_020"><span class="cls_020">ThreadSpecificData *HTInitRequest(StreamSocket sock)</span></div>
<div style="position:absolute;left:72.00px;top:575.40px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:597.96px" class="cls_020"><span class="cls_020">tsd->req.init();</span></div>
<div style="position:absolute;left:72.00px;top:620.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:646.92px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">HTRequest</span><span class="cls_006"> object was recycled during cleanup:</span></div>
<div style="position:absolute;left:72.00px;top:672.84px" class="cls_020"><span class="cls_020">void cleanup (ThreadSpecificData *tsd)</span></div>
<div style="position:absolute;left:72.00px;top:684.12px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:695.40px" class="cls_020"><span class="cls_020">tsd->req.reset();</span></div>
<div style="position:absolute;left:72.00px;top:718.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:744.36px" class="cls_006"><span class="cls_006">Now, </span><span class="cls_020">HTRequest::init()</span><span class="cls_006"> and </span><span class="cls_020">HTRequest::reset()</span><span class="cls_006"> don't have any serialized code whatsoever</span></div>
<div style="position:absolute;left:72.00px;top:756.60px" class="cls_006"><span class="cls_006">since they work on an object privately owned by the thread.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">165</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:152508px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background180.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">Shared resource pools are a must when you cannot tell in advance how many instances of the resource you</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">may need. If you do know, however, that you are going to need only a fixed number of instances, you can</span></div>
<div style="position:absolute;left:72.00px;top:95.52px" class="cls_006"><span class="cls_006">go ahead and make them private. In our case all we needed was a single instance of </span><span class="cls_020">HTrequest</span><span class="cls_006">, per</span></div>
<div style="position:absolute;left:72.00px;top:107.88px" class="cls_006"><span class="cls_006">request. We have completely eliminated the sharing of a resource (in this case, memory management data</span></div>
<div style="position:absolute;left:72.00px;top:120.48px" class="cls_006"><span class="cls_006">structures) by making the </span><span class="cls_020">HTRequest</span><span class="cls_006"> object thread-private.</span></div>
<div style="position:absolute;left:72.00px;top:174.48px" class="cls_016"><span class="cls_016">Partial Sharing</span></div>
<div style="position:absolute;left:72.00px;top:205.80px" class="cls_006"><span class="cls_006">We have previously encountered the two opposite extremes of resource sharing: the publicly shared</span></div>
<div style="position:absolute;left:72.00px;top:217.92px" class="cls_006"><span class="cls_006">resource pool and the thread-private instance of a resource. Between these two extremes lie the sharing</span></div>
<div style="position:absolute;left:72.00px;top:229.92px" class="cls_006"><span class="cls_006">middleground of the partial-sharing resource pool.</span></div>
<div style="position:absolute;left:72.00px;top:256.08px" class="cls_006"><span class="cls_006">When each thread requires a single instance of a resource, you can easily eliminate contention by making it</span></div>
<div style="position:absolute;left:72.00px;top:268.08px" class="cls_006"><span class="cls_006">thread-private. If the required number of instances cannot be determined in advance, you need to use a</span></div>
<div style="position:absolute;left:72.00px;top:280.20px" class="cls_006"><span class="cls_006">resource pool that is shared among all threads. Such shared resources often become a contention hot spot</span></div>
<div style="position:absolute;left:72.00px;top:292.20px" class="cls_006"><span class="cls_006">among threads, which severely degrades performance and scalability. Threads spend significant cycles</span></div>
<div style="position:absolute;left:72.00px;top:304.32px" class="cls_006"><span class="cls_006">spinning idle. Partial-sharing of resource pools offers a way out of a hotly contended resource.</span></div>
<div style="position:absolute;left:72.00px;top:330.36px" class="cls_006"><span class="cls_006">Originally, we started with a single resource pool serving all threads, as shown in </span><span class="cls_036">Figure 15.6</span><span class="cls_006">. Our goal</span></div>
<div style="position:absolute;left:72.00px;top:342.48px" class="cls_006"><span class="cls_006">was to reduce thread contention by reducing the number of threads competing for a resource. Towards that</span></div>
<div style="position:absolute;left:72.00px;top:354.60px" class="cls_006"><span class="cls_006">goal we converted the single resource pool into multiple identical subpools. We prefered two pools with</span></div>
<div style="position:absolute;left:72.00px;top:366.60px" class="cls_006"><span class="cls_006">half the contention, or four pools with one fourth contention over a single pool that draws all the fire</span></div>
<div style="position:absolute;left:72.00px;top:378.72px" class="cls_006"><span class="cls_006">(</span><span class="cls_036">Figure 15.7</span><span class="cls_006">).</span></div>
<div style="position:absolute;left:202.56px;top:404.88px" class="cls_021"><span class="cls_021">Figure 15.6. A single shared resource.</span></div>
<div style="position:absolute;left:171.36px;top:692.40px" class="cls_021"><span class="cls_021">Figure 15.7. Breaking up a single shared resource.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">166</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:153360px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background181.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:348.96px" class="cls_006"><span class="cls_006">The threads that formerly all ganged up on a single pool have gotten distributed over multiple subpools.</span></div>
<div style="position:absolute;left:72.00px;top:360.96px" class="cls_006"><span class="cls_006">Distributing the thread requests to separate pools could be achieved by generating a random number,</span></div>
<div style="position:absolute;left:72.00px;top:373.08px" class="cls_006"><span class="cls_006">hashing on the thread ID, or any other trick for fast random distribution. Each subpool must still be</span></div>
<div style="position:absolute;left:72.00px;top:385.20px" class="cls_006"><span class="cls_006">protected for mutual exclusion, but the thread contention has been reduced to a fraction of its previous</span></div>
<div style="position:absolute;left:72.00px;top:397.20px" class="cls_006"><span class="cls_006">levels.</span></div>
<div style="position:absolute;left:72.00px;top:423.24px" class="cls_006"><span class="cls_006">As you increase the number of subpools, contention among threads decreases. Eventually, you may end up</span></div>
<div style="position:absolute;left:72.00px;top:435.36px" class="cls_006"><span class="cls_006">reaching the extreme where the number of pools roughly equals the number of threads. In that case, it is</span></div>
<div style="position:absolute;left:72.00px;top:447.48px" class="cls_006"><span class="cls_006">almost like having a thread-private resource with no contention.</span></div>
<div style="position:absolute;left:72.00px;top:473.52px" class="cls_006"><span class="cls_006">We speculate that in most practical scenarios, splitting a single pool into two, four or even eight subpools</span></div>
<div style="position:absolute;left:72.00px;top:485.64px" class="cls_006"><span class="cls_006">will suffice to reduce contention into negligible levels. There's a point where going beyond will provide</span></div>
<div style="position:absolute;left:72.00px;top:497.64px" class="cls_006"><span class="cls_006">only diminishing returns. The ultimate judge is empirical data, which is application dependent.</span></div>
<div style="position:absolute;left:72.00px;top:551.40px" class="cls_016"><span class="cls_016">Lock Granularity</span></div>
<div style="position:absolute;left:72.00px;top:582.84px" class="cls_006"><span class="cls_006">Most reasonable implementations of a Web server will make some rudimentary statistics available to the</span></div>
<div style="position:absolute;left:72.00px;top:594.84px" class="cls_006"><span class="cls_006">Web master. For example, our implementation kept track of the number of HTTP and HTTPS (SSL)</span></div>
<div style="position:absolute;left:72.00px;top:606.96px" class="cls_006"><span class="cls_006">requests:</span></div>
<div style="position:absolute;left:72.00px;top:632.64px" class="cls_020"><span class="cls_020">class HTStats {</span></div>
<div style="position:absolute;left:96.00px;top:643.92px" class="cls_020"><span class="cls_020">int httpReqs;</span></div>
<div style="position:absolute;left:96.00px;top:655.32px" class="cls_020"><span class="cls_020">int sslReqs;</span></div>
<div style="position:absolute;left:96.00px;top:666.60px" class="cls_020"><span class="cls_020">pthread_mutex_t lock;</span></div>
<div style="position:absolute;left:72.00px;top:689.28px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:714.96px" class="cls_006"><span class="cls_006">Since multiple threads may try to manipulate the statistics concurrently, we had to protect it with a mutex</span></div>
<div style="position:absolute;left:72.00px;top:727.08px" class="cls_006"><span class="cls_006">lock:</span></div>
<div style="position:absolute;left:72.00px;top:752.76px" class="cls_020"><span class="cls_020">void HTStats::addHttpReq()// Increment the counter for HTTP requests.</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:154212px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background182.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">pthread_mutex_lock(&lock);</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">httpReqs++;</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">pthread_mutex_unlock(&lock);</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:138.48px" class="cls_020"><span class="cls_020">void HTStats::addSslReq()// Increment the counter for HTTPS requests.</span></div>
<div style="position:absolute;left:72.00px;top:149.88px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:161.16px" class="cls_020"><span class="cls_020">pthread_mutex_lock(&lock);</span></div>
<div style="position:absolute;left:96.00px;top:172.56px" class="cls_020"><span class="cls_020">sslReqs++;</span></div>
<div style="position:absolute;left:96.00px;top:183.84px" class="cls_020"><span class="cls_020">pthread_mutex_unlock(&lock);</span></div>
<div style="position:absolute;left:72.00px;top:195.12px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:221.40px" class="cls_006"><span class="cls_006">As you can tell from this code, the </span><span class="cls_020">HTStats</span><span class="cls_006"> class uses a single lock to protect the manipulation of all of</span></div>
<div style="position:absolute;left:72.00px;top:233.64px" class="cls_006"><span class="cls_006">its counters. Fusing multiple unrelated shared resources under the umbrella of a single lock is normally a</span></div>
<div style="position:absolute;left:72.00px;top:245.76px" class="cls_006"><span class="cls_006">bad idea. It widens the scope of the critical sections and creates friction among otherwise independent</span></div>
<div style="position:absolute;left:72.00px;top:257.76px" class="cls_006"><span class="cls_006">threads. The only possible exception to this rule is when the following two conditions are satisfied:</span></div>
<div style="position:absolute;left:90.00px;top:284.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   All of the shared resources are always manipulated together.</span></div>
<div style="position:absolute;left:90.00px;top:296.40px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   None of the manipulations of the shared resources consume significant CPU cycles.</span></div>
<div style="position:absolute;left:72.00px;top:322.56px" class="cls_006"><span class="cls_006">Although shared counters satisfy the second condition (updates are fast), in the case of counting HTTP and</span></div>
<div style="position:absolute;left:72.00px;top:334.56px" class="cls_006"><span class="cls_006">SSL requests, the first condition was broken: A thread that updated one counter did not access the other.</span></div>
<div style="position:absolute;left:72.00px;top:346.68px" class="cls_006"><span class="cls_006">An SSL thread would update the SSL counter but have no interest in the state of the HTTP counter. Just</span></div>
<div style="position:absolute;left:72.00px;top:358.80px" class="cls_006"><span class="cls_006">like breaking a single resource pool into multiple subpools, we prefer two distinct locks protecting two</span></div>
<div style="position:absolute;left:72.00px;top:370.80px" class="cls_006"><span class="cls_006">counters so that the contention for each lock is reduced by half.</span></div>
<div style="position:absolute;left:72.00px;top:396.60px" class="cls_020"><span class="cls_020">class HTStats {</span></div>
<div style="position:absolute;left:96.00px;top:407.88px" class="cls_020"><span class="cls_020">int httpReqs;</span></div>
<div style="position:absolute;left:96.00px;top:419.16px" class="cls_020"><span class="cls_020">pthread_mutex_t lockHttp;</span></div>
<div style="position:absolute;left:96.00px;top:441.84px" class="cls_020"><span class="cls_020">char smpDmz[CACHE_LINE_SIZE];</span></div>
<div style="position:absolute;left:287.96px;top:441.84px" class="cls_020"><span class="cls_020">// Will explain this one later</span></div>
<div style="position:absolute;left:96.00px;top:464.52px" class="cls_020"><span class="cls_020">int sslReqs;</span></div>
<div style="position:absolute;left:96.00px;top:475.80px" class="cls_020"><span class="cls_020">pthread_mutex_t lockSsl;</span></div>
<div style="position:absolute;left:72.00px;top:498.48px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:524.16px" class="cls_006"><span class="cls_006">The updates for HTTP and SSL counters will now use distinct locks:</span></div>
<div style="position:absolute;left:72.00px;top:549.96px" class="cls_020"><span class="cls_020">void HTStats::addHttpReq()// Increment the counter for HTTP requests.</span></div>
<div style="position:absolute;left:72.00px;top:561.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:572.52px" class="cls_020"><span class="cls_020">pthread_mutex_lock(&lockHttp);</span></div>
<div style="position:absolute;left:96.00px;top:583.92px" class="cls_020"><span class="cls_020">httpReqs++;</span></div>
<div style="position:absolute;left:96.00px;top:595.20px" class="cls_020"><span class="cls_020">pthread_mutex_unlock(&lockHttp);</span></div>
<div style="position:absolute;left:72.00px;top:606.60px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:629.16px" class="cls_020"><span class="cls_020">void HTStats::addSslReq()// Increment the counter for HTTPS requests.</span></div>
<div style="position:absolute;left:72.00px;top:640.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:651.84px" class="cls_020"><span class="cls_020">pthread_mutex_lock(&lockSsl);</span></div>
<div style="position:absolute;left:96.00px;top:663.24px" class="cls_020"><span class="cls_020">sslReqs++;</span></div>
<div style="position:absolute;left:96.00px;top:674.52px" class="cls_020"><span class="cls_020">pthread_mutex_unlock(&lockSsl);</span></div>
<div style="position:absolute;left:72.00px;top:685.80px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:711.60px" class="cls_006"><span class="cls_006">This implementation increases scalability and prevents the sets of SSL and HTTP threads from getting in</span></div>
<div style="position:absolute;left:72.00px;top:724.08px" class="cls_006"><span class="cls_006">each other's way. Conversely, we can use </span><span class="cls_020">HTStats</span><span class="cls_006"> to show an example where lock-fusion actually makes</span></div>
<div style="position:absolute;left:72.00px;top:736.44px" class="cls_006"><span class="cls_006">sense. Suppose we also keep track of the cumulative number of bytes served on each protocol:</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">168</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:155064px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background183.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">class HTStats {</span></div>
<div style="position:absolute;left:96.00px;top:81.84px" class="cls_020"><span class="cls_020">int httpReqs;</span></div>
<div style="position:absolute;left:96.00px;top:93.24px" class="cls_020"><span class="cls_020">int httpBytes;</span></div>
<div style="position:absolute;left:239.97px;top:93.24px" class="cls_020"><span class="cls_020">// Add this</span></div>
<div style="position:absolute;left:96.00px;top:104.52px" class="cls_020"><span class="cls_020">pthread_mutex_t lockHttp;</span></div>
<div style="position:absolute;left:96.00px;top:127.20px" class="cls_020"><span class="cls_020">char smpDmz[CACHE_LINE_SIZE];</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">int sslReqs;</span></div>
<div style="position:absolute;left:96.00px;top:149.88px" class="cls_020"><span class="cls_020">int sslBytes;</span></div>
<div style="position:absolute;left:233.97px;top:149.88px" class="cls_020"><span class="cls_020">// Add this</span></div>
<div style="position:absolute;left:96.00px;top:161.16px" class="cls_020"><span class="cls_020">pthread_mutex_t lockSsl;</span></div>
<div style="position:absolute;left:72.00px;top:183.84px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:72.00px;top:209.52px" class="cls_006"><span class="cls_006">An HTTP thread that updated the number of HTTP requests will always update the number of bytes sent as</span></div>
<div style="position:absolute;left:72.00px;top:221.64px" class="cls_006"><span class="cls_006">well. These two counters are updated together and involve fast operations such as integer addition. For</span></div>
<div style="position:absolute;left:72.00px;top:233.64px" class="cls_006"><span class="cls_006">those reasons we chose to fuse them under the same lock:</span></div>
<div style="position:absolute;left:72.00px;top:259.44px" class="cls_020"><span class="cls_020">void HTStats::updateHttpCounters(int nBytes)</span></div>
<div style="position:absolute;left:395.94px;top:259.44px" class="cls_020"><span class="cls_020">// Increment HTTP</span></div>
<div style="position:absolute;left:72.00px;top:270.72px" class="cls_020"><span class="cls_020">counters.</span></div>
<div style="position:absolute;left:72.00px;top:282.00px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:293.40px" class="cls_020"><span class="cls_020">pthread_mutex_lock(&lockHttp);</span></div>
<div style="position:absolute;left:96.00px;top:304.68px" class="cls_020"><span class="cls_020">httpReqs++;</span></div>
<div style="position:absolute;left:96.00px;top:316.08px" class="cls_020"><span class="cls_020">httpBytes += nBytes;</span></div>
<div style="position:absolute;left:96.00px;top:327.36px" class="cls_020"><span class="cls_020">pthread_mutex_unlock(&lockHttp);</span></div>
<div style="position:absolute;left:72.00px;top:338.64px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:364.44px" class="cls_006"><span class="cls_006">By separating the SSL and HTTP statistics, we reduced contention for the respective lock. The original</span></div>
<div style="position:absolute;left:72.00px;top:376.44px" class="cls_006"><span class="cls_006">design having a single lock created artificial contention among SSL and HTTP threads. On the other hand,</span></div>
<div style="position:absolute;left:72.00px;top:388.56px" class="cls_006"><span class="cls_006">we did choose to fuse the updates to two related HTTP statistics. Otherwise, we would have to waste a pair</span></div>
<div style="position:absolute;left:72.00px;top:400.56px" class="cls_006"><span class="cls_006">of calls to lock and unlock each counter.</span></div>
<div style="position:absolute;left:72.00px;top:427.20px" class="cls_006"><span class="cls_006">So far so good, but what is that </span><span class="cls_020">smpDmz</span><span class="cls_006"> character array doing in the middle of our </span><span class="cls_020">HTStats</span><span class="cls_006"> class</span></div>
<div style="position:absolute;left:72.00px;top:439.44px" class="cls_006"><span class="cls_006">definition? This is our SMP demilitarized zone. It has to do with false sharing, which we discuss next.</span></div>
<div style="position:absolute;left:72.00px;top:493.32px" class="cls_016"><span class="cls_016">False Sharing</span></div>
<div style="position:absolute;left:72.00px;top:524.64px" class="cls_006"><span class="cls_006">The atomic unit of a cache is a line. A typical cache line may hold a large number of bytes. A 128-byte</span></div>
<div style="position:absolute;left:72.00px;top:536.64px" class="cls_006"><span class="cls_006">cache line is typical. When a 4-byte integer is loaded from main memory, it is not loaded in isolation. The</span></div>
<div style="position:absolute;left:72.00px;top:548.76px" class="cls_006"><span class="cls_006">whole line containing it is loaded into the cache at once. Similarly, when that integer value is invalidated</span></div>
<div style="position:absolute;left:72.00px;top:560.88px" class="cls_006"><span class="cls_006">by another cache (running on a different processor), the whole cache line is invalidated. It follows that the</span></div>
<div style="position:absolute;left:72.00px;top:572.88px" class="cls_006"><span class="cls_006">physical memory layout of variables can play a role in SMP scalability.</span></div>
<div style="position:absolute;left:72.00px;top:599.40px" class="cls_006"><span class="cls_006">Take the </span><span class="cls_020">HTStats</span><span class="cls_006"> class discussed earlier. If you eliminate the </span><span class="cls_020">smpDmz</span><span class="cls_006"> character array, you will end up</span></div>
<div style="position:absolute;left:72.00px;top:611.76px" class="cls_006"><span class="cls_006">with the two locks close to one another as in:</span></div>
<div style="position:absolute;left:72.00px;top:637.44px" class="cls_020"><span class="cls_020">class HTStats {</span></div>
<div style="position:absolute;left:96.00px;top:648.84px" class="cls_020"><span class="cls_020">int httpReqs;</span></div>
<div style="position:absolute;left:96.00px;top:660.12px" class="cls_020"><span class="cls_020">int httpBytes;</span></div>
<div style="position:absolute;left:96.00px;top:671.52px" class="cls_020"><span class="cls_020">pthread_mutex_t lockHttp;</span></div>
<div style="position:absolute;left:96.00px;top:694.08px" class="cls_020"><span class="cls_020">int sslReqs;</span></div>
<div style="position:absolute;left:227.97px;top:694.08px" class="cls_020"><span class="cls_020">// 4 bytes</span></div>
<div style="position:absolute;left:96.00px;top:705.48px" class="cls_020"><span class="cls_020">int sslBytes;</span></div>
<div style="position:absolute;left:227.97px;top:705.48px" class="cls_020"><span class="cls_020">// 4 bytes</span></div>
<div style="position:absolute;left:96.00px;top:716.76px" class="cls_020"><span class="cls_020">pthread_mutex_t lockSsl;</span></div>
<div style="position:absolute;left:72.00px;top:739.44px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">169</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:155916px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background184.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">The two locks (</span><span class="cls_020">lockHttp</span><span class="cls_006"> and </span><span class="cls_020">lockSsl</span><span class="cls_006">) are only eight bytes apart. They are very likely to end up</span></div>
<div style="position:absolute;left:72.00px;top:83.76px" class="cls_006"><span class="cls_006">residing on the same cache line. Suppose that we have an SMP system where thread T1 is executing an</span></div>
<div style="position:absolute;left:72.00px;top:95.76px" class="cls_006"><span class="cls_006">HTTP request on processor P1 and thread T2 is executing an SSL request on P2. When T1 acquires the</span></div>
<div style="position:absolute;left:72.00px;top:108.36px" class="cls_006"><span class="cls_006">HTTP lock (</span><span class="cls_020">lockHttp</span><span class="cls_006">), it modifies the value of that lock variable on the P1 cache. That same cache line</span></div>
<div style="position:absolute;left:72.00px;top:121.20px" class="cls_006"><span class="cls_006">on P2 is now invalid. When T2 tries to acquire </span><span class="cls_020">lockSsl</span><span class="cls_006">, it takes a cache miss because that line has been</span></div>
<div style="position:absolute;left:72.00px;top:133.44px" class="cls_006"><span class="cls_006">invalidated.</span></div>
<div style="position:absolute;left:72.00px;top:159.60px" class="cls_006"><span class="cls_006">You can imagine how this scenario progresses: Threads running on P1 and P2 will continuously invalidate</span></div>
<div style="position:absolute;left:72.00px;top:171.60px" class="cls_006"><span class="cls_006">each other's cache line where these two locks reside. Keep in mind that our threads are not colliding on an</span></div>
<div style="position:absolute;left:72.00px;top:183.72px" class="cls_006"><span class="cls_006">application shared resource. They are colliding on a cache line, which is an artifact of the class memory</span></div>
<div style="position:absolute;left:72.00px;top:195.84px" class="cls_006"><span class="cls_006">layout combined with hardware architecture issues such as </span><span class="cls_007">cache consistency</span><span class="cls_006">. The resulting </span><span class="cls_007">cache</span></div>
<div style="position:absolute;left:72.00px;top:207.84px" class="cls_007"><span class="cls_007">consistency</span><span class="cls_006"> storm can seriously degrade performance and scalability by lowering the cache hit rate below</span></div>
<div style="position:absolute;left:72.00px;top:219.96px" class="cls_006"><span class="cls_006">90%.</span></div>
<div style="position:absolute;left:72.00px;top:246.48px" class="cls_006"><span class="cls_006">In the case of </span><span class="cls_020">HTStats</span><span class="cls_006">, we inserted the </span><span class="cls_020">smpDmz</span><span class="cls_006"> character array to guarantee that the two hot locks will</span></div>
<div style="position:absolute;left:72.00px;top:258.84px" class="cls_006"><span class="cls_006">not share a cache line. Ideally, a lock should be placed in close proximity to the shared data that it protects.</span></div>
<div style="position:absolute;left:72.00px;top:312.60px" class="cls_016"><span class="cls_016">Thundering Herd</span></div>
<div style="position:absolute;left:72.00px;top:343.92px" class="cls_006"><span class="cls_006">When a thread fails to acquire a busy lock, it can proceed in one of two ways:</span></div>
<div style="position:absolute;left:90.00px;top:370.20px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Spin in a tight loop trying to grab the lock on each iteration. This is effective only for short-lived</span></div>
<div style="position:absolute;left:108.00px;top:382.32px" class="cls_006"><span class="cls_006">locks. Spin-locks that are held for long periods of time will cause threads to tie up the CPUs while</span></div>
<div style="position:absolute;left:108.00px;top:394.44px" class="cls_006"><span class="cls_006">spinning idle waiting on the shared resource to become available.</span></div>
<div style="position:absolute;left:90.00px;top:406.68px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Go to sleep and await notification. When the lock is freed, waiting threads are awakened. We'll</span></div>
<div style="position:absolute;left:108.00px;top:418.80px" class="cls_006"><span class="cls_006">call this type a simple-lock to distinguish it from the spin-lock.</span></div>
<div style="position:absolute;left:72.00px;top:444.84px" class="cls_006"><span class="cls_006">When a large number of threads concurrently contend for a simple-lock, all but one are put to sleep. What</span></div>
<div style="position:absolute;left:72.00px;top:456.96px" class="cls_006"><span class="cls_006">happens when the lock finally becomes available? Again, there are two scenarios:</span></div>
<div style="position:absolute;left:90.00px;top:483.24px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Only a single thread on the waiting list is awakened. Typically, this will be the highest priority</span></div>
<div style="position:absolute;left:108.00px;top:495.36px" class="cls_006"><span class="cls_006">thread on the waiting list.</span></div>
<div style="position:absolute;left:90.00px;top:507.72px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   All the waiting threads are awakened. This triggers the Thundering Herd [</span><span class="cls_036">Cam91</span><span class="cls_006">].</span></div>
<div style="position:absolute;left:72.00px;top:533.76px" class="cls_006"><span class="cls_006">The problem with awakening all waiting threads is that all but one are going to lose and go back to sleep.</span></div>
<div style="position:absolute;left:72.00px;top:545.88px" class="cls_006"><span class="cls_006">Given that thread context switches are not cheap, we are looking at a substantial performance and</span></div>
<div style="position:absolute;left:72.00px;top:557.88px" class="cls_006"><span class="cls_006">scalablity loss. The Thundering Herd event is not an esoteric one. It is a real threat to many commercial</span></div>
<div style="position:absolute;left:72.00px;top:570.00px" class="cls_006"><span class="cls_006">server implementations. We have encountered it ourselves during the design and implementation of our</span></div>
<div style="position:absolute;left:72.00px;top:582.00px" class="cls_006"><span class="cls_006">Web server.</span></div>
<div style="position:absolute;left:72.00px;top:608.16px" class="cls_006"><span class="cls_006">When we described our three-stage pipeline of accept-serve-log, you might have wondered why we limited</span></div>
<div style="position:absolute;left:72.00px;top:620.16px" class="cls_006"><span class="cls_006">the accept stage to a single thread. This decision was a direct result of trying to avoid a Thundering Herd.</span></div>
<div style="position:absolute;left:72.00px;top:646.80px" class="cls_006"><span class="cls_006">When a server thread intends to accept a new TCP/IP connection, it must perform an </span><span class="cls_020">accept()</span><span class="cls_006"> call. The</span></div>
<div style="position:absolute;left:72.00px;top:659.52px" class="cls_020"><span class="cls_020">accept()</span><span class="cls_006"> tells TCP/IP that the calling thread would like to accept the next available connection on a</span></div>
<div style="position:absolute;left:72.00px;top:671.88px" class="cls_006"><span class="cls_006">given TCP/IP port.</span></div>
<div style="position:absolute;left:72.00px;top:697.92px" class="cls_006"><span class="cls_006">For each port, TCP/IP maintains a queue of incoming connections and a queue of threads waiting to accept</span></div>
<div style="position:absolute;left:72.00px;top:710.04px" class="cls_006"><span class="cls_006">new connections. Connections are handed over to accepting threads in order of arrival. If no threads are</span></div>
<div style="position:absolute;left:72.00px;top:722.04px" class="cls_006"><span class="cls_006">waiting, connections are queued. If no connections are available, waiting threads are queued.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">170</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:156768px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background185.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">Now picture this: A large number of threads perform an </span><span class="cls_020">accept()</span><span class="cls_006"> on a port (say, port 80) while the</span></div>
<div style="position:absolute;left:72.00px;top:83.76px" class="cls_006"><span class="cls_006">connection queue is empty. All threads are added to the waiting list. Internally, all these threads are put to</span></div>
<div style="position:absolute;left:72.00px;top:95.76px" class="cls_006"><span class="cls_006">sleep waiting on a signal. Sometime later a connection is established. On most platforms all waiting</span></div>
<div style="position:absolute;left:72.00px;top:107.88px" class="cls_006"><span class="cls_006">threads are signalled to wake up, which then causes a mad dash to grab the CPU (hence the name</span></div>
<div style="position:absolute;left:72.00px;top:120.00px" class="cls_006"><span class="cls_006">"Thundering Herd"). One lucky thread is going to seize the CPU first and accept the only available</span></div>
<div style="position:absolute;left:72.00px;top:132.00px" class="cls_006"><span class="cls_006">connection on the port. The rest of the threads are going to waste a context switch only to find that the</span></div>
<div style="position:absolute;left:72.00px;top:144.12px" class="cls_006"><span class="cls_006">connection queue for this port is empty again. All but one thread are going back to sleep on the waiting list.</span></div>
<div style="position:absolute;left:72.00px;top:156.12px" class="cls_006"><span class="cls_006">If we had 100 threads on the waiting list, only one was going to grab the new connection. The other 99</span></div>
<div style="position:absolute;left:72.00px;top:168.24px" class="cls_006"><span class="cls_006">were going to waste a costly context switch without performing any useful work. This CPU thrashing can</span></div>
<div style="position:absolute;left:72.00px;top:180.36px" class="cls_006"><span class="cls_006">bring a server to its knees and seriously damage throughput. What most system administrators tend to do</span></div>
<div style="position:absolute;left:72.00px;top:192.36px" class="cls_006"><span class="cls_006">when throughput is degraded is to increase the number of server threads, which only aggravates the</span></div>
<div style="position:absolute;left:72.00px;top:204.48px" class="cls_006"><span class="cls_006">problem. When a Thundering Herd is in effect, more threads mean less performance.</span></div>
<div style="position:absolute;left:72.00px;top:230.52px" class="cls_006"><span class="cls_006">Our Web server implementation ran on many different platforms, which was one of our claims to fame.</span></div>
<div style="position:absolute;left:72.00px;top:243.12px" class="cls_006"><span class="cls_006">Initially, all but one of those platforms suffered from the </span><span class="cls_020">accept()</span><span class="cls_006"> Thundering Herd problem. On those</span></div>
<div style="position:absolute;left:72.00px;top:255.36px" class="cls_006"><span class="cls_006">platforms we had to use a single thread to accept new connections. A prototype that used multiple threads</span></div>
<div style="position:absolute;left:72.00px;top:267.96px" class="cls_006"><span class="cls_006">had exhibited worse performance than a single-threaded </span><span class="cls_020">accept()</span><span class="cls_006">. This is one of those scenarios where</span></div>
<div style="position:absolute;left:72.00px;top:280.32px" class="cls_006"><span class="cls_006">you can have too many threads.</span></div>
<div style="position:absolute;left:72.00px;top:306.36px" class="cls_006"><span class="cls_006">The Thundering Herd is not limited to TCP/IP. It may happen any time a large number of threads compete</span></div>
<div style="position:absolute;left:72.00px;top:318.48px" class="cls_006"><span class="cls_006">for too few resources. The place where you are most likely to run into it is locking. The lock itself is a</span></div>
<div style="position:absolute;left:72.00px;top:330.48px" class="cls_006"><span class="cls_006">single resource for which many threads contend. The solution here is to learn the characteristics of the</span></div>
<div style="position:absolute;left:72.00px;top:342.60px" class="cls_006"><span class="cls_006">locking schemes available on your platform.</span></div>
<div style="position:absolute;left:72.00px;top:368.64px" class="cls_006"><span class="cls_006">Some platforms provide both type of simple-locks—the type that wakes up all waiting threads as well as</span></div>
<div style="position:absolute;left:72.00px;top:380.76px" class="cls_006"><span class="cls_006">the type that wakes up only one. If you have that choice, you ought to use the single-thread wakeup</span></div>
<div style="position:absolute;left:72.00px;top:392.76px" class="cls_006"><span class="cls_006">locking scheme.</span></div>
<div style="position:absolute;left:72.00px;top:446.64px" class="cls_016"><span class="cls_016">Reader/Writer Locks</span></div>
<div style="position:absolute;left:72.00px;top:477.96px" class="cls_006"><span class="cls_006">Another way to ease the pain of synchronization is to relax the requirement that one and only one thread</span></div>
<div style="position:absolute;left:72.00px;top:489.96px" class="cls_006"><span class="cls_006">may have exclusive access to shared data. The need to serialize access to shared data stems from the fact</span></div>
<div style="position:absolute;left:72.00px;top:502.08px" class="cls_006"><span class="cls_006">that the shared data may be modified by one of the threads accessing it. It follows that we must give</span></div>
<div style="position:absolute;left:72.00px;top:514.20px" class="cls_006"><span class="cls_006">exclusive access only to those threads aiming to modify shared data (writers). Conversely, threads that are</span></div>
<div style="position:absolute;left:72.00px;top:526.20px" class="cls_006"><span class="cls_006">merely interested in reading shared data (readers) could access shared data concurrently.</span></div>
<div style="position:absolute;left:72.00px;top:552.36px" class="cls_006"><span class="cls_006">Reader/writer locks are those that allow multiple readers to access shared data instead of waiting for</span></div>
<div style="position:absolute;left:72.00px;top:564.36px" class="cls_006"><span class="cls_006">exclusive access. A thread trying to get read access to shared data will be granted read access in one of two</span></div>
<div style="position:absolute;left:72.00px;top:576.48px" class="cls_006"><span class="cls_006">cases:</span></div>
<div style="position:absolute;left:90.00px;top:602.76px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   No other thread was granted access.</span></div>
<div style="position:absolute;left:90.00px;top:615.12px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The only threads granted access are readers.</span></div>
<div style="position:absolute;left:72.00px;top:641.16px" class="cls_006"><span class="cls_006">If a writer thread has been granted access, all readers must wait for the writer thread to leave the critical</span></div>
<div style="position:absolute;left:72.00px;top:653.28px" class="cls_006"><span class="cls_006">section. A writer thread is granted access if and only if no other thread has been granted access to the</span></div>
<div style="position:absolute;left:72.00px;top:665.28px" class="cls_006"><span class="cls_006">shared resource.</span></div>
<div style="position:absolute;left:72.00px;top:691.44px" class="cls_006"><span class="cls_006">Many platforms provide reader/writer locks. If such locks are not available for a specific platform, you can</span></div>
<div style="position:absolute;left:72.00px;top:703.44px" class="cls_006"><span class="cls_006">build your own from the available synchronization primitive building blocks. See [</span><span class="cls_036">NBF96</span><span class="cls_006">] for one such</span></div>
<div style="position:absolute;left:72.00px;top:715.56px" class="cls_006"><span class="cls_006">implementation.</span></div>
<div style="position:absolute;left:72.00px;top:741.60px" class="cls_006"><span class="cls_006">If all your threads try to modify a shared resource, then reader/writer locks would not help. In fact, they</span></div>
<div style="position:absolute;left:72.00px;top:753.72px" class="cls_006"><span class="cls_006">would hurt performance as their implementation is by nature more complex and therefore slower than plain</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">171</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:157620px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background186.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">locks. If, however, your shared data is read-mostly, reader/writer locks will improve scalability by</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">eliminating contention among reader threads.</span></div>
<div style="position:absolute;left:72.00px;top:136.80px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:168.36px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   SMP is currently the dominant MP architecture. It consists of multiple symmetric processors</span></div>
<div style="position:absolute;left:108.00px;top:180.48px" class="cls_006"><span class="cls_006">connected via a single bus to a single memory system. The bus is the scalability weak link in the</span></div>
<div style="position:absolute;left:108.00px;top:192.48px" class="cls_006"><span class="cls_006">SMP architecture. Large caches, one per processor, are meant to keep bus contention under</span></div>
<div style="position:absolute;left:108.00px;top:204.60px" class="cls_006"><span class="cls_006">control.</span></div>
<div style="position:absolute;left:90.00px;top:216.96px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Amdahl's Law puts an upper limit on the potential scalability of an application. The scalability is</span></div>
<div style="position:absolute;left:108.00px;top:228.96px" class="cls_006"><span class="cls_006">limited by portions of the computation that are serialized.</span></div>
<div style="position:absolute;left:72.00px;top:255.12px" class="cls_006"><span class="cls_006">The trick to scalability is to reduce and, if possible, eliminate serialized code. Following are some steps</span></div>
<div style="position:absolute;left:72.00px;top:267.12px" class="cls_006"><span class="cls_006">you can take towards that goal:</span></div>
<div style="position:absolute;left:90.00px;top:293.40px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Split a monolithic task into multiple subtasks that are conducive to parallel execution by</span></div>
<div style="position:absolute;left:108.00px;top:305.52px" class="cls_006"><span class="cls_006">concurrent threads.</span></div>
<div style="position:absolute;left:90.00px;top:317.88px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Code motion. Critical sections should contain critical code and nothing else. Code that does not</span></div>
<div style="position:absolute;left:108.00px;top:329.88px" class="cls_006"><span class="cls_006">directly manipulate shared resources should not reside in the critical section.</span></div>
<div style="position:absolute;left:90.00px;top:342.24px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Cache. At times, it may be possible to eliminate execution visits to a critical section by caching</span></div>
<div style="position:absolute;left:108.00px;top:354.36px" class="cls_006"><span class="cls_006">the result of an earlier visit.</span></div>
<div style="position:absolute;left:90.00px;top:366.60px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Share nothing. If you only need a small, fixed number of resource instances, you should avoid the</span></div>
<div style="position:absolute;left:108.00px;top:378.72px" class="cls_006"><span class="cls_006">use of public resource pools. Make those instances thread-private and recycle them.</span></div>
<div style="position:absolute;left:90.00px;top:391.08px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Partial-sharing. It is better to have two identical pools with half the contention.</span></div>
<div style="position:absolute;left:90.00px;top:403.32px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Lock granularity. Don't fuse resources under the protection of the same lock unless they are</span></div>
<div style="position:absolute;left:108.00px;top:415.44px" class="cls_006"><span class="cls_006">always updated together.</span></div>
<div style="position:absolute;left:90.00px;top:427.80px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   False sharing. Don't place two hot locks in close proximity in the class definition. You don't want</span></div>
<div style="position:absolute;left:108.00px;top:439.80px" class="cls_006"><span class="cls_006">them to share the same cache line and trigger </span><span class="cls_007">cache consistency</span><span class="cls_006"> storms.</span></div>
<div style="position:absolute;left:90.00px;top:452.16px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Thundering Herd. Investigate the characteristics of your locking calls. When the lock is freed,</span></div>
<div style="position:absolute;left:108.00px;top:464.28px" class="cls_006"><span class="cls_006">does it wake up all waiting threads or just one? Those that wake up all threads threaten the</span></div>
<div style="position:absolute;left:108.00px;top:476.28px" class="cls_006"><span class="cls_006">scalability of an application.</span></div>
<div style="position:absolute;left:90.00px;top:488.64px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   System and library calls. Investigate the characteristics of their implementation. Some of them are</span></div>
<div style="position:absolute;left:108.00px;top:500.76px" class="cls_006"><span class="cls_006">hiding significant portions of serialized code.</span></div>
<div style="position:absolute;left:90.00px;top:513.00px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Reader/writer locks. Shared data that is read-mostly will benefit from these locks. They eliminate</span></div>
<div style="position:absolute;left:108.00px;top:525.12px" class="cls_006"><span class="cls_006">contention among reader threads.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">172</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:158472px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background187.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Chapter 16. System Architecture Dependencies</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">We have tried to avoid waving our hands at performance problems because we wanted to provide as much</span></div>
<div style="position:absolute;left:72.00px;top:129.96px" class="cls_006"><span class="cls_006">practical information as possible. Most of the foregoing performance discussion has been fairly self-</span></div>
<div style="position:absolute;left:72.00px;top:142.08px" class="cls_006"><span class="cls_006">contained. If you know how to program in C++ then hopefully it made sense. Now we are entering an area</span></div>
<div style="position:absolute;left:72.00px;top:154.08px" class="cls_006"><span class="cls_006">that is deeply rooted in nonprogramming concepts. Hardware dependency is based on how the hardware</span></div>
<div style="position:absolute;left:72.00px;top:166.20px" class="cls_006"><span class="cls_006">works. Unfortunately, unless you have a reasonable background in hardware architecture, some of it may</span></div>
<div style="position:absolute;left:72.00px;top:178.32px" class="cls_006"><span class="cls_006">not be easy to understand.</span></div>
<div style="position:absolute;left:72.00px;top:204.36px" class="cls_006"><span class="cls_006">Computer science increasingly has become a software science in which the vagaries of how the hardware</span></div>
<div style="position:absolute;left:72.00px;top:216.36px" class="cls_006"><span class="cls_006">actually functions has been left to the train drivers (engineers). This shift away from deep-seated</span></div>
<div style="position:absolute;left:72.00px;top:228.48px" class="cls_006"><span class="cls_006">knowledge of hardware functionality has not, in general, hurt most programmers. However, optimal</span></div>
<div style="position:absolute;left:72.00px;top:240.60px" class="cls_006"><span class="cls_006">software performance cannot be obtained without the ability to intellectually translate high-level software</span></div>
<div style="position:absolute;left:72.00px;top:252.60px" class="cls_006"><span class="cls_006">structures into low-level hardware sequences. The sort of information required is not the type of thing that</span></div>
<div style="position:absolute;left:72.00px;top:264.72px" class="cls_006"><span class="cls_006">you pick up by reading a chapter in a book. It is the type of thing you start to understand by studying things</span></div>
<div style="position:absolute;left:72.00px;top:276.84px" class="cls_006"><span class="cls_006">like the Hennessy and Patterson [HP97] and Patterson and Hennessy [PH96] tomes.</span></div>
<div style="position:absolute;left:72.00px;top:302.88px" class="cls_006"><span class="cls_006">This chapter contains lots of information, but it is largely of the "look out!" and "remember" sort. We</span></div>
<div style="position:absolute;left:72.00px;top:314.88px" class="cls_006"><span class="cls_006">considered abandoning the discussion altogether, but we decided that the discussion may benefit those with</span></div>
<div style="position:absolute;left:72.00px;top:327.00px" class="cls_006"><span class="cls_006">the requisite background, and at least it may open the door to ultimate performance for those that have not</span></div>
<div style="position:absolute;left:72.00px;top:339.12px" class="cls_006"><span class="cls_006">yet delved into the hardware side of the performance equation.</span></div>
<div style="position:absolute;left:72.00px;top:392.88px" class="cls_016"><span class="cls_016">Memory Hierarchies</span></div>
<div style="position:absolute;left:72.00px;top:424.20px" class="cls_006"><span class="cls_006">Any discussion of performance must, in the end, center on memory usage and memory usage patterns.</span></div>
<div style="position:absolute;left:72.00px;top:436.32px" class="cls_006"><span class="cls_006">Frequently the most significant aspects of algorithmic complexity are centered on the number and type of</span></div>
<div style="position:absolute;left:72.00px;top:448.32px" class="cls_006"><span class="cls_006">memory accesses an algorithm requires. It has never been more true than it is now that calculation is fast</span></div>
<div style="position:absolute;left:72.00px;top:460.44px" class="cls_006"><span class="cls_006">and access is slow.</span></div>
<div style="position:absolute;left:72.00px;top:486.48px" class="cls_006"><span class="cls_006">There are now typically at least five levels in the memory hierarchy of the average computer. Some of the</span></div>
<div style="position:absolute;left:72.00px;top:498.60px" class="cls_006"><span class="cls_006">main levels of the memory hierarchy sometimes contain sublevels. The memory hierarchy, from its fastest</span></div>
<div style="position:absolute;left:72.00px;top:510.60px" class="cls_006"><span class="cls_006">(lowest access time) to its slowest (highest access time) consists of registers, L1 (level one) on-chip cache,</span></div>
<div style="position:absolute;left:72.00px;top:522.72px" class="cls_006"><span class="cls_006">L2 (level two) off-chip cache, main memory (semiconductor dynamic random access memory in all its</span></div>
<div style="position:absolute;left:72.00px;top:534.84px" class="cls_006"><span class="cls_006">varieties: DRAM, SRDAM, RAMBUS, SyncLink, etc.), and disk storage. Some of the newer processors</span></div>
<div style="position:absolute;left:72.00px;top:546.84px" class="cls_006"><span class="cls_006">carry two levels of cache on-chip, which we would have considered to be logically a single L1 cache,</span></div>
<div style="position:absolute;left:72.00px;top:558.96px" class="cls_006"><span class="cls_006">which itself is made up of a smaller extremely fast store and a larger very fast store. Most hard disks now</span></div>
<div style="position:absolute;left:72.00px;top:570.96px" class="cls_006"><span class="cls_006">carry their own local caches, and the storage hierarchy of systems with such disks can be thought of as</span></div>
<div style="position:absolute;left:72.00px;top:583.08px" class="cls_006"><span class="cls_006">consisting of two subsystems: a relatively fast, small store, and a relatively slow, huge store.</span></div>
<div style="position:absolute;left:72.00px;top:609.12px" class="cls_006"><span class="cls_006">There is a strong tendency to look at memory access simply in terms of access times and cycle rates. This</span></div>
<div style="position:absolute;left:72.00px;top:621.24px" class="cls_006"><span class="cls_006">view ignores the interaction between latency and bandwidth. Access time is a latency issue: How long does</span></div>
<div style="position:absolute;left:72.00px;top:633.36px" class="cls_006"><span class="cls_006">it take to start getting data? Bus width and burst length are bandwidth issues: How much data can I get</span></div>
<div style="position:absolute;left:72.00px;top:645.36px" class="cls_006"><span class="cls_006">once it starts arriving? This is akin to the notion of a fire hose: How long does it take to open the valve,</span></div>
<div style="position:absolute;left:72.00px;top:657.48px" class="cls_006"><span class="cls_006">once it is open how much water does the hose deliver per second, and how much water is in the trunk?</span></div>
<div style="position:absolute;left:72.00px;top:683.52px" class="cls_006"><span class="cls_006">Latency is not improving at the same rate that bandwidth is, or, we can move blocks of data with good</span></div>
<div style="position:absolute;left:72.00px;top:695.64px" class="cls_006"><span class="cls_006">average access times, but accessing individual bytes of memory is increasingly slow. For example, in the</span></div>
<div style="position:absolute;left:72.00px;top:707.64px" class="cls_006"><span class="cls_006">last five years (circa 1999) processor speeds have gone from 90MHz to 500MHz, but main memory access</span></div>
<div style="position:absolute;left:72.00px;top:719.76px" class="cls_006"><span class="cls_006">times have only gone from 120ns to 50ns (even the best 8ns SDRAM requires six cycles for the first</span></div>
<div style="position:absolute;left:72.00px;top:731.88px" class="cls_006"><span class="cls_006">access). This means that processors are more than five times faster than they were, but memory is only two</span></div>
<div style="position:absolute;left:72.00px;top:743.88px" class="cls_006"><span class="cls_006">and a half times as fast. Conversely, memory bandwidth performance has done a better job of keeping pace</span></div>
<div style="position:absolute;left:72.00px;top:756.00px" class="cls_006"><span class="cls_006">with processor performance. In the last five years, memory busses have doubled in width and the current</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">173</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:159324px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background188.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">burst characteristics of DRAM significantly increases the effective memory bandwidth. The story about</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">disk performance is similar. Access times have not kept pace, but bandwidth has not suffered to the same</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">degree.</span></div>
<div style="position:absolute;left:72.00px;top:121.20px" class="cls_006"><span class="cls_006">A perusal of main memory access characteristics for a computer may look something like "6-1-1-1-2-1-1-</span></div>
<div style="position:absolute;left:72.00px;top:133.20px" class="cls_006"><span class="cls_006">1." This means six bus cycles for the initial access and then one bus cycle for each of the next three</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_006"><span class="cls_006">accesses, followed by two bus cycles for the next access and then three more single-cycle accesses. When</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">you consider that a bus cycle is now typically four processor cycles, this means that a processor is idled for</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">24 cycles every time it goes out to main memory, and the entire cache line read will take almost 60</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">instruction cycles. This is not always the case; some sophisticated architectures support multiple</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">outstanding memory requests, and they request data before it is actually needed, but the general principal</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">still generally holds—we hurry up and wait.</span></div>
<div style="position:absolute;left:72.00px;top:231.72px" class="cls_006"><span class="cls_006">In terms of current technology (circa 1999) the access latencies for each level of the memory hierarchy are</span></div>
<div style="position:absolute;left:72.00px;top:243.84px" class="cls_006"><span class="cls_006">shown in </span><span class="cls_036">Table 16-1</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:269.88px" class="cls_006"><span class="cls_006">From these numbers it may seem that the registers and cache have roughly the same performance, but this</span></div>
<div style="position:absolute;left:72.00px;top:282.00px" class="cls_006"><span class="cls_006">is not at all the case. Computation requires both latency and bandwidth. A register set typically can handle</span></div>
<div style="position:absolute;left:72.00px;top:294.00px" class="cls_006"><span class="cls_006">three operands per clock cycle. An L1 cache can really supply only about half of an operand per cycle</span></div>
<div style="position:absolute;left:72.00px;top:306.12px" class="cls_006"><span class="cls_006">because a cache access requires a register access or two to create the effective address that will be used to</span></div>
<div style="position:absolute;left:72.00px;top:318.12px" class="cls_006"><span class="cls_006">access the cache. Thus a register set has roughly six times the bandwidth of an L1 cache. So while an L1</span></div>
<div style="position:absolute;left:72.00px;top:329.40px" class="cls_006"><span class="cls_006">cache can have good latency characteristics, its bandwidth is not particularly good.</span><span class="cls_037"><sup>[1]</sup></span></div>
<div style="position:absolute;left:90.00px;top:356.16px" class="cls_026"><span class="cls_026"><sup>[1]</sup></span><span class="cls_027"> This discussion is a general one and probably not exactly true of any specific hardware, though generally</span></div>
<div style="position:absolute;left:90.00px;top:370.08px" class="cls_027"><span class="cls_027">true of most hardwares. Super-pipelined and super-scalar architectures bias the effective speed of registers</span></div>
<div style="position:absolute;left:90.00px;top:380.40px" class="cls_027"><span class="cls_027">and caches in different ways, but in general registers tend to provide much more bandwidth than the cache</span></div>
<div style="position:absolute;left:90.00px;top:390.60px" class="cls_027"><span class="cls_027">no matter what type of processor you are using.</span></div>
<div style="position:absolute;left:211.92px;top:417.00px" class="cls_021"><span class="cls_021">Table 16.1. Memory Access Speed</span></div>
<div style="position:absolute;left:72.00px;top:432.12px" class="cls_031"><span class="cls_031">Memory Level</span></div>
<div style="position:absolute;left:358.68px;top:432.12px" class="cls_031"><span class="cls_031">Latency</span></div>
<div style="position:absolute;left:72.00px;top:447.12px" class="cls_032"><span class="cls_032">Disk</span></div>
<div style="position:absolute;left:358.66px;top:447.12px" class="cls_032"><span class="cls_032">10ms</span></div>
<div style="position:absolute;left:72.00px;top:462.24px" class="cls_032"><span class="cls_032">DRAM</span></div>
<div style="position:absolute;left:358.61px;top:462.24px" class="cls_032"><span class="cls_032">50ns</span></div>
<div style="position:absolute;left:72.00px;top:477.36px" class="cls_032"><span class="cls_032">L2 Cache</span></div>
<div style="position:absolute;left:358.63px;top:477.36px" class="cls_032"><span class="cls_032">4-8ns</span></div>
<div style="position:absolute;left:72.00px;top:492.36px" class="cls_032"><span class="cls_032">L1 Cache</span></div>
<div style="position:absolute;left:358.66px;top:492.36px" class="cls_032"><span class="cls_032">2ns</span></div>
<div style="position:absolute;left:72.00px;top:507.48px" class="cls_032"><span class="cls_032">Registers</span></div>
<div style="position:absolute;left:358.65px;top:507.48px" class="cls_032"><span class="cls_032">2ns</span></div>
<div style="position:absolute;left:72.00px;top:563.16px" class="cls_016"><span class="cls_016">Registers: Kings of Memory</span></div>
<div style="position:absolute;left:72.00px;top:594.48px" class="cls_006"><span class="cls_006">Registers are the lowest latency, highest bandwidth, lowest specification overhead entities in the memory</span></div>
<div style="position:absolute;left:72.00px;top:606.48px" class="cls_006"><span class="cls_006">hierarchy. As already indicated, they are effectively at least twice as fast as an L1 cache. Typically, register</span></div>
<div style="position:absolute;left:72.00px;top:618.60px" class="cls_006"><span class="cls_006">sets are at least triple ported; that is, a register set typically can read two operands and write one operand</span></div>
<div style="position:absolute;left:72.00px;top:630.72px" class="cls_006"><span class="cls_006">every clock cycle. This means that a simple 600MHz, 64-bit RISC architecture would have a maximum</span></div>
<div style="position:absolute;left:72.00px;top:642.72px" class="cls_006"><span class="cls_006">register bandwidth of approximately 14.4 gigabytes per second. This is three to six times greater than a</span></div>
<div style="position:absolute;left:72.00px;top:654.84px" class="cls_006"><span class="cls_006">respectable L1 cache's bandwidth and more than 30 times the effective bandwidth of a 64-bit wide,</span></div>
<div style="position:absolute;left:72.00px;top:666.96px" class="cls_006"><span class="cls_006">100MHz external DRAM interface.</span></div>
<div style="position:absolute;left:72.00px;top:693.00px" class="cls_006"><span class="cls_006">Registers are directly addressed within machine code statements. Five bits within an instruction format can</span></div>
<div style="position:absolute;left:72.00px;top:705.00px" class="cls_006"><span class="cls_006">access one operand (a 5-bit register specifier can address one of 32 registers). This means that a three-</span></div>
<div style="position:absolute;left:72.00px;top:717.12px" class="cls_006"><span class="cls_006">operand, 32-bit instruction has an effective register bandwidth of three operands per 32-bit instruction, or a</span></div>
<div style="position:absolute;left:72.00px;top:729.24px" class="cls_006"><span class="cls_006">three-to-one ratio of operands to instructions. All other levels of the memory hierarchy are based on virtual</span></div>
<div style="position:absolute;left:72.00px;top:741.24px" class="cls_006"><span class="cls_006">or physical addresses or on indices within an operating-system-managed storage system (file system). To</span></div>
<div style="position:absolute;left:72.00px;top:753.36px" class="cls_006"><span class="cls_006">obtain a memory-based operand, at least one full address of bits are necessary to load it, plus another</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">174</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:160176px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background189.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">instruction may be needed at some point to store the value. On a RISC processor with 32-bit instructions</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">and 32-bit data addresses, this would mean that 64 bits would be required to perform any meaningful</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">operation on a single operand. Thus registers have six times less operational overhead, three-to-six times</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">more bandwidth, and half the latency of an L1 cache. The advantage of registers vis-à-vis the other</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">succeeding levels of the memory hierarchy are proportionally greater.</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_006"><span class="cls_006">So, registers are great. Let's just put all our data in the registers and be done with the rest of the memory</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">hierarchy. This solution will work fine if your program has less than a couple dozen atomic variables, but</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">any program of even modest size will find the confines of the register set far too restrictive. Many</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">processors now sport 32 general purpose registers and there are architectures soon to be released that have</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">in excess of 100 registers. But even if a "magic" huge register set could be designed (one that did not need</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">to pay any homage to the laws of physics) the direct addressing characteristic of registers makes them a</span></div>
<div style="position:absolute;left:72.00px;top:217.68px" class="cls_006"><span class="cls_006">difficult medium for large-scale memory mapping. Direct addressing provides registers with much of their</span></div>
<div style="position:absolute;left:72.00px;top:229.80px" class="cls_006"><span class="cls_006">speed, but it also makes it impossible to embed arrays into registers and dynamically index them (without</span></div>
<div style="position:absolute;left:72.00px;top:241.92px" class="cls_006"><span class="cls_006">resorting to self-modifying code, a compelling capability in this instance, but one fraught with difficulties).</span></div>
<div style="position:absolute;left:72.00px;top:253.92px" class="cls_006"><span class="cls_006">It is extremely difficult to create a pointer to a register-based variable. Variable-to-register mapping is</span></div>
<div style="position:absolute;left:72.00px;top:266.04px" class="cls_006"><span class="cls_006">context insensitive; that is, register 3 is always register 3, independent of how deep we might be in a call</span></div>
<div style="position:absolute;left:72.00px;top:278.16px" class="cls_006"><span class="cls_006">tree (this is actually only mostly true; architectures that support overlapping register windows do remap</span></div>
<div style="position:absolute;left:72.00px;top:290.16px" class="cls_006"><span class="cls_006">registers).</span></div>
<div style="position:absolute;left:72.00px;top:316.20px" class="cls_006"><span class="cls_006">Registers work great as temporary repositories of atomic data, but there are too few of them and their</span></div>
<div style="position:absolute;left:72.00px;top:328.32px" class="cls_006"><span class="cls_006">addressing characteristics are too limited to consider them seriously as the only memory store. They are</span></div>
<div style="position:absolute;left:72.00px;top:340.44px" class="cls_006"><span class="cls_006">great for the right type of temporary data, though. Let's examine what the right kind of temporary data is,</span></div>
<div style="position:absolute;left:72.00px;top:352.44px" class="cls_006"><span class="cls_006">and let's also look at what compilers can do to help in the variable-to-register mapping department, as well</span></div>
<div style="position:absolute;left:72.00px;top:364.56px" class="cls_006"><span class="cls_006">as what we can do to assist the compiler when it fails to make the best decisions.</span></div>
<div style="position:absolute;left:72.00px;top:390.60px" class="cls_006"><span class="cls_006">Compiler writers are as aware of the importance of good register mapping as anyone. They do their best to</span></div>
<div style="position:absolute;left:72.00px;top:402.72px" class="cls_006"><span class="cls_006">allocate variables to registers, but they tend to be somewhat conservative and they understand the aliasing</span></div>
<div style="position:absolute;left:72.00px;top:414.72px" class="cls_006"><span class="cls_006">issues associated with languages like C++ that allow unrestricted pointer manipulation. Pointers allow</span></div>
<div style="position:absolute;left:72.00px;top:426.84px" class="cls_006"><span class="cls_006">variables to be aliased in arcane fashions. Though we believe that there is no imperative to continue to</span></div>
<div style="position:absolute;left:72.00px;top:438.96px" class="cls_006"><span class="cls_006">support this type of programming, we also realize that changes in compiler methodology that breaks</span></div>
<div style="position:absolute;left:72.00px;top:450.96px" class="cls_006"><span class="cls_006">existing code are viewed as unadvised in many circles.</span></div>
<div style="position:absolute;left:72.00px;top:477.60px" class="cls_006"><span class="cls_006">The </span><span class="cls_020">register</span><span class="cls_006"> reserved word indicates to the compiler that there is no need for a variable ever to be</span></div>
<div style="position:absolute;left:72.00px;top:489.84px" class="cls_006"><span class="cls_006">placed in memory, or more accurately, for a variable ever to have a memory address. This is just a</span></div>
<div style="position:absolute;left:72.00px;top:502.44px" class="cls_006"><span class="cls_006">suggestion, and just like the </span><span class="cls_020">inline</span><span class="cls_006"> directive, it can be ignored by the compiler. Some compilers</span></div>
<div style="position:absolute;left:72.00px;top:514.80px" class="cls_006"><span class="cls_006">completely ignore all register directives. We can only assume that the writers of such compilers believe</span></div>
<div style="position:absolute;left:72.00px;top:526.80px" class="cls_006"><span class="cls_006">that their register allocation algorithms will make better decisions than a programmer will, a belief that in</span></div>
<div style="position:absolute;left:72.00px;top:538.92px" class="cls_006"><span class="cls_006">some cases is true and in other cases is far from it.</span></div>
<div style="position:absolute;left:72.00px;top:564.96px" class="cls_006"><span class="cls_006">We earlier indicated that in an ideal world, inlining should be done automatically and optimally by the</span></div>
<div style="position:absolute;left:72.00px;top:577.08px" class="cls_006"><span class="cls_006">compiler. This is even more the case for register basing of variables. The compiler should be able to do a</span></div>
<div style="position:absolute;left:72.00px;top:589.08px" class="cls_006"><span class="cls_006">better job of register allocation, or of making decisions about where variables should be based, than a</span></div>
<div style="position:absolute;left:72.00px;top:601.20px" class="cls_006"><span class="cls_006">programmer does. If a compiler were able to take advantage of profiling information, which would give</span></div>
<div style="position:absolute;left:72.00px;top:613.32px" class="cls_006"><span class="cls_006">the compiler a reasonable basis for making decisions about the dominant execution path through each</span></div>
<div style="position:absolute;left:72.00px;top:625.32px" class="cls_006"><span class="cls_006">method, then a compiler should be able to make optimal decisions about register allocation. This seems to</span></div>
<div style="position:absolute;left:72.00px;top:637.44px" class="cls_006"><span class="cls_006">be the direction in which some compiler writers are moving and we applaud them for it. As we indicated</span></div>
<div style="position:absolute;left:72.00px;top:649.44px" class="cls_006"><span class="cls_006">earlier, we believe that profile-based compiler optimization offers the greatest possibility of automating the</span></div>
<div style="position:absolute;left:72.00px;top:661.56px" class="cls_006"><span class="cls_006">optimization process and will be the most effective technique for freeing the programmer from making</span></div>
<div style="position:absolute;left:72.00px;top:673.68px" class="cls_006"><span class="cls_006">explicit, low-level optimization decisions. Programmers should be concerned with class implementation</span></div>
<div style="position:absolute;left:72.00px;top:685.68px" class="cls_006"><span class="cls_006">decisions, not spending their time on low-level register basing issues. Unfortunately, many compilers still</span></div>
<div style="position:absolute;left:72.00px;top:697.80px" class="cls_006"><span class="cls_006">make far from optimal register basing decisions, and some programmer directed assistance is frequently in</span></div>
<div style="position:absolute;left:72.00px;top:709.92px" class="cls_006"><span class="cls_006">order.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">175</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:161028px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background190.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:71.40px" class="cls_006"><span class="cls_006">Following are three methods, </span><span class="cls_020">a</span><span class="cls_006">, </span><span class="cls_020">b</span><span class="cls_006">, and </span><span class="cls_020">c</span><span class="cls_006">, each of which contain a local variable </span><span class="cls_020">i</span><span class="cls_006">, which in method </span><span class="cls_020">a</span></div>
<div style="position:absolute;left:72.00px;top:84.24px" class="cls_006"><span class="cls_006">should be register based, in method </span><span class="cls_007">b</span><span class="cls_006"> should not be register based, and in method </span><span class="cls_020">c</span><span class="cls_006"> may or may not be a</span></div>
<div style="position:absolute;left:72.00px;top:96.48px" class="cls_006"><span class="cls_006">good candidate, based on our understanding of the common execution path for the method.</span></div>
<div style="position:absolute;left:72.00px;top:122.28px" class="cls_020"><span class="cls_020">int x::a (int x, int& y)</span></div>
<div style="position:absolute;left:72.00px;top:133.56px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:144.96px" class="cls_020"><span class="cls_020">int i = -x + y;</span></div>
<div style="position:absolute;left:96.00px;top:156.24px" class="cls_020"><span class="cls_020">y = i -10;</span></div>
<div style="position:absolute;left:96.00px;top:167.52px" class="cls_020"><span class="cls_020">i = x;</span></div>
<div style="position:absolute;left:96.00px;top:178.92px" class="cls_020"><span class="cls_020">y -= i;</span></div>
<div style="position:absolute;left:96.00px;top:201.60px" class="cls_020"><span class="cls_020">return i + 10;</span></div>
<div style="position:absolute;left:197.98px;top:201.60px" class="cls_020"><span class="cls_020">// i used 5 times in 5 instructions with</span></div>
<div style="position:absolute;left:72.00px;top:212.88px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:197.98px;top:212.88px" class="cls_020"><span class="cls_020">// no intervening calls</span></div>
<div style="position:absolute;left:72.00px;top:235.56px" class="cls_020"><span class="cls_020">int x::b (int x, int& y)</span></div>
<div style="position:absolute;left:72.00px;top:246.84px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:258.24px" class="cls_020"><span class="cls_020">int i = -x;</span></div>
<div style="position:absolute;left:96.00px;top:269.52px" class="cls_020"><span class="cls_020">y = test(x);</span></div>
<div style="position:absolute;left:96.00px;top:280.80px" class="cls_020"><span class="cls_020">y = -y;</span></div>
<div style="position:absolute;left:96.00px;top:292.20px" class="cls_020"><span class="cls_020">int j = test(y);</span></div>
<div style="position:absolute;left:96.00px;top:303.48px" class="cls_020"><span class="cls_020">y = -j + 12;</span></div>
<div style="position:absolute;left:96.00px;top:314.88px" class="cls_020"><span class="cls_020">cout &lt;&lt; j &lt;&lt; y;</span></div>
<div style="position:absolute;left:96.00px;top:337.44px" class="cls_020"><span class="cls_020">return i + j;</span></div>
<div style="position:absolute;left:191.98px;top:337.44px" class="cls_020"><span class="cls_020">// i used 2 times in 8 instructions with</span></div>
<div style="position:absolute;left:72.00px;top:348.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:191.98px;top:348.84px" class="cls_020"><span class="cls_020">// 2 intervening calls between its first</span></div>
<div style="position:absolute;left:191.98px;top:360.12px" class="cls_020"><span class="cls_020">// and last usage</span></div>
<div style="position:absolute;left:72.00px;top:382.80px" class="cls_020"><span class="cls_020">int x::c (int x, int& y)</span></div>
<div style="position:absolute;left:72.00px;top:394.08px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:405.48px" class="cls_020"><span class="cls_020">int i = -x + 100;</span></div>
<div style="position:absolute;left:96.00px;top:416.76px" class="cls_020"><span class="cls_020">if (i &lt; 0) {</span></div>
<div style="position:absolute;left:119.99px;top:428.16px" class="cls_020"><span class="cls_020">y = test(x) + i;</span></div>
<div style="position:absolute;left:96.00px;top:439.44px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:450.72px" class="cls_020"><span class="cls_020">y = -y;</span></div>
<div style="position:absolute;left:96.00px;top:462.12px" class="cls_020"><span class="cls_020">int j = 15;</span></div>
<div style="position:absolute;left:96.00px;top:473.40px" class="cls_020"><span class="cls_020">if (i &lt;= 0) {</span></div>
<div style="position:absolute;left:119.99px;top:484.80px" class="cls_020"><span class="cls_020">j = test(y) + x;</span></div>
<div style="position:absolute;left:96.00px;top:496.08px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:96.00px;top:507.36px" class="cls_020"><span class="cls_020">y -= -j + 12;</span></div>
<div style="position:absolute;left:96.00px;top:518.76px" class="cls_020"><span class="cls_020">return i + j;</span></div>
<div style="position:absolute;left:191.98px;top:518.76px" class="cls_020"><span class="cls_020">// i used 5 times in 9 instructions, but with</span></div>
<div style="position:absolute;left:72.00px;top:530.04px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:191.98px;top:530.04px" class="cls_020"><span class="cls_020">// potentially two intervening calls between</span></div>
<div style="position:absolute;left:191.98px;top:541.44px" class="cls_020"><span class="cls_020">// its first and its last usage</span></div>
<div style="position:absolute;left:72.00px;top:567.12px" class="cls_006"><span class="cls_006">The salient metric for the decision about whether to register base a variable is the number of times the</span></div>
<div style="position:absolute;left:72.00px;top:579.12px" class="cls_006"><span class="cls_006">variable will need to be loaded and stored. If a variable is register based, then the register in which it</span></div>
<div style="position:absolute;left:72.00px;top:591.24px" class="cls_006"><span class="cls_006">resides typically will need to be stored if the method makes a call and then restored when the called</span></div>
<div style="position:absolute;left:72.00px;top:603.24px" class="cls_006"><span class="cls_006">method returns. This amounts to a load and store for each method call that occurs between a variable's first</span></div>
<div style="position:absolute;left:72.00px;top:615.36px" class="cls_006"><span class="cls_006">and last usage. If the variable is not register based, then the variable will not need to be loaded and stored</span></div>
<div style="position:absolute;left:72.00px;top:627.48px" class="cls_006"><span class="cls_006">every time its defining method makes a call, but it will need to be loaded and stored every time its method</span></div>
<div style="position:absolute;left:72.00px;top:639.48px" class="cls_006"><span class="cls_006">uses it. This makes it relatively simple to count the calls and the usage points and make a decision. The</span></div>
<div style="position:absolute;left:72.00px;top:651.60px" class="cls_006"><span class="cls_006">compiler can do a relatively good job of this. The only time that the compiler should need help is when</span></div>
<div style="position:absolute;left:72.00px;top:663.72px" class="cls_006"><span class="cls_006">there are a significant number of conditionally invoked methods. These instances make profile information</span></div>
<div style="position:absolute;left:72.00px;top:675.72px" class="cls_006"><span class="cls_006">very useful, but since most compilers have no automatic feedback loops, the programmer must sometimes</span></div>
<div style="position:absolute;left:72.00px;top:687.84px" class="cls_006"><span class="cls_006">supply the appropriate hints to the compiler by specifying that certain variables should be register based.</span></div>
<div style="position:absolute;left:72.00px;top:713.88px" class="cls_006"><span class="cls_006">Proper register basing of a variable can improve the performance of individual methods generated by some</span></div>
<div style="position:absolute;left:72.00px;top:726.00px" class="cls_006"><span class="cls_006">compilers by an order of magnitude. In most such instances the compiler should recognize these</span></div>
<div style="position:absolute;left:72.00px;top:738.00px" class="cls_006"><span class="cls_006">optimization possibilities and perform register basing itself, but it never hurts to check. Register basing</span></div>
<div style="position:absolute;left:72.00px;top:750.12px" class="cls_006"><span class="cls_006">decisions, like inlining decisions, should be profile based. Only code that lies on a program's critical path</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">176</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:161880px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background191.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">should be considered for register pragma specification. One relative quality metric of a compiler can be</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">gauged by finding the most likely candidate for register basing, supplying the register pragma, recompiling,</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">and reprofiling. Any improvement in execution speed indicates that either explicit register allocation</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">decisions need to be supplied by the programmer, or that the level of optimization supplied by the compiler</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">needs to be increased. NOTE: Profile data should be gathered with the highest functional level of compiler</span></div>
<div style="position:absolute;left:72.00px;top:131.28px" class="cls_006"><span class="cls_006">optimizations enabled. Profiles of unoptimized code can make it look like the compiler was written by</span></div>
<div style="position:absolute;left:72.00px;top:143.40px" class="cls_006"><span class="cls_006">performance morons. Most compilers need to be explicitly enabled before they will perform interesting</span></div>
<div style="position:absolute;left:72.00px;top:155.40px" class="cls_006"><span class="cls_006">automatic optimizations.</span></div>
<div style="position:absolute;left:72.00px;top:209.28px" class="cls_016"><span class="cls_016">Disk and Memory Structures</span></div>
<div style="position:absolute;left:72.00px;top:240.60px" class="cls_006"><span class="cls_006">File structures are a topic for entire books all by themselves, and it is beyond the scope of this one to go</span></div>
<div style="position:absolute;left:72.00px;top:252.60px" class="cls_006"><span class="cls_006">into them in any significant detail. We will, however, discuss some of the more significant reasons why it</span></div>
<div style="position:absolute;left:72.00px;top:264.72px" class="cls_006"><span class="cls_006">is important to understand file structures and use appropriate ones when data persistence requires file</span></div>
<div style="position:absolute;left:72.00px;top:276.84px" class="cls_006"><span class="cls_006">storage, or when dynamic data size requires extensive use of virtual storage.</span></div>
<div style="position:absolute;left:72.00px;top:302.88px" class="cls_006"><span class="cls_006">B+ trees and b* trees are the canonical file structures associated with the storage of volatile ordered class</span></div>
<div style="position:absolute;left:72.00px;top:314.88px" class="cls_006"><span class="cls_006">instances. Simple linear files or indexed files are viable structures for data that has sequential access</span></div>
<div style="position:absolute;left:72.00px;top:327.00px" class="cls_006"><span class="cls_006">characteristics or that is infrequently modified. These file structures are often considered more appropriate</span></div>
<div style="position:absolute;left:72.00px;top:339.12px" class="cls_006"><span class="cls_006">to persistent storage of data, and they are not typically considered particularly applicative to run-time data</span></div>
<div style="position:absolute;left:72.00px;top:351.12px" class="cls_006"><span class="cls_006">management. Run-time management of large data sets requires a storage mechanism more closely aligned</span></div>
<div style="position:absolute;left:72.00px;top:363.24px" class="cls_006"><span class="cls_006">with the system's virtual memory mechanism.</span></div>
<div style="position:absolute;left:72.00px;top:389.28px" class="cls_006"><span class="cls_006">Unfortunately, we have met far too many programmers who view virtual memory as a "magic elixir" that</span></div>
<div style="position:absolute;left:72.00px;top:401.40px" class="cls_006"><span class="cls_006">makes unrestricted memory consumption both possible and affordable. This view is, in part, responsible</span></div>
<div style="position:absolute;left:72.00px;top:413.40px" class="cls_006"><span class="cls_006">for some of the program executable-image bloat that has become so ubiquitous. The tendency to rely on</span></div>
<div style="position:absolute;left:72.00px;top:425.52px" class="cls_006"><span class="cls_006">virtual storage to maintain very large run-time data sets has at times been exacerbated by the ability, on</span></div>
<div style="position:absolute;left:72.00px;top:437.64px" class="cls_006"><span class="cls_006">newer operating systems, to access persistent data sets (files) by mapping them into the system's virtual</span></div>
<div style="position:absolute;left:72.00px;top:449.64px" class="cls_006"><span class="cls_006">address space. This remapping of simple sequentially managed data into the random access memory model</span></div>
<div style="position:absolute;left:72.00px;top:461.76px" class="cls_006"><span class="cls_006">makes software easy to write, but it can result in programs that are not particularly efficient or fast. That is</span></div>
<div style="position:absolute;left:72.00px;top:473.76px" class="cls_006"><span class="cls_006">not to say that file mapping is an inapropriate strategy. For some types of data, mapping files to virtual</span></div>
<div style="position:absolute;left:72.00px;top:485.88px" class="cls_006"><span class="cls_006">storage can yield significant performance gains. We are only warning against an indescriminate reliance on</span></div>
<div style="position:absolute;left:72.00px;top:498.00px" class="cls_006"><span class="cls_006">an operating system's virtual memory storage mechanism.</span></div>
<div style="position:absolute;left:72.00px;top:524.04px" class="cls_006"><span class="cls_006">There is nothing magic about virtual memory. The fact that operating system code is responsible for</span></div>
<div style="position:absolute;left:72.00px;top:536.16px" class="cls_006"><span class="cls_006">maintaining the memory residence of your data instead of your own code does not necessarily make access</span></div>
<div style="position:absolute;left:72.00px;top:548.16px" class="cls_006"><span class="cls_006">to that data any faster. Disk access is roughly as expensive for the system's virtual paging system as it is for</span></div>
<div style="position:absolute;left:72.00px;top:560.28px" class="cls_006"><span class="cls_006">explicit memory management code.</span></div>
<div style="position:absolute;left:72.00px;top:586.32px" class="cls_006"><span class="cls_006">It takes an average of about 12-20 ms to access a disk (a number supplied by the disk manufacturers and</span></div>
<div style="position:absolute;left:72.00px;top:598.44px" class="cls_006"><span class="cls_006">generally considered overly optimistic, particularly on busy systems). This amounts to about 3 million</span></div>
<div style="position:absolute;left:72.00px;top:610.44px" class="cls_006"><span class="cls_006">cycles of processor latency. A typical disk access involves at least two context switches and the execution</span></div>
<div style="position:absolute;left:72.00px;top:622.56px" class="cls_006"><span class="cls_006">of a low-level device interface. This amounts to at least a couple thousand instructions of overhead. Disk</span></div>
<div style="position:absolute;left:72.00px;top:634.68px" class="cls_006"><span class="cls_006">access latency can be covered by other activities on busy systems, but the cycles consumed by the device</span></div>
<div style="position:absolute;left:72.00px;top:646.68px" class="cls_006"><span class="cls_006">interface cannot. Disk access is expensive. Undisciplined reliance on a system's virtual memory system can</span></div>
<div style="position:absolute;left:72.00px;top:658.80px" class="cls_006"><span class="cls_006">have very deleterious effects on a program's performance.</span></div>
<div style="position:absolute;left:72.00px;top:684.84px" class="cls_006"><span class="cls_006">When allocating storage, the goal should always be to maintain as much data locality as possible. If data</span></div>
<div style="position:absolute;left:72.00px;top:696.96px" class="cls_006"><span class="cls_006">sets are large, this locality should be considered page locality. Data should be organized such that a</span></div>
<div style="position:absolute;left:72.00px;top:708.96px" class="cls_006"><span class="cls_006">minimum number of page accesses are necessary. This is the raison d'être of the aforementioned b+ tree</span></div>
<div style="position:absolute;left:72.00px;top:721.08px" class="cls_006"><span class="cls_006">structure.</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:162732px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background192.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">A binary search is typically the fastest search mechanism on ordered data (let us ignore hashing for the</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">moment) with a search complexity of order log</span><span class="cls_033"><sub>2</sub></span><span class="cls_006">N. This means that an element can be found from within an</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">array of 1 billion ordered elements with only 30 comparisons. However, if 20 of those 30 comparisons</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">have a page fault associated with them, then our real efficiency is not particularly good. A solution that</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">required more comparisons, but resulted in fewer page faults would be much better. After all, the</span></div>
<div style="position:absolute;left:72.00px;top:131.28px" class="cls_006"><span class="cls_006">computational overhead of a page fault is thousands of instructions and the latency is millions of</span></div>
<div style="position:absolute;left:72.00px;top:143.40px" class="cls_006"><span class="cls_006">instructions, whereas comparisons generally require less than half a dozen instructions. You can do a lot of</span></div>
<div style="position:absolute;left:72.00px;top:155.40px" class="cls_006"><span class="cls_006">comparisons in the time it takes to process a page fault.</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">In many cases, natural data locality makes very efficient use of a system's virtual memory capability. In</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">such cases, data shows good temporal and spacial locality. This means that a program may access very</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">large quantities of data, but only a small subset of that data is actively used at one time. This subset of</span></div>
<div style="position:absolute;left:72.00px;top:217.68px" class="cls_006"><span class="cls_006">active data, called a program's working set, tends to be only a small fraction of the program's total memory</span></div>
<div style="position:absolute;left:72.00px;top:229.80px" class="cls_006"><span class="cls_006">usage, and can prove to be fairly stable (the average tenure of the pages within the working set can be</span></div>
<div style="position:absolute;left:72.00px;top:241.92px" class="cls_006"><span class="cls_006">fairly long). A program's working sets may gradually transition pages in and out as new pages are accessed</span></div>
<div style="position:absolute;left:72.00px;top:253.92px" class="cls_006"><span class="cls_006">and old pages are no longer accessed. A program's call stack demonstrates exactly this type of locality.</span></div>
<div style="position:absolute;left:72.00px;top:266.04px" class="cls_006"><span class="cls_006">Conversely, a program may exhibit a flurry of page faults as a significantly different working set is loaded</span></div>
<div style="position:absolute;left:72.00px;top:278.16px" class="cls_006"><span class="cls_006">into memory followed by a period of very infrequent page faults. A shift from one major processing</span></div>
<div style="position:absolute;left:72.00px;top:290.16px" class="cls_006"><span class="cls_006">subsystem to another can exhibit this type of behavior.</span></div>
<div style="position:absolute;left:72.00px;top:316.20px" class="cls_006"><span class="cls_006">Some programs have good data locality, whereas other programs can demonstrate sparse data usage,</span></div>
<div style="position:absolute;left:72.00px;top:328.32px" class="cls_006"><span class="cls_006">resulting in frequent page faults and poor performance. This is sometimes the result of a failure to manage</span></div>
<div style="position:absolute;left:72.00px;top:340.44px" class="cls_006"><span class="cls_006">the storage for a program's dominant classes. Class storage management has already been discussed in a</span></div>
<div style="position:absolute;left:72.00px;top:352.44px" class="cls_006"><span class="cls_006">general sense; what we are now interested in is how to manage classes with large storage requirements.</span></div>
<div style="position:absolute;left:72.00px;top:378.60px" class="cls_006"><span class="cls_006">In general, program code will tend to have very good locality, and code storage management will be</span></div>
<div style="position:absolute;left:72.00px;top:390.60px" class="cls_006"><span class="cls_006">unnecessary. In instances where the working set size of a program's code becomes problematic, the code</span></div>
<div style="position:absolute;left:72.00px;top:402.72px" class="cls_006"><span class="cls_006">may need to be rearranged based on execution profiles to locate commonly associated code within the</span></div>
<div style="position:absolute;left:72.00px;top:414.72px" class="cls_006"><span class="cls_006">same file or files. This should only be a problem in extreme instances, and it is, interestingly, a place where</span></div>
<div style="position:absolute;left:72.00px;top:427.32px" class="cls_006"><span class="cls_006">C++'s </span><span class="cls_020">namespace</span><span class="cls_006"> capability can become very handy. A very large program may benefit from spacial</span></div>
<div style="position:absolute;left:72.00px;top:440.16px" class="cls_006"><span class="cls_006">colocation of its primary methods within a single compilation unit. </span><span class="cls_020">Namespace</span><span class="cls_006">s have made this a</span></div>
<div style="position:absolute;left:72.00px;top:452.40px" class="cls_006"><span class="cls_006">relatively simple operation as each of the colocated methods can carry its own name space identifier. It is</span></div>
<div style="position:absolute;left:72.00px;top:465.00px" class="cls_006"><span class="cls_006">not a bad idea to begin to rely increasingly on </span><span class="cls_020">namespace</span><span class="cls_006">-based partitioning instead of file-location-</span></div>
<div style="position:absolute;left:72.00px;top:477.36px" class="cls_006"><span class="cls_006">based partitioning anyway. The next generation of integrated development environments could well make</span></div>
<div style="position:absolute;left:72.00px;top:489.36px" class="cls_006"><span class="cls_006">the file concept obsolete and move to automated namespace management convention (a move we heartily</span></div>
<div style="position:absolute;left:72.00px;top:501.48px" class="cls_006"><span class="cls_006">support).</span></div>
<div style="position:absolute;left:72.00px;top:527.52px" class="cls_006"><span class="cls_006">Code reorganization for performance reasons is another area where profile feedback into a compiler could</span></div>
<div style="position:absolute;left:72.00px;top:539.64px" class="cls_006"><span class="cls_006">provide significant automatic optimization. The code for a method does not care where within an</span></div>
<div style="position:absolute;left:72.00px;top:551.76px" class="cls_006"><span class="cls_006">executable module it resides, and there is no reason to necessarily keep the methods for a class together in</span></div>
<div style="position:absolute;left:72.00px;top:563.76px" class="cls_006"><span class="cls_006">one area, though you do need to be careful to maintain at least a semblance of maintainability while</span></div>
<div style="position:absolute;left:72.00px;top:575.88px" class="cls_006"><span class="cls_006">extracting that last ounce of performance. If you do spray a class' implementation across the filescape, then</span></div>
<div style="position:absolute;left:72.00px;top:587.88px" class="cls_006"><span class="cls_006">be sure to note in the header where each method's implementation can be located, and be sure to explain</span></div>
<div style="position:absolute;left:72.00px;top:600.00px" class="cls_006"><span class="cls_006">why you did something so strange.</span></div>
<div style="position:absolute;left:72.00px;top:626.04px" class="cls_006"><span class="cls_006">Although code requires placement optimization only occasionally, managing data storage is a common</span></div>
<div style="position:absolute;left:72.00px;top:638.16px" class="cls_006"><span class="cls_006">necessity. Though the reuse of OO has tended to be overstated, class storage management is an area that</span></div>
<div style="position:absolute;left:72.00px;top:650.28px" class="cls_006"><span class="cls_006">acquits itself quite well in terms of mix-in class and template reuse. A vast selection of very sophisticated</span></div>
<div style="position:absolute;left:72.00px;top:662.28px" class="cls_006"><span class="cls_006">storage management algorithms can be reused easily. Some of these solutions leverage very good, general-</span></div>
<div style="position:absolute;left:72.00px;top:674.40px" class="cls_006"><span class="cls_006">purpose implementations of multithousand code line data management mechanisms. We need to think very</span></div>
<div style="position:absolute;left:72.00px;top:686.40px" class="cls_006"><span class="cls_006">hard about it before purposely choosing to write our own b+ tree when one is readily available via reuse.</span></div>
<div style="position:absolute;left:72.00px;top:712.56px" class="cls_006"><span class="cls_006">Unfortunately, the easy availability of sophisticated storage structures makes it all too easy to use the</span></div>
<div style="position:absolute;left:72.00px;top:724.56px" class="cls_006"><span class="cls_006">wrong one. It is always a good idea to understand the underlying concepts behind the structures you plan</span></div>
<div style="position:absolute;left:72.00px;top:736.68px" class="cls_006"><span class="cls_006">on using, or at least to have a reasonable idea of the computational efficiency of the storage structures you</span></div>
<div style="position:absolute;left:72.00px;top:748.68px" class="cls_006"><span class="cls_006">select. Fortunately, the use of user-defined classes, with their associated constructor/destructor</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">178</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:163584px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background193.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">specification mechanism, can make the fundamental storage mechanism for a given class' objects</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">transparent to the class' users. This can make transitioning from one storage management scheme to</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">another fairly painless. Our recommendation is to start simple and employ increasingly sophisticated</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">storage mechanisms as profiled performance metrics dictate.</span></div>
<div style="position:absolute;left:72.00px;top:133.68px" class="cls_006"><span class="cls_006">For example, we may start with a simple array, or an STL </span><span class="cls_020">vector</span><span class="cls_006"> as the storage mechanism for very</span></div>
<div style="position:absolute;left:72.00px;top:146.04px" class="cls_006"><span class="cls_006">large ordered lists. If profiling does not expose any flaws in this implementation, then we are done. If</span></div>
<div style="position:absolute;left:72.00px;top:158.52px" class="cls_006"><span class="cls_006">profiling indicates that we are spending too much time sorting or searching the array (</span><span class="cls_020">vector</span><span class="cls_006">), then we</span></div>
<div style="position:absolute;left:72.00px;top:170.88px" class="cls_006"><span class="cls_006">may choose to employ a hash table access mechanism. Or perhaps we could adopt a b* tree or an indexed</span></div>
<div style="position:absolute;left:72.00px;top:183.00px" class="cls_006"><span class="cls_006">key approach. The availability of these sophisticated management classes, with essentially identical</span></div>
<div style="position:absolute;left:72.00px;top:195.00px" class="cls_006"><span class="cls_006">interfaces, allows us to replace one management implementation with another easily. Adoption of</span></div>
<div style="position:absolute;left:72.00px;top:207.12px" class="cls_006"><span class="cls_006">increasingly sophisticated management code only when profiling indicates that we need it will allow us to</span></div>
<div style="position:absolute;left:72.00px;top:219.24px" class="cls_006"><span class="cls_006">use complexity when necessary and leave simplicity everywhere else. Remember, complexity is the enemy</span></div>
<div style="position:absolute;left:72.00px;top:231.24px" class="cls_006"><span class="cls_006">of correctness and maintainability. Employ the simplest solution that solves the problem. Parsimony says</span></div>
<div style="position:absolute;left:72.00px;top:243.36px" class="cls_006"><span class="cls_006">that the simplest working solution is the best—keep your software parsimonious.</span></div>
<div style="position:absolute;left:72.00px;top:269.40px" class="cls_006"><span class="cls_006">In all this talk about being careful we failed to note one of the most effective C++ hardware oriented</span></div>
<div style="position:absolute;left:72.00px;top:281.52px" class="cls_006"><span class="cls_006">optimizations: </span><span class="cls_007">Get more memory</span><span class="cls_006"> and </span><span class="cls_007">a faster processor!</span><span class="cls_006"> We sometimes find ourselves spinning our</span></div>
<div style="position:absolute;left:72.00px;top:293.52px" class="cls_006"><span class="cls_006">optimization wheels trying to extract another 10% performance gain, sometimes at great expense, and we</span></div>
<div style="position:absolute;left:72.00px;top:305.64px" class="cls_006"><span class="cls_006">fail to do the obvious: respecify the minimal acceptable hardware requirements for the software. Going</span></div>
<div style="position:absolute;left:72.00px;top:317.76px" class="cls_006"><span class="cls_006">from a 200MHz processor with 32 megabytes of RAM to a 500MHz processor with 256 megabytes of</span></div>
<div style="position:absolute;left:72.00px;top:329.76px" class="cls_006"><span class="cls_006">RAM can do more to improve code performance than a hundred memory placement optimization tweaks.</span></div>
<div style="position:absolute;left:72.00px;top:341.88px" class="cls_006"><span class="cls_006">Hardware is relatively inexpensive; do not be afraid to admit that you are solving a big problem and that</span></div>
<div style="position:absolute;left:72.00px;top:353.88px" class="cls_006"><span class="cls_006">big software solutions require access to big hardware platforms.</span></div>
<div style="position:absolute;left:72.00px;top:407.76px" class="cls_016"><span class="cls_016">Cache Effects</span></div>
<div style="position:absolute;left:72.00px;top:439.08px" class="cls_006"><span class="cls_006">A cache provides more than just fast access for previously accessed data; it also provides a small prefetch</span></div>
<div style="position:absolute;left:72.00px;top:451.08px" class="cls_006"><span class="cls_006">region around that previously accessed data. Caches fetch and manage lines of data. A typical cache line</span></div>
<div style="position:absolute;left:72.00px;top:463.20px" class="cls_006"><span class="cls_006">consists of 32 bytes of data aligned on a 32-byte boundary. Typically caches lack the capability to manage</span></div>
<div style="position:absolute;left:72.00px;top:475.32px" class="cls_006"><span class="cls_006">anything other than complete lines. This means that if an instruction accesses a single byte of data at</span></div>
<div style="position:absolute;left:72.00px;top:487.32px" class="cls_006"><span class="cls_006">address 100, then the cache will load bytes 96-127 into a line. The initial access to address 100 may well</span></div>
<div style="position:absolute;left:72.00px;top:499.44px" class="cls_006"><span class="cls_006">result in a cache miss and cause the processor to stall for dozens of cycles while the desired data is fetched</span></div>
<div style="position:absolute;left:72.00px;top:511.56px" class="cls_006"><span class="cls_006">from memory (or half a dozen cycles if it is fetched from another level of the cache), but subsequent</span></div>
<div style="position:absolute;left:72.00px;top:523.56px" class="cls_006"><span class="cls_006">accesses to bytes 101, 102, 103, … 127 will probably not fault, unless a significant time passes before the</span></div>
<div style="position:absolute;left:72.00px;top:535.68px" class="cls_006"><span class="cls_006">neighboring locations are accessed.</span></div>
<div style="position:absolute;left:72.00px;top:561.72px" class="cls_006"><span class="cls_006">This automatic cache blocking should be taken into consideration when building code. Consider the</span></div>
<div style="position:absolute;left:72.00px;top:574.32px" class="cls_006"><span class="cls_006">following two implementations of class </span><span class="cls_020">lla</span><span class="cls_006"> that encapsulate an array of linked lists into which </span><span class="cls_020">lla</span></div>
<div style="position:absolute;left:72.00px;top:586.56px" class="cls_006"><span class="cls_006">objects can be linked based on a priority argument. The first implementation uses two independent arrays</span></div>
<div style="position:absolute;left:72.00px;top:599.16px" class="cls_006"><span class="cls_006">of </span><span class="cls_020">first</span><span class="cls_006"> and </span><span class="cls_020">last</span><span class="cls_006"> pointers to maintain the priority list:</span></div>
<div style="position:absolute;left:72.00px;top:625.08px" class="cls_020"><span class="cls_020">class lla</span></div>
<div style="position:absolute;left:72.00px;top:636.48px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:72.00px;top:647.76px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:670.44px" class="cls_020"><span class="cls_020">void insert ();</span></div>
<div style="position:absolute;left:72.00px;top:693.12px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:715.80px" class="cls_020"><span class="cls_020">int priority;</span></div>
<div style="position:absolute;left:96.00px;top:727.08px" class="cls_020"><span class="cls_020">lla *next;</span></div>
<div style="position:absolute;left:96.00px;top:749.76px" class="cls_020"><span class="cls_020">static lla *first[1024];</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">179</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:164436px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background194.jpg" width=595 height=842></div>
<div style="position:absolute;left:96.00px;top:70.56px" class="cls_020"><span class="cls_020">static lla *last[1024];</span></div>
<div style="position:absolute;left:72.00px;top:81.84px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">void lla::insert ()</span></div>
<div style="position:absolute;left:72.00px;top:115.92px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:127.20px" class="cls_020"><span class="cls_020">if (first[priority]) last[priority]->next = this;</span></div>
<div style="position:absolute;left:96.00px;top:138.48px" class="cls_020"><span class="cls_020">else first[priority] = this;</span></div>
<div style="position:absolute;left:96.00px;top:149.88px" class="cls_020"><span class="cls_020">last[priority] = this;</span></div>
<div style="position:absolute;left:72.00px;top:161.16px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:187.44px" class="cls_006"><span class="cls_006">The second implementation uses a single array of </span><span class="cls_020">first</span><span class="cls_006">/ </span><span class="cls_020">last</span><span class="cls_006"> pairs:</span></div>
<div style="position:absolute;left:72.00px;top:213.36px" class="cls_020"><span class="cls_020">class lla {</span></div>
<div style="position:absolute;left:72.00px;top:224.64px" class="cls_020"><span class="cls_020">public:</span></div>
<div style="position:absolute;left:96.00px;top:247.32px" class="cls_020"><span class="cls_020">void insert ();</span></div>
<div style="position:absolute;left:72.00px;top:270.00px" class="cls_020"><span class="cls_020">private:</span></div>
<div style="position:absolute;left:96.00px;top:292.56px" class="cls_020"><span class="cls_020">int priority;</span></div>
<div style="position:absolute;left:96.00px;top:303.96px" class="cls_020"><span class="cls_020">lla *next;</span></div>
<div style="position:absolute;left:96.00px;top:326.64px" class="cls_020"><span class="cls_020">struct pairs {</span></div>
<div style="position:absolute;left:107.99px;top:337.92px" class="cls_020"><span class="cls_020">lla *first;</span></div>
<div style="position:absolute;left:107.99px;top:349.20px" class="cls_020"><span class="cls_020">lla *last;</span></div>
<div style="position:absolute;left:96.00px;top:360.60px" class="cls_020"><span class="cls_020">};</span></div>
<div style="position:absolute;left:96.00px;top:371.88px" class="cls_020"><span class="cls_020">static pairs ptrs[1024];</span></div>
<div style="position:absolute;left:72.00px;top:383.28px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:405.84px" class="cls_020"><span class="cls_020">void lla::insert ()</span></div>
<div style="position:absolute;left:72.00px;top:417.24px" class="cls_020"><span class="cls_020">{</span></div>
<div style="position:absolute;left:96.00px;top:428.52px" class="cls_020"><span class="cls_020">if (ptrs[priority].first) ptrs[priority].last->next = this;</span></div>
<div style="position:absolute;left:96.00px;top:439.92px" class="cls_020"><span class="cls_020">else ptrs[priority].first = this;</span></div>
<div style="position:absolute;left:96.00px;top:451.20px" class="cls_020"><span class="cls_020">ptrs[priority].last = this;</span></div>
<div style="position:absolute;left:72.00px;top:462.48px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:488.28px" class="cls_006"><span class="cls_006">The second implementation may seem somewhat less obvious in its operation, but consider the cache</span></div>
<div style="position:absolute;left:72.00px;top:500.76px" class="cls_006"><span class="cls_006">effects of the two implementations. In the first implementation, the test of </span><span class="cls_020">first[priority]</span><span class="cls_006"> will have</span></div>
<div style="position:absolute;left:72.00px;top:513.60px" class="cls_006"><span class="cls_006">no effect on the loading of </span><span class="cls_020">last[priority]</span><span class="cls_006">. A cache miss on the first access of </span><span class="cls_020">first[priority]</span></div>
<div style="position:absolute;left:72.00px;top:526.44px" class="cls_006"><span class="cls_006">will not affect the likelihood that </span><span class="cls_020">last[priority]</span><span class="cls_006"> will be present. In the second implementation, the</span></div>
<div style="position:absolute;left:72.00px;top:539.16px" class="cls_020"><span class="cls_020">first</span><span class="cls_006"> and </span><span class="cls_020">last</span><span class="cls_006"> </span><span class="cls_020">pairs</span><span class="cls_006"> are allocated in adjacent memory words. If the </span><span class="cls_020">pairs</span><span class="cls_006"> array is properly aligned</span></div>
<div style="position:absolute;left:72.00px;top:552.00px" class="cls_006"><span class="cls_006">in memory, then the initial access to a </span><span class="cls_020">first[priority]</span><span class="cls_006"> will guarantee that the associated</span></div>
<div style="position:absolute;left:72.00px;top:564.84px" class="cls_020"><span class="cls_020">last[priority]</span><span class="cls_006"> is present in the cache.</span></div>
<div style="position:absolute;left:72.00px;top:591.12px" class="cls_006"><span class="cls_006">The entreaty to keep related data together does not only manifest itself in the cache. It is also possible that</span></div>
<div style="position:absolute;left:72.00px;top:603.24px" class="cls_006"><span class="cls_006">the initial access could page fault. In this example, the first and last arrays in the first implementation are</span></div>
<div style="position:absolute;left:72.00px;top:615.72px" class="cls_006"><span class="cls_006">each reasonably large, and it would not necessarily be the case that a page fault on </span><span class="cls_020">first[priority]</span></div>
<div style="position:absolute;left:72.00px;top:628.56px" class="cls_006"><span class="cls_006">would also bring </span><span class="cls_020">last[priority]</span><span class="cls_006"> into memory. Although any significant level of structure usage</span></div>
<div style="position:absolute;left:72.00px;top:640.92px" class="cls_006"><span class="cls_006">would tend to keep both arrays in memory and insignificant levels of usage will tend to have little impact</span></div>
<div style="position:absolute;left:72.00px;top:652.92px" class="cls_006"><span class="cls_006">on performance, it is still best to do things right the first time.</span></div>
<div style="position:absolute;left:72.00px;top:706.80px" class="cls_016"><span class="cls_016">Cache Thrash</span></div>
<div style="position:absolute;left:72.00px;top:738.12px" class="cls_006"><span class="cls_006">One of the interesting effects of having a cache in a multiprocessor system is the effect of cache coherency</span></div>
<div style="position:absolute;left:72.00px;top:750.12px" class="cls_006"><span class="cls_006">protocols on cache performance. A cache coherency protocol is a mechanism employed by memory/cache</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">180</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:165288px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background195.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">controllers that maintains a coherent view of memory across a number of what would otherwise be</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">unassociated caches. The problem is simple: processor A wants to write to memory location 100 and</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">processor B wants to read from memory location 100. If B has previously read from location 100 and has a</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">copy of it in its cache then another read will not go out onto the system bus to refetch it. This is the</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">behavior you want if the processor is to go fast. However, if processor A has written a new value to</span></div>
<div style="position:absolute;left:72.00px;top:131.28px" class="cls_006"><span class="cls_006">location 100 between the time B read that location the first time and the time B read it for the second time,</span></div>
<div style="position:absolute;left:72.00px;top:143.40px" class="cls_006"><span class="cls_006">then without a coherency protocol, processor B will read the stale (old, incorrect) contents of location 100,</span></div>
<div style="position:absolute;left:72.00px;top:155.40px" class="cls_006"><span class="cls_006">not the fresh (new, correct) content.</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">Cache coherency protocols are based on notions of memory ownership and explicit invalidation of peer</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">cache entries on reads. This basically amounts to a protocol that allows multiple caches to share a copy of</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">a single data item, but only one cache to have write privileges for the data item at a time. If the owner (the</span></div>
<div style="position:absolute;left:72.00px;top:217.68px" class="cls_006"><span class="cls_006">one with write access) is not actively updating the data, then other caches can have their own copy of the</span></div>
<div style="position:absolute;left:72.00px;top:229.80px" class="cls_006"><span class="cls_006">cache line, but every time the owner of the cache line modifies the line, it tells all other caches to</span></div>
<div style="position:absolute;left:72.00px;top:241.92px" class="cls_006"><span class="cls_006">invalidate their copy. Invalidating the other copies will force the other caches to get another copy before</span></div>
<div style="position:absolute;left:72.00px;top:253.92px" class="cls_006"><span class="cls_006">they read it again. This will allow the owning cache to supply its peer caches with what is now the only</span></div>
<div style="position:absolute;left:72.00px;top:266.04px" class="cls_006"><span class="cls_006">correct value for the cache line. At some point the cache line will be flushed out to memory, maintaining</span></div>
<div style="position:absolute;left:72.00px;top:278.16px" class="cls_006"><span class="cls_006">the overall consistency of the memory system.</span></div>
<div style="position:absolute;left:72.00px;top:304.20px" class="cls_006"><span class="cls_006">Cache coherency protocols can require direct communication between caches. Significant amounts of such</span></div>
<div style="position:absolute;left:72.00px;top:316.20px" class="cls_006"><span class="cls_006">communication can slow system performance. This is because the path between the caches is a shared</span></div>
<div style="position:absolute;left:72.00px;top:328.32px" class="cls_006"><span class="cls_006">system resource. Such communication must be serialized between caches. This can force a cache to wait if</span></div>
<div style="position:absolute;left:72.00px;top:340.44px" class="cls_006"><span class="cls_006">the memory bus is already busy with another cache transaction. This waiting for cache update access is</span></div>
<div style="position:absolute;left:72.00px;top:352.44px" class="cls_006"><span class="cls_006">referred to as </span><span class="cls_034">cache thrash</span><span class="cls_006">. Cache thrash is typically the result of multiprocessor systems that do not</span></div>
<div style="position:absolute;left:72.00px;top:364.56px" class="cls_006"><span class="cls_006">maintain any processor affinity for its processes. Processor affinity amounts to keeping track of which</span></div>
<div style="position:absolute;left:72.00px;top:376.68px" class="cls_006"><span class="cls_006">processor a process ran on last time it executed, and trying to increase the likelihood that it will execute on</span></div>
<div style="position:absolute;left:72.00px;top:388.68px" class="cls_006"><span class="cls_006">that same processor the next time it executes.</span></div>
<div style="position:absolute;left:72.00px;top:414.72px" class="cls_006"><span class="cls_006">Consider the effect of an affinity free process queue on a 2-way SMP system. The likelihood that a process</span></div>
<div style="position:absolute;left:72.00px;top:426.84px" class="cls_006"><span class="cls_006">will execute on the same processor it ran on previously is 50%. If a process is swapped out 10 times</span></div>
<div style="position:absolute;left:72.00px;top:438.96px" class="cls_006"><span class="cls_006">between invocation and termination, the likelihood that it will run on the same processor the entire time is</span></div>
<div style="position:absolute;left:72.00px;top:450.96px" class="cls_006"><span class="cls_006">one in one thousand. With increased processor scaling, the cache effect becomes worse. A 16-way SMP</span></div>
<div style="position:absolute;left:72.00px;top:463.08px" class="cls_006"><span class="cls_006">system only has a 1 in 16 chance of continuing a process on the same processor and a one in a trillion</span></div>
<div style="position:absolute;left:72.00px;top:475.08px" class="cls_006"><span class="cls_006">chance of executing on the same processor across 10 context switches.</span></div>
<div style="position:absolute;left:72.00px;top:501.24px" class="cls_006"><span class="cls_006">As already discussed, maintaining a process' working set in a cache is the key to good performance, and</span></div>
<div style="position:absolute;left:72.00px;top:513.24px" class="cls_006"><span class="cls_006">cache misses idle the processor for dozens of cycles. Cache thrash is an antiscaling artifact that must be</span></div>
<div style="position:absolute;left:72.00px;top:525.36px" class="cls_006"><span class="cls_006">dealt with to obtain high performance in large-scale SMP systems. Some SMP systems are starting to</span></div>
<div style="position:absolute;left:72.00px;top:537.48px" class="cls_006"><span class="cls_006">provide affinity mechanisms for processor assignment. Though this is perhaps a very advanced hardware</span></div>
<div style="position:absolute;left:72.00px;top:549.48px" class="cls_006"><span class="cls_006">concept, it is also one that must be addressed for high performance software on multiprocessor systems.</span></div>
<div style="position:absolute;left:72.00px;top:561.60px" class="cls_006"><span class="cls_006">This is not a C++ issue. It is purely an operating system issue. There is some disagreement about its</span></div>
<div style="position:absolute;left:72.00px;top:573.60px" class="cls_006"><span class="cls_006">importance, but we believe that when the dust settles, maintaining processor affinity for some high priority</span></div>
<div style="position:absolute;left:72.00px;top:585.72px" class="cls_006"><span class="cls_006">threads will have significant performance advantages, particularly on the next generation of multithreaded</span></div>
<div style="position:absolute;left:72.00px;top:597.84px" class="cls_006"><span class="cls_006">processors. If processor affinity characteristics ever filter down into the multithreading or multiprocessing</span></div>
<div style="position:absolute;left:72.00px;top:609.84px" class="cls_006"><span class="cls_006">programming interfaces, it is important to understand the implications of the capability the API is making</span></div>
<div style="position:absolute;left:72.00px;top:621.96px" class="cls_006"><span class="cls_006">available.</span></div>
<div style="position:absolute;left:72.00px;top:675.72px" class="cls_016"><span class="cls_016">Avoid Branching</span></div>
<div style="position:absolute;left:72.00px;top:707.04px" class="cls_006"><span class="cls_006">Modern processors tend not to be particularly branch friendly. In the "good old days" one processor</span></div>
<div style="position:absolute;left:72.00px;top:719.16px" class="cls_006"><span class="cls_006">instruction would finish before the next instruction was issued. This meant that if one instruction</span></div>
<div style="position:absolute;left:72.00px;top:731.28px" class="cls_006"><span class="cls_006">calculated the target for a branch or set a condition code on which a branch decision was dependent, the</span></div>
<div style="position:absolute;left:72.00px;top:743.28px" class="cls_006"><span class="cls_006">result of this instruction was available for immediate use by the next instruction. This made for a simple</span></div>
<div style="position:absolute;left:72.00px;top:755.40px" class="cls_006"><span class="cls_006">processor architecture, though generally not a particularly fast one.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">181</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:166140px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background196.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">Almost all modern processors are now pipelined. A pipelined processor breaks up instruction execution</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">into a number of stages. A simple pipeline might have five stages: instruction fetch, instruction decode,</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">operand fetch, operation execution, and result store. This five-stage pipe would, in general, mean that</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">while one instruction was storing its result into a register, the next instruction would be using the ALU to</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">calculate something, and the instruction after that would be fetching its operands from the registers, and</span></div>
<div style="position:absolute;left:72.00px;top:131.28px" class="cls_006"><span class="cls_006">the instruction after that one would be decoded, and still the next instruction would be fetched. During any</span></div>
<div style="position:absolute;left:72.00px;top:143.40px" class="cls_006"><span class="cls_006">given clock cycle the processor is engaged in five concurrent activities (the execution of five sequential</span></div>
<div style="position:absolute;left:72.00px;top:155.40px" class="cls_006"><span class="cls_006">instructions).</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">Pipelining makes for fast processing; ideally one instruction could finish per cycle, and the basic clock</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">cycle for the processor could possibly be decreased by a factor of five relative to its nonpipelined</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">predecessors (overly simplistic analysis, but hopefully you get the idea). This substantially improves</span></div>
<div style="position:absolute;left:72.00px;top:217.68px" class="cls_006"><span class="cls_006">performance when the pipeline can be kept filled. Unfortunately branches, particularly conditional</span></div>
<div style="position:absolute;left:72.00px;top:229.80px" class="cls_006"><span class="cls_006">branches, tend to stall the pipeline. A pipeline stall occurs when an instruction is prevented from entering</span></div>
<div style="position:absolute;left:72.00px;top:241.92px" class="cls_006"><span class="cls_006">the pipeline because its entry is contingent on an as yet unknown value. For example, suppose you had the</span></div>
<div style="position:absolute;left:72.00px;top:253.92px" class="cls_006"><span class="cls_006">following two assembly level statements:</span></div>
<div style="position:absolute;left:72.00px;top:279.72px" class="cls_020"><span class="cls_020">CMP  r1,  r2 // compare r1 to r2 and set the condition codes</span></div>
<div style="position:absolute;left:72.00px;top:291.00px" class="cls_020"><span class="cls_020">BLT  x</span></div>
<div style="position:absolute;left:149.99px;top:291.00px" class="cls_020"><span class="cls_020">// branch if the condition codes indicate that the</span></div>
<div style="position:absolute;left:149.99px;top:302.28px" class="cls_020"><span class="cls_020">// result was less than zero.</span></div>
<div style="position:absolute;left:72.00px;top:328.08px" class="cls_006"><span class="cls_006">The compare instruction might enter the pipeline during clock cycle 100, and the branch instruction would</span></div>
<div style="position:absolute;left:72.00px;top:340.08px" class="cls_006"><span class="cls_006">then enter at clock cycle 101. At clock cycle 102 we would ideally start loading the next instruction, but</span></div>
<div style="position:absolute;left:72.00px;top:352.20px" class="cls_006"><span class="cls_006">the condition in the branch requires that the compare instruction complete its subtraction and set the</span></div>
<div style="position:absolute;left:72.00px;top:364.20px" class="cls_006"><span class="cls_006">condition codes, which does not complete until cycle 104. This results in a two-cycle stall while we wait to</span></div>
<div style="position:absolute;left:72.00px;top:376.32px" class="cls_006"><span class="cls_006">decide whether we will branch or not. These two lost cycles could have been used to do some useful work</span></div>
<div style="position:absolute;left:72.00px;top:388.44px" class="cls_006"><span class="cls_006">if we had not branched.</span></div>
<div style="position:absolute;left:72.00px;top:414.48px" class="cls_006"><span class="cls_006">Although this discussion of pipelining is admittedly overly simplistic, it does get at the core of the branch</span></div>
<div style="position:absolute;left:72.00px;top:426.48px" class="cls_006"><span class="cls_006">problem in pipelined processors. Sophisticated processors use branch prediction, out of order execution,</span></div>
<div style="position:absolute;left:72.00px;top:438.60px" class="cls_006"><span class="cls_006">and/or branch delay slots to decrease the cost of branching. Conversely, such processors also tend to have</span></div>
<div style="position:absolute;left:72.00px;top:450.72px" class="cls_006"><span class="cls_006">deeper pipelines (more stages between operation completion and instruction fetch), and short of a</span></div>
<div style="position:absolute;left:72.00px;top:462.72px" class="cls_006"><span class="cls_006">multithreaded processor approach (that sacrifices latency for bandwidth and is still a very new technology),</span></div>
<div style="position:absolute;left:72.00px;top:474.84px" class="cls_006"><span class="cls_006">small branching will remain an uncomfortable expense.</span></div>
<div style="position:absolute;left:72.00px;top:500.88px" class="cls_006"><span class="cls_006">One place where branching seems to be much in evidence is argument sanity checking. We have seen</span></div>
<div style="position:absolute;left:72.00px;top:513.00px" class="cls_006"><span class="cls_006">numerous instances of functions that are 90% argument checking and 10% calculation. Unfortunately most</span></div>
<div style="position:absolute;left:72.00px;top:525.00px" class="cls_006"><span class="cls_006">of this argument checking is conditional testing. Given that conditional testing has negative performance</span></div>
<div style="position:absolute;left:72.00px;top:537.12px" class="cls_006"><span class="cls_006">repercussions, it is best to try to keep overly defensive programming out of the critical code path. We have</span></div>
<div style="position:absolute;left:72.00px;top:549.24px" class="cls_006"><span class="cls_006">seen numerous instances in which a value is passed down through three or four levels of function calls and</span></div>
<div style="position:absolute;left:72.00px;top:561.24px" class="cls_006"><span class="cls_006">the same range check is applied to it at every level. This repetitive application of conditional branching</span></div>
<div style="position:absolute;left:72.00px;top:573.36px" class="cls_006"><span class="cls_006">gobbles cycles without a commensurate benefit.</span></div>
<div style="position:absolute;left:72.00px;top:599.40px" class="cls_006"><span class="cls_006">The fastest code is straight line code: no conditional tests, no loops, no calls, no returns. In general, the</span></div>
<div style="position:absolute;left:72.00px;top:611.52px" class="cls_006"><span class="cls_006">more the critical path of a program looks like a straight line, the faster it will execute. Remember: Short</span></div>
<div style="position:absolute;left:72.00px;top:623.52px" class="cls_006"><span class="cls_006">code sequences with lots of branches will frequently take longer to execute than longer code sequences</span></div>
<div style="position:absolute;left:72.00px;top:635.64px" class="cls_006"><span class="cls_006">with no branches.</span></div>
<div style="position:absolute;left:72.00px;top:689.40px" class="cls_016"><span class="cls_016">Prefer Simple Calculations to Small Branches</span></div>
<div style="position:absolute;left:72.00px;top:720.72px" class="cls_006"><span class="cls_006">As previously discussed, branching can be expensive in performance terms. Frequently, branching cannot</span></div>
<div style="position:absolute;left:72.00px;top:732.84px" class="cls_006"><span class="cls_006">be avoided, but sometimes branching is used in place of calculation. This can be a critical performance</span></div>
<div style="position:absolute;left:72.00px;top:744.96px" class="cls_006"><span class="cls_006">mistake. Take, for example, the following code sequence:</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">182</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:166992px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background197.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.56px" class="cls_020"><span class="cls_020">const int X_MAX = 16;</span></div>
<div style="position:absolute;left:72.00px;top:93.24px" class="cls_020"><span class="cls_020">++x;</span></div>
<div style="position:absolute;left:72.00px;top:104.52px" class="cls_020"><span class="cls_020">if (x >= X_MAX) {</span></div>
<div style="position:absolute;left:96.00px;top:115.92px" class="cls_020"><span class="cls_020">x = 0;</span></div>
<div style="position:absolute;left:72.00px;top:127.20px" class="cls_020"><span class="cls_020">}</span></div>
<div style="position:absolute;left:72.00px;top:152.76px" class="cls_006"><span class="cls_006">It is really just a bit mask operation and can just as easily be done with the following code sequence:</span></div>
<div style="position:absolute;left:72.00px;top:178.56px" class="cls_020"><span class="cls_020">const int X_MASK = 15;</span></div>
<div style="position:absolute;left:72.00px;top:201.24px" class="cls_020"><span class="cls_020">x = (x + 1) & X_MASK;</span></div>
<div style="position:absolute;left:72.00px;top:227.04px" class="cls_006"><span class="cls_006">In the first case there is a load, an increment, a store, a conditional test, and another store. Even on a</span></div>
<div style="position:absolute;left:72.00px;top:239.04px" class="cls_006"><span class="cls_006">machine with a short pipeline, the conditional test will cost at least three cycles, and thus the effective cost</span></div>
<div style="position:absolute;left:72.00px;top:251.04px" class="cls_006"><span class="cls_006">of the conditional solution is roughly the same as executing seven machine code instructions. The</span></div>
<div style="position:absolute;left:72.00px;top:263.16px" class="cls_006"><span class="cls_006">unconditional version has a load, an increment, possibly one or two instruction mask creation sequences</span></div>
<div style="position:absolute;left:72.00px;top:275.28px" class="cls_006"><span class="cls_006">(something to get the value 15 into a register or immediate field), a bit-wise AND operation, and a store. In</span></div>
<div style="position:absolute;left:72.00px;top:287.28px" class="cls_006"><span class="cls_006">the worst case this is six instructions, in the general case this is only four instructions; almost twice as fast</span></div>
<div style="position:absolute;left:72.00px;top:299.40px" class="cls_006"><span class="cls_006">as the conditional version. On a deeply pipelined machine the calculated version will be proportionally</span></div>
<div style="position:absolute;left:72.00px;top:311.52px" class="cls_006"><span class="cls_006">faster.</span></div>
<div style="position:absolute;left:72.00px;top:337.56px" class="cls_006"><span class="cls_006">Notice that these code sequences are essentially equivalent, but not exactly so. The first solution is more</span></div>
<div style="position:absolute;left:72.00px;top:350.04px" class="cls_006"><span class="cls_006">flexible than the second one. There is no power-of-two alignment requirement for </span><span class="cls_020">X_MAX</span><span class="cls_006">, but there is one</span></div>
<div style="position:absolute;left:72.00px;top:362.88px" class="cls_006"><span class="cls_006">for </span><span class="cls_020">X_MASK</span><span class="cls_006">. Thus, for the values in the example they provide the same function, although the faster</span></div>
<div style="position:absolute;left:72.00px;top:375.24px" class="cls_006"><span class="cls_006">solution is more restrictive than the first. In general, if performance is of primary importance, we should</span></div>
<div style="position:absolute;left:72.00px;top:387.24px" class="cls_006"><span class="cls_006">expect to trade some flexibility for fast calculations that avoid the necessity to branch.</span></div>
<div style="position:absolute;left:72.00px;top:441.12px" class="cls_016"><span class="cls_016">Threading Effects</span></div>
<div style="position:absolute;left:72.00px;top:472.44px" class="cls_006"><span class="cls_006">Multiprocessing and multithreading are two closely related, but different, types of concurrent</span></div>
<div style="position:absolute;left:72.00px;top:484.44px" class="cls_006"><span class="cls_006">programming. Although both concepts exist in a larger context, we will limit our discussion to their impact</span></div>
<div style="position:absolute;left:72.00px;top:496.56px" class="cls_006"><span class="cls_006">on the creation of a monolithic software system, not on the interaction of multiple essentially independent</span></div>
<div style="position:absolute;left:72.00px;top:508.68px" class="cls_006"><span class="cls_006">software systems within an operating system environment.</span></div>
<div style="position:absolute;left:72.00px;top:534.72px" class="cls_006"><span class="cls_006">Multiprocessing is an old concept. Multiprocessing allows multiple, largely independent processes to</span></div>
<div style="position:absolute;left:72.00px;top:546.84px" class="cls_006"><span class="cls_006">communicate with each other. Processes used to be the schedulable entities that existed in an operating</span></div>
<div style="position:absolute;left:72.00px;top:558.84px" class="cls_006"><span class="cls_006">system. Historically, multiprocessing was the only mechanism available to system designers who wanted</span></div>
<div style="position:absolute;left:72.00px;top:570.96px" class="cls_006"><span class="cls_006">to be able to perform multiple, pseudoconcurrent, asynchronous activities. InterProcess Communication</span></div>
<div style="position:absolute;left:72.00px;top:583.44px" class="cls_006"><span class="cls_006">(IPC), typically a socket library, was used to facilitate communication between processes. </span><span class="cls_020">fork()</span><span class="cls_006"> and</span></div>
<div style="position:absolute;left:72.00px;top:596.28px" class="cls_020"><span class="cls_020">exec()</span><span class="cls_006"> were used to create new processes and process termination was used to join processes. Processes</span></div>
<div style="position:absolute;left:72.00px;top:608.64px" class="cls_006"><span class="cls_006">cooperated via socket calls, pipes, shared memory, and semaphores. None of these were particularly easy</span></div>
<div style="position:absolute;left:72.00px;top:620.64px" class="cls_006"><span class="cls_006">to use, and each was very operating system specific.</span></div>
<div style="position:absolute;left:72.00px;top:646.80px" class="cls_006"><span class="cls_006">Multithreading is a more recent concept. Threads are subprocesses. They are pieces of a larger process, but</span></div>
<div style="position:absolute;left:72.00px;top:658.80px" class="cls_006"><span class="cls_006">they are also independently schedulable. Threading, in perhaps overly simplistic terms, is just</span></div>
<div style="position:absolute;left:72.00px;top:670.92px" class="cls_006"><span class="cls_006">multiprocessing, in which a group of lightweight processes can all access a shared memory region. Each</span></div>
<div style="position:absolute;left:72.00px;top:683.04px" class="cls_006"><span class="cls_006">lightweight process in the group of processes that share a memory region would be a thread, and the group</span></div>
<div style="position:absolute;left:72.00px;top:695.04px" class="cls_006"><span class="cls_006">as a whole would be referred to as a process or task. Threads are the schedulable entities within a task.</span></div>
<div style="position:absolute;left:72.00px;top:707.16px" class="cls_006"><span class="cls_006">Most operating systems treat threads as their only schedulable entity; that is, a task cannot be scheduled,</span></div>
<div style="position:absolute;left:72.00px;top:719.16px" class="cls_006"><span class="cls_006">only the threads within the task can be scheduled. Most threading systems treat tasks as memory</span></div>
<div style="position:absolute;left:72.00px;top:731.28px" class="cls_006"><span class="cls_006">management structures and threads as scheduling structures. A much more involved discussion of task</span></div>
<div style="position:absolute;left:72.00px;top:743.40px" class="cls_006"><span class="cls_006">scheduling can be found in almost any operating systems text.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">183</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:167844px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background198.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">Any discussion of multitasking from an application's viewpoint will need to include a discussion of</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">blocking. There are typically two different flavors of most I/O requests: blocking and nonblocking, or</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">synchronous and asynchronous. Synchronous I/O waits for the requested I/O to complete before it allows</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">its processing context to continue; that is, it blocks, waiting for its I/O request to be fully satisfied.</span></div>
<div style="position:absolute;left:72.00px;top:119.16px" class="cls_006"><span class="cls_006">Asynchronous I/O performs as much of the requested I/O transaction as is immediately satisfiable, and</span></div>
<div style="position:absolute;left:72.00px;top:131.28px" class="cls_006"><span class="cls_006">returns to its processing context the amount of progress it has made, but it does not block no matter how</span></div>
<div style="position:absolute;left:72.00px;top:143.40px" class="cls_006"><span class="cls_006">little of the requested transaction was completed. Typically, there is also an intermediate I/O request</span></div>
<div style="position:absolute;left:72.00px;top:155.40px" class="cls_006"><span class="cls_006">capability, one that acts synchronously for a specific amount of time and them becomes asynchronous.</span></div>
<div style="position:absolute;left:72.00px;top:167.52px" class="cls_006"><span class="cls_006">Although this middle ground between synchronous and asynchronous operation provides interesting</span></div>
<div style="position:absolute;left:72.00px;top:179.64px" class="cls_006"><span class="cls_006">operational capabilities to tasks, from a performance viewpoint it is essentially synchronous in its</span></div>
<div style="position:absolute;left:72.00px;top:191.64px" class="cls_006"><span class="cls_006">operation.</span></div>
<div style="position:absolute;left:72.00px;top:217.68px" class="cls_006"><span class="cls_006">A thread blocks when it synchronously requests a resource or some data that is unavailable. The requesting</span></div>
<div style="position:absolute;left:72.00px;top:229.80px" class="cls_006"><span class="cls_006">thread must then wait for the system to satisfy the request, which typically requires the completion of an</span></div>
<div style="position:absolute;left:72.00px;top:241.92px" class="cls_006"><span class="cls_006">I/O operation. While a thread is waiting for the completion of its associated I/O operation it is swapped out</span></div>
<div style="position:absolute;left:72.00px;top:253.92px" class="cls_006"><span class="cls_006">of the processor, and other threads that are not blocked are allowed to run. After the requested I/O</span></div>
<div style="position:absolute;left:72.00px;top:266.04px" class="cls_006"><span class="cls_006">completes, the thread once again becomes schedulable and it will eventually be swapped back into the</span></div>
<div style="position:absolute;left:72.00px;top:278.16px" class="cls_006"><span class="cls_006">processor. A blocked, very high priority thread will typically resume processing as soon as its I/O request</span></div>
<div style="position:absolute;left:72.00px;top:290.16px" class="cls_006"><span class="cls_006">completes.</span></div>
<div style="position:absolute;left:72.00px;top:316.20px" class="cls_006"><span class="cls_006">A typical program is synchronously single threaded, and as such, it can only do one thing at a time. Any</span></div>
<div style="position:absolute;left:72.00px;top:328.32px" class="cls_006"><span class="cls_006">time a request is made that cannot be fulfilled immediately, the entire program becomes blocked waiting</span></div>
<div style="position:absolute;left:72.00px;top:340.44px" class="cls_006"><span class="cls_006">for the operating system to complete the request. Conversely, some sophisticated programs are written</span></div>
<div style="position:absolute;left:72.00px;top:352.44px" class="cls_006"><span class="cls_006">with multiple logically concurrent physical or logical processing streams. This allows multiple, relatively</span></div>
<div style="position:absolute;left:72.00px;top:364.56px" class="cls_006"><span class="cls_006">independent aspects of a program to execute without regard to whether one of them may, at some</span></div>
<div style="position:absolute;left:72.00px;top:376.68px" class="cls_006"><span class="cls_006">particular time, be unable to completely satisfy an I/O request. For example, a multithreaded program that</span></div>
<div style="position:absolute;left:72.00px;top:388.68px" class="cls_006"><span class="cls_006">contains ten threads could still make forward progress even if nine of its ten threads were blocked. A</span></div>
<div style="position:absolute;left:72.00px;top:400.80px" class="cls_006"><span class="cls_006">program that relied on asynchronous I/O could continue to execute even if an I/O request did not return all</span></div>
<div style="position:absolute;left:72.00px;top:412.80px" class="cls_006"><span class="cls_006">the desired data. Writing software that supports the concept of concurrent execution, though more</span></div>
<div style="position:absolute;left:72.00px;top:424.92px" class="cls_006"><span class="cls_006">complicated, can provide much better performance, particularly in terms of its latency characteristics, than</span></div>
<div style="position:absolute;left:72.00px;top:437.04px" class="cls_006"><span class="cls_006">simple synchronous single-threaded solutions. This performance advantage of multithreading becomes</span></div>
<div style="position:absolute;left:72.00px;top:449.04px" class="cls_006"><span class="cls_006">even more pronounced on multiprocessor systems that can really perform multiple operations in parallel.</span></div>
<div style="position:absolute;left:72.00px;top:475.08px" class="cls_006"><span class="cls_006">Multithreading is a very valuable capability, and on the right systems it can yield tremendous performance</span></div>
<div style="position:absolute;left:72.00px;top:487.20px" class="cls_006"><span class="cls_006">advantages, but misapplication of the threading concept can cause significant performance problems.</span></div>
<div style="position:absolute;left:72.00px;top:499.32px" class="cls_006"><span class="cls_006">Multithreading implies context switches and context switches can consume thousands of processing cycles.</span></div>
<div style="position:absolute;left:72.00px;top:511.32px" class="cls_006"><span class="cls_006">Multithreading also frequently requires locks around shared memory regions. Locks can also consume a</span></div>
<div style="position:absolute;left:72.00px;top:523.44px" class="cls_006"><span class="cls_006">significant number of processing cycles without making any progress towards program completion.</span></div>
<div style="position:absolute;left:72.00px;top:535.56px" class="cls_006"><span class="cls_006">Although multithreading is now relatively easy to do, we have found that it seems to be hard to do right.</span></div>
<div style="position:absolute;left:72.00px;top:547.56px" class="cls_006"><span class="cls_006">Far too often programs are broken up into threads that lack the necessary level of independence from each</span></div>
<div style="position:absolute;left:72.00px;top:559.68px" class="cls_006"><span class="cls_006">other to make threading effective. We have seen numerous examples of threaded programs that had so</span></div>
<div style="position:absolute;left:72.00px;top:571.68px" class="cls_006"><span class="cls_006">many locks and serialization semaphores that the net result was serialized thread execution (more than one</span></div>
<div style="position:absolute;left:72.00px;top:583.80px" class="cls_006"><span class="cls_006">simultaneously runable threads was the exception rather than the rule). When the overhead of context</span></div>
<div style="position:absolute;left:72.00px;top:595.92px" class="cls_006"><span class="cls_006">switching was added into the mix, some of these programs ran faster as asynchronously polled monolithic</span></div>
<div style="position:absolute;left:72.00px;top:607.92px" class="cls_006"><span class="cls_006">programs, than as synchronous multithreaded programs. One of the keys to understanding the cost</span></div>
<div style="position:absolute;left:72.00px;top:620.04px" class="cls_006"><span class="cls_006">equation for multithreading is to understand the performance impact of context switching.</span></div>
<div style="position:absolute;left:72.00px;top:673.80px" class="cls_016"><span class="cls_016">Context Switching</span></div>
<div style="position:absolute;left:72.00px;top:705.12px" class="cls_006"><span class="cls_006">What is a context switch and why is it so expensive? A context switch is moving one process (thread) out</span></div>
<div style="position:absolute;left:72.00px;top:717.24px" class="cls_006"><span class="cls_006">of a processor and another process into the processor. This involves saving the process' and the processor's</span></div>
<div style="position:absolute;left:72.00px;top:729.24px" class="cls_006"><span class="cls_006">state. The process' state needs to be saved so that an accurate record of the process' execution point is</span></div>
<div style="position:absolute;left:72.00px;top:741.36px" class="cls_006"><span class="cls_006">maintained. The processor's state needs to be saved so that the processor can be put back into that state</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">184</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:168696px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background199.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">when the associated process continues its execution. Processor state is a component of a process' state, but</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">not the whole story.</span></div>
<div style="position:absolute;left:72.00px;top:109.08px" class="cls_006"><span class="cls_006">A process context is an operating system construct, and as such is very OS dependent. It is managed by a</span></div>
<div style="position:absolute;left:72.00px;top:121.20px" class="cls_006"><span class="cls_006">structure in the OS that contains the relevant aspects of a process' state, such as allocated memory range,</span></div>
<div style="position:absolute;left:72.00px;top:133.20px" class="cls_006"><span class="cls_006">page map table, open file pointers, child processes, processor state variables (registers, program counter,</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_006"><span class="cls_006">possibly translation-lookaside buffer (TLB)), and process state variables like priority, owner, invocation</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">time, and current state (runable, blocked, running). The bulk of a process' state is located in memory and is</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">accessed only occasionally, but the processor state portion of a process context is used constantly by the</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">processor and must be resident in the processor for a process to execute. The process-dependent portion of</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">a processor's state must migrate from the processor to memory every time a process is swapped out, and it</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">must be loaded back into the processor every time a process is swapped back in.</span></div>
<div style="position:absolute;left:72.00px;top:231.72px" class="cls_006"><span class="cls_006">There are three primary cost aspects to a context switch: processor context migration, cache and TLB loss,</span></div>
<div style="position:absolute;left:72.00px;top:243.84px" class="cls_006"><span class="cls_006">and scheduler overhead. Let us address each in order. A processor context is the portion of a processor's</span></div>
<div style="position:absolute;left:72.00px;top:255.84px" class="cls_006"><span class="cls_006">state that is specific to a process. This typically includes the entire register set, including the program</span></div>
<div style="position:absolute;left:72.00px;top:267.96px" class="cls_006"><span class="cls_006">counter and stack pointer when they are not included in the register set proper; any conditional status flags,</span></div>
<div style="position:absolute;left:72.00px;top:280.08px" class="cls_006"><span class="cls_006">typically included in a processor status word or two; page table pointers, valid address range indices; and</span></div>
<div style="position:absolute;left:72.00px;top:292.08px" class="cls_006"><span class="cls_006">possibly a portion of the TLB, a structure that caches page table entries. Page tables are used to manage the</span></div>
<div style="position:absolute;left:72.00px;top:304.20px" class="cls_006"><span class="cls_006">individual pages that make up a process' linear virtual address space. Saving a process' state typically</span></div>
<div style="position:absolute;left:72.00px;top:316.20px" class="cls_006"><span class="cls_006">requires the writing to memory of between 20 and 50 words of data. This is the explicit cost of a context</span></div>
<div style="position:absolute;left:72.00px;top:328.32px" class="cls_006"><span class="cls_006">switch, and in some cases its least expensive aspect, with a cost of sometimes as little as 100 cycles,</span></div>
<div style="position:absolute;left:72.00px;top:340.44px" class="cls_006"><span class="cls_006">though it should be remembered that it is at least 100 cycles to save one context and then at least another</span></div>
<div style="position:absolute;left:72.00px;top:352.44px" class="cls_006"><span class="cls_006">100 to load another. Machines with more registers and/or more processor resident process contexts would</span></div>
<div style="position:absolute;left:72.00px;top:364.56px" class="cls_006"><span class="cls_006">see proportionally more context switch overhead.</span></div>
<div style="position:absolute;left:72.00px;top:390.60px" class="cls_006"><span class="cls_006">The interaction between context switches and caches often has the most pernicious impact on a program's</span></div>
<div style="position:absolute;left:72.00px;top:402.72px" class="cls_006"><span class="cls_006">performance. The structure and type of cache will have a significant impact on this characteristic of system</span></div>
<div style="position:absolute;left:72.00px;top:414.72px" class="cls_006"><span class="cls_006">performance. Caches can be partitioned into two classes based on the type of address with which they are</span></div>
<div style="position:absolute;left:72.00px;top:426.84px" class="cls_006"><span class="cls_006">accessed. Virtually addressed caches are accessed with addresses from the process' virtual address space.</span></div>
<div style="position:absolute;left:72.00px;top:438.96px" class="cls_006"><span class="cls_006">Virtual addresses are not process specific. That is, every process in a system may be using virtual address</span></div>
<div style="position:absolute;left:72.00px;top:450.96px" class="cls_006"><span class="cls_006">100, but the physical resolution of virtual address 100 will be possibly hundreds of different physical</span></div>
<div style="position:absolute;left:72.00px;top:463.08px" class="cls_006"><span class="cls_006">addresses. A cache that relied purely on virtual addresses would need to be flushed/invalidated on each</span></div>
<div style="position:absolute;left:72.00px;top:475.08px" class="cls_006"><span class="cls_006">context switch. This would mean that after every context switch, a process would need to rebuild its cache</span></div>
<div style="position:absolute;left:72.00px;top:487.20px" class="cls_006"><span class="cls_006">content.</span></div>
<div style="position:absolute;left:72.00px;top:513.24px" class="cls_006"><span class="cls_006">Suppose a process' working set is made up of 200 cache lines. This would mean that rebuilding the</span></div>
<div style="position:absolute;left:72.00px;top:525.36px" class="cls_006"><span class="cls_006">working set from scratch after a context switch would entail 200 cache misses. At a dozen cycles per miss,</span></div>
<div style="position:absolute;left:72.00px;top:537.48px" class="cls_006"><span class="cls_006">this is 1,200 cycles of additional context switch overhead. This is perhaps one of the reasons that there are</span></div>
<div style="position:absolute;left:72.00px;top:549.48px" class="cls_006"><span class="cls_006">very few systems that rely on virtually addressed caches. There are mechanisms that can decrease these</span></div>
<div style="position:absolute;left:72.00px;top:561.60px" class="cls_006"><span class="cls_006">types of cache effects. For example, a process identification field can be added to the cache line's address</span></div>
<div style="position:absolute;left:72.00px;top:573.60px" class="cls_006"><span class="cls_006">tag. This would allow multiple instances of the same virtual address to exist in the cache (each would have</span></div>
<div style="position:absolute;left:72.00px;top:585.72px" class="cls_006"><span class="cls_006">a different process ID), and it would remove the necessity of flushing the cache on a context switch. This</span></div>
<div style="position:absolute;left:72.00px;top:597.84px" class="cls_006"><span class="cls_006">would allow a cache to handle multiple processes efficiently, and cold cache start (using a logically empty</span></div>
<div style="position:absolute;left:72.00px;top:609.84px" class="cls_006"><span class="cls_006">cache) penalties would be decreased.</span></div>
<div style="position:absolute;left:72.00px;top:636.00px" class="cls_006"><span class="cls_006">The other type of cache, physically addressed caches, are essentially the same as virtual caches with ID</span></div>
<div style="position:absolute;left:72.00px;top:648.00px" class="cls_006"><span class="cls_006">tags. The difference is that instead of relying on the ID/address pair in the tag, they force the system to</span></div>
<div style="position:absolute;left:72.00px;top:660.12px" class="cls_006"><span class="cls_006">translate virtual addresses into physical addresses before they are submitted to the cache. The reality is that</span></div>
<div style="position:absolute;left:72.00px;top:672.12px" class="cls_006"><span class="cls_006">because of the mechanism used for page mapping, the bottom 9-14 bits of the address can be sent</span></div>
<div style="position:absolute;left:72.00px;top:684.24px" class="cls_006"><span class="cls_006">immediately and only the remaining upper bits of an address actually require translation. This turns out to</span></div>
<div style="position:absolute;left:72.00px;top:696.36px" class="cls_006"><span class="cls_006">be very handy in terms of cache latency. Physical caches also make it easier to eject lines from the cache.</span></div>
<div style="position:absolute;left:72.00px;top:708.36px" class="cls_006"><span class="cls_006">Their memory location is specified in the line's tag and is independent of process-specific page mapping.</span></div>
<div style="position:absolute;left:72.00px;top:720.48px" class="cls_006"><span class="cls_006">Most processors use physically mapped caches. This makes context switching transparent to the cache; that</span></div>
<div style="position:absolute;left:72.00px;top:732.60px" class="cls_006"><span class="cls_006">is, a context switch need not invalidate cache lines. Physically mapped caches can have better context</span></div>
<div style="position:absolute;left:72.00px;top:744.60px" class="cls_006"><span class="cls_006">switching characteristics than virtual ones, but even with a physically mapped cache there is still a capacity</span></div>
<div style="position:absolute;left:72.00px;top:756.72px" class="cls_006"><span class="cls_006">problem. The cache can hold only so much data. Take, for example, a processor with a 32K-byte L1 cache</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">185</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:169548px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background200.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">with a 32-byte line size. Such a cache has 1,024 cache lines. If a machine with this sort of cache were</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">multiprocessing on a set of 10 processes, then the relative processor residence characteristics of each of</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">these processes would determine the amount of warm data the cache holds when a process is switched into</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">the processor.</span></div>
<div style="position:absolute;left:72.00px;top:133.20px" class="cls_006"><span class="cls_006">Suppose process A is swapped out and process B is swapped in, but B only executes momentarily and is</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_006"><span class="cls_006">then swapped out, and A is swapped back in. In this case you can reasonably expect that the 1,024 cache</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">lines will still contain a reasonably good set of A's context. Conversely, suppose A is switched out because</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">of a page fault. It could be a million cycles before A is runnable again. The other nine processes will</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">probably walk all over the cache in that time and when A makes it back into the processor it is unlikely</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">that any of A's context will still be cache resident. A significant amount of the motivation for the currently</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">spiraling L2 cache sizes is an attempt to build caches large enough to provide a modicum of transcendence</span></div>
<div style="position:absolute;left:72.00px;top:217.68px" class="cls_006"><span class="cls_006">to process cache context.</span></div>
<div style="position:absolute;left:72.00px;top:243.84px" class="cls_006"><span class="cls_006">The data and instruction cache(s) are only one form of cache in most modern processors. Translation-look-</span></div>
<div style="position:absolute;left:72.00px;top:255.84px" class="cls_006"><span class="cls_006">aside buffers (TLBs), caches for a process' page map tables, are another type of cache. TLBs are very</span></div>
<div style="position:absolute;left:72.00px;top:267.96px" class="cls_006"><span class="cls_006">variable in size, sometimes as small as eight entries and sometimes more than hundreds of entries. TLBs</span></div>
<div style="position:absolute;left:72.00px;top:280.08px" class="cls_006"><span class="cls_006">are as system dependent as register sets. Some TLBs are process identification tagged and can transcend a</span></div>
<div style="position:absolute;left:72.00px;top:292.08px" class="cls_006"><span class="cls_006">context switch, and others are not and need to be invalidated on a context switch. Hit rates for TLB tend to</span></div>
<div style="position:absolute;left:72.00px;top:304.20px" class="cls_006"><span class="cls_006">be fairly high, and a single TLB entry can map a significant amount of data. Conversely, TLB misses can</span></div>
<div style="position:absolute;left:72.00px;top:316.20px" class="cls_006"><span class="cls_006">be much more expensive—two to five times more expensive—than cache misses. Cold starts on TLBs are</span></div>
<div style="position:absolute;left:72.00px;top:328.32px" class="cls_006"><span class="cls_006">another significant aspect of the performance cost of context switches. The cost of dynamically recovering</span></div>
<div style="position:absolute;left:72.00px;top:340.44px" class="cls_006"><span class="cls_006">a dozen TLB entries can easily run into the 500-cycle range.</span></div>
<div style="position:absolute;left:72.00px;top:366.48px" class="cls_006"><span class="cls_006">The last major context switch cost is scheduler execution. The scheduler typically is executed as the last</span></div>
<div style="position:absolute;left:72.00px;top:378.60px" class="cls_006"><span class="cls_006">phase of most interrupts. The scheduler will decide whether to continue running the interrupted process, or</span></div>
<div style="position:absolute;left:72.00px;top:390.60px" class="cls_006"><span class="cls_006">whether to load a different process back into the processor. A scheduler is part of an operating system's</span></div>
<div style="position:absolute;left:72.00px;top:402.72px" class="cls_006"><span class="cls_006">core functionality; in fact, the micro-kernel type operating systems have a kernel that is little more than a</span></div>
<div style="position:absolute;left:72.00px;top:414.72px" class="cls_006"><span class="cls_006">scheduler. Although scheduling is relatively straightforward and need not consume a significant number of</span></div>
<div style="position:absolute;left:72.00px;top:426.84px" class="cls_006"><span class="cls_006">operating cycles, there are complications, like process aging and dynamic priority assignment, that</span></div>
<div style="position:absolute;left:72.00px;top:438.96px" class="cls_006"><span class="cls_006">consume something between 50 and 500 cycles.</span></div>
<div style="position:absolute;left:72.00px;top:465.00px" class="cls_006"><span class="cls_006">Thus the first order, explicit cost of a context switch (processor state migration and scheduler execution)</span></div>
<div style="position:absolute;left:72.00px;top:477.12px" class="cls_006"><span class="cls_006">consumes somewhere between 250 and 1000 cycles. Second order, context switch costs (cache and TLB</span></div>
<div style="position:absolute;left:72.00px;top:489.12px" class="cls_006"><span class="cls_006">misses) can consume thousands of additional cycles more. This makes context switches moderately</span></div>
<div style="position:absolute;left:72.00px;top:501.24px" class="cls_006"><span class="cls_006">expensive, and not an event that a high-performance program would invite without good reason.</span></div>
<div style="position:absolute;left:72.00px;top:555.00px" class="cls_016"><span class="cls_016">Kernel Crossing</span></div>
<div style="position:absolute;left:72.00px;top:586.32px" class="cls_006"><span class="cls_006">Asynchronous polling can be a reasonable alternative to synchronous multithreading. Although not as</span></div>
<div style="position:absolute;left:72.00px;top:598.44px" class="cls_006"><span class="cls_006">simple a software technique, it can, on some systems, offer significant performance advantages. The issue</span></div>
<div style="position:absolute;left:72.00px;top:610.44px" class="cls_006"><span class="cls_006">surrounds the cost of kernel crossings relative to context switches. We have already discussed context</span></div>
<div style="position:absolute;left:72.00px;top:622.56px" class="cls_006"><span class="cls_006">switching, so let us now delve into the notion of a kernel crossing.</span></div>
<div style="position:absolute;left:72.00px;top:648.60px" class="cls_006"><span class="cls_006">A kernel crossing occurs when a program explicitly calls a service routine that requires kernel privilege to</span></div>
<div style="position:absolute;left:72.00px;top:660.72px" class="cls_006"><span class="cls_006">execute. When this happens, one of two things happens: a fat system call or a thin system call; depending</span></div>
<div style="position:absolute;left:72.00px;top:672.72px" class="cls_006"><span class="cls_006">on the mechanism employed by the operating system and depending on the type of service requested.</span></div>
<div style="position:absolute;left:72.00px;top:698.88px" class="cls_006"><span class="cls_006">Fat system calls are, in their worst cases, full context switches into the kernel. The process requesting</span></div>
<div style="position:absolute;left:72.00px;top:710.88px" class="cls_006"><span class="cls_006">service is swapped out and the kernel service routine is swapped in. The scheduler typically is executed</span></div>
<div style="position:absolute;left:72.00px;top:723.00px" class="cls_006"><span class="cls_006">after the service routine to determine which process will run next. If the service request was satisfied, the</span></div>
<div style="position:absolute;left:72.00px;top:735.12px" class="cls_006"><span class="cls_006">requesting process is still runnable, the process has not consumed all of its execution quantum (maximum</span></div>
<div style="position:absolute;left:72.00px;top:747.12px" class="cls_006"><span class="cls_006">amount of time a process may continuously occupy the processor), and there is no other process with</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">186</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:170400px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background201.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">higher priority waiting, then the process that requested the service will be swapped back into the processor.</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">Thus servicing the fat system call required almost two full context switches (the scheduler was run only</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">once).</span></div>
<div style="position:absolute;left:72.00px;top:121.20px" class="cls_006"><span class="cls_006">Some kernel service requests can be satisfied without performing a full context switch. A thin system call</span></div>
<div style="position:absolute;left:72.00px;top:133.20px" class="cls_006"><span class="cls_006">need only save a few registers and change the processing priority and level of the system. Such calls can</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_006"><span class="cls_006">perform their work with relatively little impact on performance and return to the calling routine with</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">something that looks like little more than a very expensive method call. The processor vendors are</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">increasingly cognizant of the cost of kernel crossings and are starting to build special purpose kernel entry</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">and exit capabilities into the hardware. Such systems can be in and out of the kernel in a few hundred</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">cycles, roughly an order of magnitude less overhead than a fat kernel crossing.</span></div>
<div style="position:absolute;left:72.00px;top:219.60px" class="cls_006"><span class="cls_006">On systems with efficient kernel entry mechanisms, a dozen asynchronous I/O operations can consume</span></div>
<div style="position:absolute;left:72.00px;top:231.72px" class="cls_006"><span class="cls_006">less time than a single synchronous one. This can make the adoption of a multithreading approach (based</span></div>
<div style="position:absolute;left:72.00px;top:243.84px" class="cls_006"><span class="cls_006">on internally managed I/O vectors within a single monolithic process) an interesting alternative to systems-</span></div>
<div style="position:absolute;left:72.00px;top:255.84px" class="cls_006"><span class="cls_006">managed multithreading. Polling (asynchronous reading and writing) the significant I/O vectors allows a</span></div>
<div style="position:absolute;left:72.00px;top:267.96px" class="cls_006"><span class="cls_006">single program to avoid the locking and serialization frequently necessary in system-managed</span></div>
<div style="position:absolute;left:72.00px;top:280.08px" class="cls_006"><span class="cls_006">multithreading and obviates the need for context switches between threads. If a quick perusal of the I/O</span></div>
<div style="position:absolute;left:72.00px;top:292.08px" class="cls_006"><span class="cls_006">vectors yields no processable data, then a synchronous "select" style I/O call can be employed to put the</span></div>
<div style="position:absolute;left:72.00px;top:304.20px" class="cls_006"><span class="cls_006">process to sleep until additional data arrives. Conversely, if an I/O vector is polled a dozen times without</span></div>
<div style="position:absolute;left:72.00px;top:316.20px" class="cls_006"><span class="cls_006">any change in state, then a context switch would probably have been faster.</span></div>
<div style="position:absolute;left:72.00px;top:370.08px" class="cls_016"><span class="cls_016">Threading Choices</span></div>
<div style="position:absolute;left:72.00px;top:401.40px" class="cls_006"><span class="cls_006">There are three primary threading approaches: monolithic, small-scale, and large-scale. Monolithic</span></div>
<div style="position:absolute;left:72.00px;top:413.40px" class="cls_006"><span class="cls_006">threading, in its simplest incarnation, is just a typical simple program that has only one thread of control.</span></div>
<div style="position:absolute;left:72.00px;top:425.52px" class="cls_006"><span class="cls_006">However, in its more sophisticated forms, monolithically threaded programs can use asynchronous I/O to</span></div>
<div style="position:absolute;left:72.00px;top:437.64px" class="cls_006"><span class="cls_006">perform logically concurrent and independent activities. The monolithic, asynchronous model relies on</span></div>
<div style="position:absolute;left:72.00px;top:449.64px" class="cls_006"><span class="cls_006">structures internal to the program to monitor the state of the program's constituent pieces, and it relies on</span></div>
<div style="position:absolute;left:72.00px;top:461.76px" class="cls_006"><span class="cls_006">polling to test the availability of I/O within those pieces. Using asynchronous I/O guarantees: one, that no</span></div>
<div style="position:absolute;left:72.00px;top:473.76px" class="cls_006"><span class="cls_006">subtask will block the entire task because some I/O request is not immediately satisfied; and two, that the</span></div>
<div style="position:absolute;left:72.00px;top:485.88px" class="cls_006"><span class="cls_006">control element of the program will be able to determine when to relinquish control of the processor and</span></div>
<div style="position:absolute;left:72.00px;top:498.00px" class="cls_006"><span class="cls_006">when to continue processing. Such systems tend to be built around a central control loop that serially</span></div>
<div style="position:absolute;left:72.00px;top:510.00px" class="cls_006"><span class="cls_006">executes each subsystem. This tends to be a very complicated approach, but one that can offer better</span></div>
<div style="position:absolute;left:72.00px;top:522.12px" class="cls_006"><span class="cls_006">performance than its multithreaded peers in some environments. It is also an approach that, when</span></div>
<div style="position:absolute;left:72.00px;top:534.24px" class="cls_006"><span class="cls_006">misapplied, can become lost in fruitless polling cycles that make no progress. Software built on this</span></div>
<div style="position:absolute;left:72.00px;top:546.24px" class="cls_006"><span class="cls_006">asynchronous model allows logically multithreaded structures to be layered on top of operating systems</span></div>
<div style="position:absolute;left:72.00px;top:558.36px" class="cls_006"><span class="cls_006">that do not support multithreading. It can also ease multiplatform porting concerns by removing any</span></div>
<div style="position:absolute;left:72.00px;top:570.36px" class="cls_006"><span class="cls_006">reliance on what may turn out to be divergent, platform-specific, threading characteristics.</span></div>
<div style="position:absolute;left:72.00px;top:596.52px" class="cls_006"><span class="cls_006">Large-scale threading is a mechanism that treats processing requests as independent processing entities.</span></div>
<div style="position:absolute;left:72.00px;top:608.52px" class="cls_006"><span class="cls_006">This can be thought of as the one thread per significant object methodology. Significant objects are, at</span></div>
<div style="position:absolute;left:72.00px;top:620.64px" class="cls_006"><span class="cls_006">birth, allocated their own thread whose sole purpose is to journey with the object from birth to death. This</span></div>
<div style="position:absolute;left:72.00px;top:632.76px" class="cls_006"><span class="cls_006">mechanism can be very effective, but it can also suffer from context switch fever. This approach is perhaps</span></div>
<div style="position:absolute;left:72.00px;top:644.76px" class="cls_006"><span class="cls_006">the simplest conceptually, treating core objects as semi-independent synchronous programs. Unfortunately,</span></div>
<div style="position:absolute;left:72.00px;top:656.88px" class="cls_006"><span class="cls_006">the semi-independence can sometimes be illusory if the threaded objects rely too much on shared resources.</span></div>
<div style="position:absolute;left:72.00px;top:668.88px" class="cls_006"><span class="cls_006">The serialization semaphores necessary to prevent concurrent access to critical code sections can result in</span></div>
<div style="position:absolute;left:72.00px;top:681.00px" class="cls_006"><span class="cls_006">threads burning cycles spinning on locks, on wake-up storms (the system waking up a group of threads</span></div>
<div style="position:absolute;left:72.00px;top:693.12px" class="cls_006"><span class="cls_006">when a resource becomes available only to have all but one of the newly awakened threads go right back to</span></div>
<div style="position:absolute;left:72.00px;top:705.12px" class="cls_006"><span class="cls_006">sleep after consuming a context switch), or both.</span></div>
<div style="position:absolute;left:72.00px;top:731.28px" class="cls_006"><span class="cls_006">Small-scale threading is a mechanism that mixes elements of monolithic threading with elements of large-</span></div>
<div style="position:absolute;left:72.00px;top:743.28px" class="cls_006"><span class="cls_006">scale threading. Small-scale threading tends to be centered more around completion of subtasks than</span></div>
<div style="position:absolute;left:72.00px;top:755.40px" class="cls_006"><span class="cls_006">around the entire completion of individual processing requests. In small-scale threaded environments</span></div>
<div style="position:absolute;left:272.50px;top:791.56px" class="cls_009"><span class="cls_009">Team-Fly</span><span class="cls_010">®</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:171252px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background202.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">objects tend to migrate from thread to thread as they journey from birth to death. Small-scale</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_006"><span class="cls_006">multithreading tends to be more complicated than large-scale multithreading, but it is less likely to suffer</span></div>
<div style="position:absolute;left:72.00px;top:95.04px" class="cls_006"><span class="cls_006">from thread serialization problems, it decreases context switch overhead relative to large-scale threading,</span></div>
<div style="position:absolute;left:72.00px;top:107.16px" class="cls_006"><span class="cls_006">and it tends to provide better scalability than monolithic threading.</span></div>
<div style="position:absolute;left:72.00px;top:133.20px" class="cls_006"><span class="cls_006">Take, for example, a simple program that starts by spawning three threads, one thread to manage input, one</span></div>
<div style="position:absolute;left:72.00px;top:145.32px" class="cls_006"><span class="cls_006">thread to perform the program's primary function, and one thread to manage output. Suppose the threads</span></div>
<div style="position:absolute;left:72.00px;top:157.32px" class="cls_006"><span class="cls_006">communicate via pipes. This is a very respectable model for program execution, but it can be an expensive</span></div>
<div style="position:absolute;left:72.00px;top:169.44px" class="cls_006"><span class="cls_006">paradigm in the wrong situation. Suppose the program is interested primarily in character-based input, and</span></div>
<div style="position:absolute;left:72.00px;top:181.56px" class="cls_006"><span class="cls_006">that the input thread collects characters, performs some simple input filtering and editing, and passes what</span></div>
<div style="position:absolute;left:72.00px;top:193.56px" class="cls_006"><span class="cls_006">it receives on to the central function thread. If input rates are low, this could mean that the program</span></div>
<div style="position:absolute;left:72.00px;top:205.68px" class="cls_006"><span class="cls_006">performs a context switch between the input thread and the central process thread every time a character</span></div>
<div style="position:absolute;left:72.00px;top:217.68px" class="cls_006"><span class="cls_006">arrives. A context switch can cost a thousand instructions. The question must be asked: Would</span></div>
<div style="position:absolute;left:72.00px;top:229.80px" class="cls_006"><span class="cls_006">asynchronously polling the input stream of a monolithic program consume fewer cycles than constant</span></div>
<div style="position:absolute;left:72.00px;top:241.92px" class="cls_006"><span class="cls_006">context switching?</span></div>
<div style="position:absolute;left:72.00px;top:267.96px" class="cls_006"><span class="cls_006">There is no fixed answer. Sometimes the context switching is more expensive and sometimes the</span></div>
<div style="position:absolute;left:72.00px;top:280.08px" class="cls_006"><span class="cls_006">asynchronous polling is more expensive. The right answer for a particular application is wrapped up in a</span></div>
<div style="position:absolute;left:72.00px;top:292.08px" class="cls_006"><span class="cls_006">number of issues. Does processing new input have immediate processing requirements? Is the expected</span></div>
<div style="position:absolute;left:72.00px;top:304.20px" class="cls_006"><span class="cls_006">rate of input high or low? How much input processing can be done in the input thread? On what type of</span></div>
<div style="position:absolute;left:72.00px;top:316.20px" class="cls_006"><span class="cls_006">hardware will I be running? Application of the wrong threading model can significantly impact system</span></div>
<div style="position:absolute;left:72.00px;top:328.32px" class="cls_006"><span class="cls_006">performance, and of course picking the right model can significantly improve performance. Unfortunately,</span></div>
<div style="position:absolute;left:72.00px;top:340.44px" class="cls_006"><span class="cls_006">a program's threading model is not easily changed as part of a post implementation performance</span></div>
<div style="position:absolute;left:72.00px;top:352.44px" class="cls_006"><span class="cls_006">optimization.</span></div>
<div style="position:absolute;left:72.00px;top:378.60px" class="cls_006"><span class="cls_006">Possibly the most significant aspect of the threading decision will be the hardware base upon which the</span></div>
<div style="position:absolute;left:72.00px;top:390.60px" class="cls_006"><span class="cls_006">program is expected to run. Are you writing for a desktop system on which response latency is probably</span></div>
<div style="position:absolute;left:72.00px;top:402.72px" class="cls_006"><span class="cls_006">the most important performance requirement, or are you writing server software, where latency may not be</span></div>
<div style="position:absolute;left:72.00px;top:414.72px" class="cls_006"><span class="cls_006">as critical as throughput, and where resource usage may be more constrained? Does your intended</span></div>
<div style="position:absolute;left:72.00px;top:426.84px" class="cls_006"><span class="cls_006">hardware platform have any specific features that make context switching less expensive? Are you targeted</span></div>
<div style="position:absolute;left:72.00px;top:438.96px" class="cls_006"><span class="cls_006">at multiprocessor systems?</span></div>
<div style="position:absolute;left:72.00px;top:465.00px" class="cls_006"><span class="cls_006">Applications that require minimal response latency are typically better served by synchronous</span></div>
<div style="position:absolute;left:72.00px;top:477.12px" class="cls_006"><span class="cls_006">multithreaded solutions than by asynchronous polled solutions. This is because asynchronous programs</span></div>
<div style="position:absolute;left:72.00px;top:489.12px" class="cls_006"><span class="cls_006">rely on control loops and lack a mechanism to alert themselves when input arrives. The main problem here</span></div>
<div style="position:absolute;left:72.00px;top:501.24px" class="cls_006"><span class="cls_006">is that asynchronously polling a device is not free. It costs cycles. The more you do it and find that there</span></div>
<div style="position:absolute;left:72.00px;top:513.24px" class="cls_006"><span class="cls_006">was nothing there, the poorer the program's performance. The less you look for input, the less performance</span></div>
<div style="position:absolute;left:72.00px;top:525.36px" class="cls_006"><span class="cls_006">the polling loop consumes, but the poorer the program's response latency. If latency is not a concern, then</span></div>
<div style="position:absolute;left:72.00px;top:537.48px" class="cls_006"><span class="cls_006">an asynchronous polled solution may offer the best performance; if latency is a concern, then</span></div>
<div style="position:absolute;left:72.00px;top:549.48px" class="cls_006"><span class="cls_006">multithreading is probably the right direction.</span></div>
<div style="position:absolute;left:72.00px;top:575.64px" class="cls_006"><span class="cls_006">Busy servers are frequently resource constrained. A server may not welcome your program's 1,000</span></div>
<div style="position:absolute;left:72.00px;top:587.64px" class="cls_006"><span class="cls_006">preallocated service threads. Conversely, servers are increasingly multiprocessor systems. Monolithic</span></div>
<div style="position:absolute;left:72.00px;top:599.76px" class="cls_006"><span class="cls_006">software cannot spread itself out across multiple processors like the other models. This can result in idle</span></div>
<div style="position:absolute;left:72.00px;top:611.76px" class="cls_006"><span class="cls_006">processors even when the program is swamped with data.</span></div>
<div style="position:absolute;left:72.00px;top:637.92px" class="cls_006"><span class="cls_006">A new series of processor architectures that will significantly change the effective costs of multithreading</span></div>
<div style="position:absolute;left:72.00px;top:649.92px" class="cls_006"><span class="cls_006">is currently under development. Multithreaded architectures have the capability of performing essentially</span></div>
<div style="position:absolute;left:72.00px;top:662.04px" class="cls_006"><span class="cls_006">zero overhead context switches. This makes it unadvised, in the long term, to accept the complication and</span></div>
<div style="position:absolute;left:72.00px;top:674.16px" class="cls_006"><span class="cls_006">expense of managing a logically synchronous threading model by managing it yourself within an</span></div>
<div style="position:absolute;left:72.00px;top:686.16px" class="cls_006"><span class="cls_006">asynchronous model. In the shorter term, a serious design decision must be made with regard to whether to</span></div>
<div style="position:absolute;left:72.00px;top:698.28px" class="cls_006"><span class="cls_006">use a synchronous model or an asynchronous one. Sadly this is not the type of decision that can be delayed</span></div>
<div style="position:absolute;left:72.00px;top:710.28px" class="cls_006"><span class="cls_006">until after a system is built and then "fixed" as part of the system's profile-based optimization. It is</span></div>
<div style="position:absolute;left:72.00px;top:722.40px" class="cls_006"><span class="cls_006">nontrivial to change a system's threading model, and virtually impossible to alter it conditionally along a</span></div>
<div style="position:absolute;left:72.00px;top:734.52px" class="cls_006"><span class="cls_006">program's critical path. Thread models are very good candidates for prototyping early in the design phase.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">188</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:172104px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background203.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:98.64px" class="cls_016"><span class="cls_016">Key Points</span></div>
<div style="position:absolute;left:90.00px;top:130.20px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   The farther the memory you want to use is from the processor, the longer it takes to access. The</span></div>
<div style="position:absolute;left:108.00px;top:142.32px" class="cls_006"><span class="cls_006">resource closest to the processor, registers, are limited in their capability, but extremely fast. Their</span></div>
<div style="position:absolute;left:108.00px;top:154.32px" class="cls_006"><span class="cls_006">optimization can be very valuable.</span></div>
<div style="position:absolute;left:90.00px;top:166.68px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Virtual memory is not free. Indiscriminate reliance on system maintained virtual structures can</span></div>
<div style="position:absolute;left:108.00px;top:178.80px" class="cls_006"><span class="cls_006">have very significant performance ramifications, typically negative ones.</span></div>
<div style="position:absolute;left:90.00px;top:191.04px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Context switches are expensive; avoid them.</span></div>
<div style="position:absolute;left:90.00px;top:203.40px" class="cls_017"><span class="cls_017">• </span><span class="cls_006">   Lastly, though we are aware that internally managed asynchronous I/O has its place, we also feel</span></div>
<div style="position:absolute;left:108.00px;top:215.52px" class="cls_006"><span class="cls_006">that the coming shift in processor architecture will significantly disadvantage monolithic threading</span></div>
<div style="position:absolute;left:108.00px;top:227.52px" class="cls_006"><span class="cls_006">approaches.</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">189</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:172956px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background204.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:84.60px" class="cls_008"><span class="cls_008">Bibliography</span></div>
<div style="position:absolute;left:72.00px;top:117.84px" class="cls_006"><span class="cls_006">[ALG95] J. Alger. </span><span class="cls_007">Secrets of the C++ Masters</span><span class="cls_006">. AP Professional, Chestnut Hill, MA (1995).</span></div>
<div style="position:absolute;left:72.00px;top:144.00px" class="cls_006"><span class="cls_006">[AHU74] A. Aho, J. Hopcroft, and J. Ullman. </span><span class="cls_007">The Design and Analysis of Computer Algorithms</span><span class="cls_006">. Addison-</span></div>
<div style="position:absolute;left:72.00px;top:156.00px" class="cls_006"><span class="cls_006">Wesley, Reading, MA (1974).</span></div>
<div style="position:absolute;left:72.00px;top:182.16px" class="cls_006"><span class="cls_006">[Ben82] J. L. Bentley. </span><span class="cls_007">Writing Efficient Programs</span><span class="cls_006">. Prentice-Hall, Englewood Cliffs, NJ (1982).</span></div>
<div style="position:absolute;left:72.00px;top:208.20px" class="cls_006"><span class="cls_006">[BM97] B. Meyer. </span><span class="cls_007">Object-Oriented Software Construction, Second Edition</span><span class="cls_006">. Prentice-Hall PTR,</span></div>
<div style="position:absolute;left:72.00px;top:220.32px" class="cls_006"><span class="cls_006">Englewood Cliffs, NJ (1997).</span></div>
<div style="position:absolute;left:72.00px;top:246.36px" class="cls_006"><span class="cls_006">[BR95] A. Binstock and J. Rex. </span><span class="cls_007">Practical Algorithms for Programmers</span><span class="cls_006">. Addison-Wesley, Reading, MA</span></div>
<div style="position:absolute;left:72.00px;top:258.36px" class="cls_006"><span class="cls_006">(1995).</span></div>
<div style="position:absolute;left:72.00px;top:284.52px" class="cls_006"><span class="cls_006">[BR97] R. Booth. </span><span class="cls_007">Inner Loops</span><span class="cls_006">. Addison-Wesley, Reading, MA (1997).</span></div>
<div style="position:absolute;left:72.00px;top:310.56px" class="cls_006"><span class="cls_006">[BW97] J. Beveridge and R. Wiener. </span><span class="cls_007">Multithreading Applications in Win32</span><span class="cls_006">. Addison-Wesley, Reading,</span></div>
<div style="position:absolute;left:72.00px;top:322.68px" class="cls_006"><span class="cls_006">MA (1997).</span></div>
<div style="position:absolute;left:72.00px;top:348.72px" class="cls_006"><span class="cls_006">[Cam91] M. Campbell </span><span class="cls_007">et al</span><span class="cls_006">. </span><span class="cls_007">"The Parallelization of UNIX System V Release 4.0,"</span><span class="cls_006"> </span><span class="cls_007">Proceedings of the</span></div>
<div style="position:absolute;left:72.00px;top:360.84px" class="cls_007"><span class="cls_007">Winter 1991 USENIX Conference</span><span class="cls_006">.</span></div>
<div style="position:absolute;left:72.00px;top:386.88px" class="cls_006"><span class="cls_006">[Car92] T. Cargill. </span><span class="cls_007">C++ Programming Style</span><span class="cls_006">. Addison-Wesley, Reading, MA (1992).</span></div>
<div style="position:absolute;left:72.00px;top:412.92px" class="cls_006"><span class="cls_006">[CE95] M. Carroll and M. Ellis. </span><span class="cls_007">Designing and Coding Reusable C++</span><span class="cls_006">. Addison-Wesley, Reading, MA</span></div>
<div style="position:absolute;left:72.00px;top:425.04px" class="cls_006"><span class="cls_006">(1995).</span></div>
<div style="position:absolute;left:72.00px;top:451.08px" class="cls_006"><span class="cls_006">[CL95] M. P. Cline and G. A. Lomow. </span><span class="cls_007">C++ FAQs: Frequently Asked Questions</span><span class="cls_006">. Addison-Wesley,</span></div>
<div style="position:absolute;left:72.00px;top:463.20px" class="cls_006"><span class="cls_006">Reading, MA (1995).</span></div>
<div style="position:absolute;left:72.00px;top:489.24px" class="cls_006"><span class="cls_006">[CL99] M. Cline, G. Lomow, and M. Girou. </span><span class="cls_007">C++ FAQs, Second Edition</span><span class="cls_006">. Addison-Wesley, Reading, MA,</span></div>
<div style="position:absolute;left:72.00px;top:501.24px" class="cls_006"><span class="cls_006">(1999).</span></div>
<div style="position:absolute;left:72.00px;top:527.40px" class="cls_006"><span class="cls_006">[ES90] M. A. Ellis and B. Stroustrup. </span><span class="cls_007">The Annotated C++ Reference Manual</span><span class="cls_006">. Addison-Wesley, Reading,</span></div>
<div style="position:absolute;left:72.00px;top:539.40px" class="cls_006"><span class="cls_006">MA (1990).</span></div>
<div style="position:absolute;left:72.00px;top:565.56px" class="cls_006"><span class="cls_006">[GH95] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. </span><span class="cls_007">Design Patterns: Elements of Reusable Object-</span></div>
<div style="position:absolute;left:72.00px;top:577.56px" class="cls_007"><span class="cls_007">Oriented Software</span><span class="cls_006">. Addison-Wesley, Reading, MA (1995).</span></div>
<div style="position:absolute;left:72.00px;top:603.72px" class="cls_006"><span class="cls_006">[HP96] J. Hennessy and D. Patterson. </span><span class="cls_007">Computer Architecture: A Quantitative Approach</span><span class="cls_006">. Morgan</span></div>
<div style="position:absolute;left:72.00px;top:615.72px" class="cls_006"><span class="cls_006">Kaufmann, San Francisco, CA, (1996).</span></div>
<div style="position:absolute;left:72.00px;top:641.76px" class="cls_006"><span class="cls_006">[KP74] B. W. Kernighan and P. J. Plauger. </span><span class="cls_007">The Elements of Programming Style</span><span class="cls_006">. McGraw-Hill, New York,</span></div>
<div style="position:absolute;left:72.00px;top:653.88px" class="cls_006"><span class="cls_006">NY (1974).</span></div>
<div style="position:absolute;left:72.00px;top:679.92px" class="cls_006"><span class="cls_006">[KR88] B. W. Kernighan and D. M. Ritchie. </span><span class="cls_007">The C Programming Language, Second Edition</span><span class="cls_006">. Prentice-</span></div>
<div style="position:absolute;left:72.00px;top:692.04px" class="cls_006"><span class="cls_006">Hall, Englewood Cliffs, NJ (1988).</span></div>
<div style="position:absolute;left:72.00px;top:718.08px" class="cls_006"><span class="cls_006">[Knu97] D. E. Knuth. </span><span class="cls_007">The Art of Computer Programming: Fundamental Algorithms, Volume 1, Third</span></div>
<div style="position:absolute;left:72.00px;top:730.20px" class="cls_007"><span class="cls_007">Edition</span><span class="cls_006">. Addison-Wesley, Reading, MA (1997).</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">190</span></div>
</div>
<div style="position:absolute;left:50%;margin-left:-297px;top:173808px;width:595px;height:842px;border-style:outset;overflow:hidden">
<div style="position:absolute;left:0px;top:0px">
<img src="f8a310f0-1821-11eb-8b25-0cc47a792c0a_id_f8a310f0-1821-11eb-8b25-0cc47a792c0a_files/background205.jpg" width=595 height=842></div>
<div style="position:absolute;left:72.00px;top:70.92px" class="cls_006"><span class="cls_006">[Knu97] D. E. Knuth. </span><span class="cls_007">The Art of Computer Programming: Seminumerical Algorithms, Volume 2, Third</span></div>
<div style="position:absolute;left:72.00px;top:83.04px" class="cls_007"><span class="cls_007">Edition</span><span class="cls_006">. Addison-Wesley, Reading, MA (1998).</span></div>
<div style="position:absolute;left:72.00px;top:109.08px" class="cls_006"><span class="cls_006">[Knu97] D. E. Knuth. </span><span class="cls_007">The Art of Computer Programming: Sorting and Searching, Volume 3, Second</span></div>
<div style="position:absolute;left:72.00px;top:121.20px" class="cls_007"><span class="cls_007">Edition</span><span class="cls_006">. Addison-Wesley, Reading, MA (1998).</span></div>
<div style="position:absolute;left:72.00px;top:147.24px" class="cls_006"><span class="cls_006">[Lak96] J. Lakos. </span><span class="cls_007">Large-Scale C++ Software Design</span><span class="cls_006">. Addison-Wesley, Reading, MA (1996).</span></div>
<div style="position:absolute;left:72.00px;top:173.28px" class="cls_006"><span class="cls_006">[Lew1] T. Lewis. </span><span class="cls_007">"The Next 10,000 Years: Part 1,"</span><span class="cls_006"> </span><span class="cls_007">IEEE Computer</span><span class="cls_006">. April 1996.</span></div>
<div style="position:absolute;left:72.00px;top:199.32px" class="cls_006"><span class="cls_006">[Lew2] T. Lewis. </span><span class="cls_007">"The Next 10,000 Years: Part 1,"</span><span class="cls_006"> </span><span class="cls_007">IEEE Computer</span><span class="cls_006">. May 1996.</span></div>
<div style="position:absolute;left:72.00px;top:225.48px" class="cls_006"><span class="cls_006">[Lip91] S. B. Lippman and J. Lajoie. </span><span class="cls_007">C++ Primer, Third Edition</span><span class="cls_006">. Addison-Wesley, Reading, MA (1998).</span></div>
<div style="position:absolute;left:72.00px;top:251.52px" class="cls_006"><span class="cls_006">[Lip96C] S. B. Lippman, Editor. </span><span class="cls_007">C++ Gems</span><span class="cls_006">. SIGS Books and Multimedia (1996).</span></div>
<div style="position:absolute;left:72.00px;top:277.56px" class="cls_006"><span class="cls_006">[Lip96I] S. B. Lippman. </span><span class="cls_007">Inside the C++ Object Model</span><span class="cls_006">. Addison-Wesley, Reading, MA (1996).</span></div>
<div style="position:absolute;left:72.00px;top:303.60px" class="cls_006"><span class="cls_006">[McC93] S. McConnell. </span><span class="cls_007">Code Complete</span><span class="cls_006">. Microsoft Press, Redmond, WA (1993).</span></div>
<div style="position:absolute;left:72.00px;top:329.76px" class="cls_006"><span class="cls_006">[Mey96] S. Meyers. </span><span class="cls_007">More Effective C++</span><span class="cls_006">. Addison-Wesley, Reading, MA (1996).</span></div>
<div style="position:absolute;left:72.00px;top:355.80px" class="cls_006"><span class="cls_006">[Mey97] S. Meyers. </span><span class="cls_007">Effective C++, Second Edition</span><span class="cls_006">. Addison-Wesley, Reading, MA (1998).</span></div>
<div style="position:absolute;left:72.00px;top:381.84px" class="cls_006"><span class="cls_006">[MS96] D. R. Musser and A. Saini. </span><span class="cls_007">STL Tutorial and Reference Guide</span><span class="cls_006">. Addison-Wesley, Reading, MA</span></div>
<div style="position:absolute;left:72.00px;top:393.96px" class="cls_006"><span class="cls_006">(1996).</span></div>
<div style="position:absolute;left:72.00px;top:420.00px" class="cls_006"><span class="cls_006">[Mur93] R. B. Murray. </span><span class="cls_007">C++ Strategies and Tactics</span><span class="cls_006">. Addison-Wesley, Reading, MA (1993).</span></div>
<div style="position:absolute;left:72.00px;top:446.16px" class="cls_006"><span class="cls_006">[NBF96] B. Nichols, D. Buttlar, and J. P. Farrell. </span><span class="cls_007">Pthreads Programming</span><span class="cls_006">. O'Reilly & Associates, Inc.,</span></div>
<div style="position:absolute;left:72.00px;top:458.16px" class="cls_006"><span class="cls_006">Cambridge, MA (1996).</span></div>
<div style="position:absolute;left:72.00px;top:484.20px" class="cls_006"><span class="cls_006">[O98] J. M. Orost. </span><span class="cls_007">"The Bench++ Benchmark Suite,"</span><span class="cls_006"> </span><span class="cls_007">Dr. Dobbs Journal</span><span class="cls_006">, October 1998.</span></div>
<div style="position:absolute;left:72.00px;top:510.36px" class="cls_006"><span class="cls_006">[Pat] D. A. Patterson. </span><span class="cls_007">"Microprocessors in 2020,"</span><span class="cls_006"> </span><span class="cls_007">Scientific American</span><span class="cls_006">, September 1995.</span></div>
<div style="position:absolute;left:72.00px;top:536.40px" class="cls_006"><span class="cls_006">[PH97] D. Patterson and J. Hennessy. </span><span class="cls_007">Computer Organization and Design: The Hardware/Software</span></div>
<div style="position:absolute;left:72.00px;top:548.52px" class="cls_007"><span class="cls_007">Interface</span><span class="cls_006">. Morgan Kaufmann, San Francisco, CA (1997).</span></div>
<div style="position:absolute;left:72.00px;top:574.56px" class="cls_006"><span class="cls_006">[Str97] B. Stroustrup. </span><span class="cls_007">The C++ Programming Language, Third Edition</span><span class="cls_006">. Addison-Wesley, Reading, MA</span></div>
<div style="position:absolute;left:72.00px;top:586.68px" class="cls_006"><span class="cls_006">(1997).</span></div>
<div style="position:absolute;left:288.60px;top:791.64px" class="cls_003"><span class="cls_003">191</span></div>
</div>

</body>
</html>
